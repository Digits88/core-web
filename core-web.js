"format register";



System.register("npm:zone.js@0.4.4/zone", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    (function(exports) {
      'use strict';
      var zone = null;
      function Zone(parentZone, data) {
        var zone = (arguments.length) ? Object.create(parentZone) : this;
        zone.parent = parentZone;
        Object.keys(data || {}).forEach(function(property) {
          var _property = property.substr(1);
          if (property[0] === '$') {
            zone[_property] = data[property](parentZone[_property] || function() {});
          } else if (property[0] === '+') {
            if (parentZone[_property]) {
              zone[_property] = function() {
                var result = parentZone[_property].apply(this, arguments);
                data[property].apply(this, arguments);
                return result;
              };
            } else {
              zone[_property] = data[property];
            }
          } else if (property[0] === '-') {
            if (parentZone[_property]) {
              zone[_property] = function() {
                data[property].apply(this, arguments);
                return parentZone[_property].apply(this, arguments);
              };
            } else {
              zone[_property] = data[property];
            }
          } else {
            zone[property] = (typeof data[property] === 'object') ? JSON.parse(JSON.stringify(data[property])) : data[property];
          }
        });
        zone.$id = ++Zone.nextId;
        return zone;
      }
      Zone.prototype = {
        constructor: Zone,
        fork: function(locals) {
          this.onZoneCreated();
          return new Zone(this, locals);
        },
        bind: function(fn, skipEnqueue) {
          skipEnqueue || this.enqueueTask(fn);
          var zone = this.fork();
          return function zoneBoundFn() {
            return zone.run(fn, this, arguments);
          };
        },
        bindOnce: function(fn) {
          var boundZone = this;
          return this.bind(function() {
            var result = fn.apply(this, arguments);
            boundZone.dequeueTask(fn);
            return result;
          });
        },
        run: function run(fn, applyTo, applyWith) {
          applyWith = applyWith || [];
          var oldZone = zone,
              result;
          exports.zone = zone = this;
          try {
            this.beforeTask();
            result = fn.apply(applyTo, applyWith);
          } catch (e) {
            if (zone.onError) {
              zone.onError(e);
            } else {
              throw e;
            }
          } finally {
            this.afterTask();
            exports.zone = zone = oldZone;
          }
          return result;
        },
        onError: null,
        beforeTask: function() {},
        onZoneCreated: function() {},
        afterTask: function() {},
        enqueueTask: function() {},
        dequeueTask: function() {}
      };
      Zone.patchSetClearFn = function(obj, fnNames) {
        fnNames.map(function(name) {
          return name[0].toUpperCase() + name.substr(1);
        }).forEach(function(name) {
          var setName = 'set' + name;
          var delegate = obj[setName];
          if (delegate) {
            var clearName = 'clear' + name;
            var ids = {};
            var bindArgs = setName === 'setInterval' ? Zone.bindArguments : Zone.bindArgumentsOnce;
            zone[setName] = function(fn) {
              var id,
                  fnRef = fn;
              arguments[0] = function() {
                delete ids[id];
                return fnRef.apply(this, arguments);
              };
              var args = bindArgs(arguments);
              id = delegate.apply(obj, args);
              ids[id] = true;
              return id;
            };
            obj[setName] = function() {
              return zone[setName].apply(this, arguments);
            };
            var clearDelegate = obj[clearName];
            zone[clearName] = function(id) {
              if (ids[id]) {
                delete ids[id];
                zone.dequeueTask();
              }
              return clearDelegate.apply(this, arguments);
            };
            obj[clearName] = function() {
              return zone[clearName].apply(this, arguments);
            };
          }
        });
      };
      Zone.nextId = 1;
      Zone.patchSetFn = function(obj, fnNames) {
        fnNames.forEach(function(name) {
          var delegate = obj[name];
          if (delegate) {
            zone[name] = function(fn) {
              var fnRef = fn;
              arguments[0] = function() {
                return fnRef.apply(this, arguments);
              };
              var args = Zone.bindArgumentsOnce(arguments);
              return delegate.apply(obj, args);
            };
            obj[name] = function() {
              return zone[name].apply(this, arguments);
            };
          }
        });
      };
      Zone.patchPrototype = function(obj, fnNames) {
        fnNames.forEach(function(name) {
          var delegate = obj[name];
          if (delegate) {
            obj[name] = function() {
              return delegate.apply(this, Zone.bindArguments(arguments));
            };
          }
        });
      };
      Zone.bindArguments = function(args) {
        for (var i = args.length - 1; i >= 0; i--) {
          if (typeof args[i] === 'function') {
            args[i] = zone.bind(args[i]);
          }
        }
        return args;
      };
      Zone.bindArgumentsOnce = function(args) {
        for (var i = args.length - 1; i >= 0; i--) {
          if (typeof args[i] === 'function') {
            args[i] = zone.bindOnce(args[i]);
          }
        }
        return args;
      };
      Zone.bindPromiseFn = (function() {
        if (window.Promise) {
          return function(delegate) {
            return function() {
              var delegatePromise = delegate.apply(this, arguments);
              if (delegatePromise instanceof Promise) {
                return delegatePromise;
              } else {
                return new Promise(function(resolve, reject) {
                  delegatePromise.then(resolve, reject);
                });
              }
            };
          };
        } else {
          return function(delegate) {
            return function() {
              return patchThenable(delegate.apply(this, arguments));
            };
          };
        }
        function patchThenable(thenable) {
          var then = thenable.then;
          thenable.then = function() {
            var args = Zone.bindArguments(arguments);
            var nextThenable = then.apply(thenable, args);
            return patchThenable(nextThenable);
          };
          var ocatch = thenable.catch;
          thenable.catch = function() {
            var args = Zone.bindArguments(arguments);
            var nextThenable = ocatch.apply(thenable, args);
            return patchThenable(nextThenable);
          };
          return thenable;
        }
      }());
      Zone.patchableFn = function(obj, fnNames) {
        fnNames.forEach(function(name) {
          var delegate = obj[name];
          zone[name] = function() {
            return delegate.apply(obj, arguments);
          };
          obj[name] = function() {
            return zone[name].apply(this, arguments);
          };
        });
      };
      Zone.patchProperty = function(obj, prop) {
        var desc = Object.getOwnPropertyDescriptor(obj, prop) || {
          enumerable: true,
          configurable: true
        };
        delete desc.writable;
        delete desc.value;
        var eventName = prop.substr(2);
        var _prop = '_' + prop;
        desc.set = function(fn) {
          if (this[_prop]) {
            this.removeEventListener(eventName, this[_prop]);
          }
          if (typeof fn === 'function') {
            this[_prop] = fn;
            this.addEventListener(eventName, fn, false);
          } else {
            this[_prop] = null;
          }
        };
        desc.get = function() {
          return this[_prop];
        };
        Object.defineProperty(obj, prop, desc);
      };
      Zone.patchProperties = function(obj, properties) {
        (properties || (function() {
          var props = [];
          for (var prop in obj) {
            props.push(prop);
          }
          return props;
        }()).filter(function(propertyName) {
          return propertyName.substr(0, 2) === 'on';
        })).forEach(function(eventName) {
          Zone.patchProperty(obj, eventName);
        });
      };
      Zone.patchEventTargetMethods = function(obj) {
        var addDelegate = obj.addEventListener;
        obj.addEventListener = function(eventName, fn) {
          fn._bound = fn._bound || {};
          arguments[1] = fn._bound[eventName] = zone.bind(fn);
          return addDelegate.apply(this, arguments);
        };
        var removeDelegate = obj.removeEventListener;
        obj.removeEventListener = function(eventName, fn) {
          if (arguments[1]._bound && arguments[1]._bound[eventName]) {
            var _bound = arguments[1]._bound;
            arguments[1] = _bound[eventName];
            delete _bound[eventName];
          }
          var result = removeDelegate.apply(this, arguments);
          zone.dequeueTask(fn);
          return result;
        };
      };
      Zone.patch = function patch() {
        Zone.patchSetClearFn(window, ['timeout', 'interval', 'immediate']);
        Zone.patchSetFn(window, ['requestAnimationFrame', 'mozRequestAnimationFrame', 'webkitRequestAnimationFrame']);
        Zone.patchableFn(window, ['alert', 'prompt']);
        if (window.EventTarget) {
          Zone.patchEventTargetMethods(window.EventTarget.prototype);
        } else {
          ['ApplicationCache', 'EventSource', 'FileReader', 'InputMethodContext', 'MediaController', 'MessagePort', 'Node', 'Performance', 'SVGElementInstance', 'SharedWorker', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebKitNamedFlow', 'Window', 'Worker', 'WorkerGlobalScope', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'].filter(function(thing) {
            return window[thing];
          }).map(function(thing) {
            return window[thing].prototype;
          }).forEach(Zone.patchEventTargetMethods);
        }
        if (Zone.canPatchViaPropertyDescriptor()) {
          Zone.patchProperties(HTMLElement.prototype, Zone.onEventNames);
          Zone.patchProperties(XMLHttpRequest.prototype);
          Zone.patchProperties(WebSocket.prototype);
        } else {
          Zone.patchViaCapturingAllTheEvents();
          Zone.patchClass('XMLHttpRequest');
          Zone.patchWebSocket();
        }
        if (window.Promise) {
          Zone.patchPrototype(Promise.prototype, ['then', 'catch']);
        }
        Zone.patchMutationObserverClass('MutationObserver');
        Zone.patchMutationObserverClass('WebKitMutationObserver');
        Zone.patchDefineProperty();
        Zone.patchRegisterElement();
      };
      Zone.canPatchViaPropertyDescriptor = function() {
        if (!Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
          var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
          if (desc && !desc.configurable)
            return false;
        }
        Object.defineProperty(HTMLElement.prototype, 'onclick', {get: function() {
            return true;
          }});
        var elt = document.createElement('div');
        var result = !!elt.onclick;
        Object.defineProperty(HTMLElement.prototype, 'onclick', {});
        return result;
      };
      Zone.patchViaCapturingAllTheEvents = function() {
        Zone.eventNames.forEach(function(property) {
          var onproperty = 'on' + property;
          document.addEventListener(property, function(event) {
            var elt = event.target,
                bound;
            while (elt) {
              if (elt[onproperty] && !elt[onproperty]._unbound) {
                bound = zone.bind(elt[onproperty]);
                bound._unbound = elt[onproperty];
                elt[onproperty] = bound;
              }
              elt = elt.parentElement;
            }
          }, true);
        });
      };
      Zone.patchWebSocket = function() {
        var WS = window.WebSocket;
        Zone.patchEventTargetMethods(WS.prototype);
        window.WebSocket = function(a, b) {
          var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
          var proxySocket;
          var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
          if (onmessageDesc && onmessageDesc.configurable === false) {
            proxySocket = Object.create(socket);
            ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {
              proxySocket[propName] = function() {
                return socket[propName].apply(socket, arguments);
              };
            });
          } else {
            proxySocket = socket;
          }
          Zone.patchProperties(proxySocket, ['onclose', 'onerror', 'onmessage', 'onopen']);
          return proxySocket;
        };
      };
      Zone.patchClass = function(className) {
        var OriginalClass = window[className];
        if (!OriginalClass) {
          return ;
        }
        window[className] = function() {
          var a = Zone.bindArguments(arguments);
          switch (a.length) {
            case 0:
              this._o = new OriginalClass();
              break;
            case 1:
              this._o = new OriginalClass(a[0]);
              break;
            case 2:
              this._o = new OriginalClass(a[0], a[1]);
              break;
            case 3:
              this._o = new OriginalClass(a[0], a[1], a[2]);
              break;
            case 4:
              this._o = new OriginalClass(a[0], a[1], a[2], a[3]);
              break;
            default:
              throw new Error('what are you even doing?');
          }
        };
        var instance = new OriginalClass(className.substr(-16) === 'MutationObserver' ? function() {} : undefined);
        var prop;
        for (prop in instance) {
          (function(prop) {
            if (typeof instance[prop] === 'function') {
              window[className].prototype[prop] = function() {
                return this._o[prop].apply(this._o, arguments);
              };
            } else {
              Object.defineProperty(window[className].prototype, prop, {
                set: function(fn) {
                  if (typeof fn === 'function') {
                    this._o[prop] = zone.bind(fn);
                  } else {
                    this._o[prop] = fn;
                  }
                },
                get: function() {
                  return this._o[prop];
                }
              });
            }
          }(prop));
        }
        ;
      };
      Zone.patchMutationObserverClass = function(className) {
        var OriginalClass = window[className];
        if (!OriginalClass) {
          return ;
        }
        window[className] = function(fn) {
          this._o = new OriginalClass(zone.bind(fn, true));
        };
        var instance = new OriginalClass(function() {});
        window[className].prototype.disconnect = function() {
          var result = this._o.disconnect.apply(this._o, arguments);
          this._active && zone.dequeueTask();
          this._active = false;
          return result;
        };
        window[className].prototype.observe = function() {
          if (!this._active) {
            zone.enqueueTask();
          }
          this._active = true;
          return this._o.observe.apply(this._o, arguments);
        };
        var prop;
        for (prop in instance) {
          (function(prop) {
            if (typeof window[className].prototype !== undefined) {
              return ;
            }
            if (typeof instance[prop] === 'function') {
              window[className].prototype[prop] = function() {
                return this._o[prop].apply(this._o, arguments);
              };
            } else {
              Object.defineProperty(window[className].prototype, prop, {
                set: function(fn) {
                  if (typeof fn === 'function') {
                    this._o[prop] = zone.bind(fn);
                  } else {
                    this._o[prop] = fn;
                  }
                },
                get: function() {
                  return this._o[prop];
                }
              });
            }
          }(prop));
        }
      };
      Zone.patchDefineProperty = function() {
        var _defineProperty = Object.defineProperty;
        var _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var _create = Object.create;
        Object.defineProperty = function(obj, prop, desc) {
          if (isUnconfigurable(obj, prop)) {
            throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
          }
          if (prop !== 'prototype') {
            desc = rewriteDescriptor(obj, prop, desc);
          }
          return _defineProperty(obj, prop, desc);
        };
        Object.defineProperties = function(obj, props) {
          Object.keys(props).forEach(function(prop) {
            Object.defineProperty(obj, prop, props[prop]);
          });
          return obj;
        };
        Object.create = function(obj, proto) {
          if (typeof proto === 'object') {
            Object.keys(proto).forEach(function(prop) {
              proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
            });
          }
          return _create(obj, proto);
        };
        Object.getOwnPropertyDescriptor = function(obj, prop) {
          var desc = _getOwnPropertyDescriptor(obj, prop);
          if (isUnconfigurable(obj, prop)) {
            desc.configurable = false;
          }
          return desc;
        };
        Zone._redefineProperty = function(obj, prop, desc) {
          desc = rewriteDescriptor(obj, prop, desc);
          return _defineProperty(obj, prop, desc);
        };
        function isUnconfigurable(obj, prop) {
          return obj && obj.__unconfigurables && obj.__unconfigurables[prop];
        }
        function rewriteDescriptor(obj, prop, desc) {
          desc.configurable = true;
          if (!desc.configurable) {
            if (!obj.__unconfigurables) {
              _defineProperty(obj, '__unconfigurables', {
                writable: true,
                value: {}
              });
            }
            obj.__unconfigurables[prop] = true;
          }
          return desc;
        }
      };
      Zone.patchRegisterElement = function() {
        if (!('registerElement' in document)) {
          return ;
        }
        var _registerElement = document.registerElement;
        var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];
        document.registerElement = function(name, opts) {
          callbacks.forEach(function(callback) {
            if (opts.prototype[callback]) {
              var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
              if (descriptor.value) {
                descriptor.value = zone.bind(descriptor.value || opts.prototype[callback]);
                Zone._redefineProperty(opts.prototype, callback, descriptor);
              }
            }
          });
          return _registerElement.apply(document, [name, opts]);
        };
      };
      Zone.eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');
      Zone.onEventNames = Zone.eventNames.map(function(property) {
        return 'on' + property;
      });
      Zone.init = function init() {
        exports.zone = zone = new Zone();
        Zone.patch();
      };
      if (window.Zone) {
        console.warn('Zone already exported on window the object!');
      }
      Zone.init();
      exports.Zone = Zone;
    }((typeof module !== 'undefined' && module && module.exports) ? module.exports : window));
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("npm:ms@0.7.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    if ('string' == typeof val)
      return parse(val);
    return options.long ? long(val) : short(val);
  };
  function parse(str) {
    str = '' + str;
    if (str.length > 10000)
      return ;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return ;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  function short(ms) {
    if (ms >= d)
      return Math.round(ms / d) + 'd';
    if (ms >= h)
      return Math.round(ms / h) + 'h';
    if (ms >= m)
      return Math.round(ms / m) + 'm';
    if (ms >= s)
      return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  function plural(ms, n, name) {
    if (ms < n)
      return ;
    if (ms < n * 1.5)
      return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:base64-js@0.0.8/lib/b64", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

System.register("npm:ieee754@1.1.5/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLE ? (nBytes - 1) : 0,
        d = isLE ? -1 : 1,
        s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c,
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
        i = isLE ? 0 : (nBytes - 1),
        d = isLE ? 1 : -1,
        s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:is-array@1.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:inherits@2.0.1/inherits_browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hash@1.1.1/helpers", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var intSize = 4;
    var zeroBuffer = new Buffer(intSize);
    zeroBuffer.fill(0);
    var chrsz = 8;
    function toArray(buf, bigEndian) {
      if ((buf.length % intSize) !== 0) {
        var len = buf.length + (intSize - (buf.length % intSize));
        buf = Buffer.concat([buf, zeroBuffer], len);
      }
      var arr = [];
      var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
      for (var i = 0; i < buf.length; i += intSize) {
        arr.push(fn.call(buf, i));
      }
      return arr;
    }
    function toBuffer(arr, size, bigEndian) {
      var buf = new Buffer(size);
      var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
      for (var i = 0; i < arr.length; i++) {
        fn.call(buf, arr[i], i * 4, true);
      }
      return buf;
    }
    function hash(buf, fn, hashSize, bigEndian) {
      if (!Buffer.isBuffer(buf))
        buf = new Buffer(buf);
      var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
      return toBuffer(arr, hashSize, bigEndian);
    }
    exports.hash = hash;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:ripemd160@1.0.1/lib/ripemd160", ["github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
    var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
    function bytesToWords(bytes) {
      var words = [];
      for (var i = 0,
          b = 0; i < bytes.length; i++, b += 8) {
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      }
      return words;
    }
    function wordsToBytes(words) {
      var bytes = [];
      for (var b = 0; b < words.length * 32; b += 8) {
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      }
      return bytes;
    }
    function processBlock(H, M, offset) {
      for (var i = 0; i < 16; i++) {
        var offset_i = offset + i;
        var M_offset_i = M[offset_i];
        M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
      }
      var al,
          bl,
          cl,
          dl,
          el;
      var ar,
          br,
          cr,
          dr,
          er;
      ar = al = H[0];
      br = bl = H[1];
      cr = cl = H[2];
      dr = dl = H[3];
      er = el = H[4];
      var t;
      for (i = 0; i < 80; i += 1) {
        t = (al + M[offset + zl[i]]) | 0;
        if (i < 16) {
          t += f1(bl, cl, dl) + hl[0];
        } else if (i < 32) {
          t += f2(bl, cl, dl) + hl[1];
        } else if (i < 48) {
          t += f3(bl, cl, dl) + hl[2];
        } else if (i < 64) {
          t += f4(bl, cl, dl) + hl[3];
        } else {
          t += f5(bl, cl, dl) + hl[4];
        }
        t = t | 0;
        t = rotl(t, sl[i]);
        t = (t + el) | 0;
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = t;
        t = (ar + M[offset + zr[i]]) | 0;
        if (i < 16) {
          t += f5(br, cr, dr) + hr[0];
        } else if (i < 32) {
          t += f4(br, cr, dr) + hr[1];
        } else if (i < 48) {
          t += f3(br, cr, dr) + hr[2];
        } else if (i < 64) {
          t += f2(br, cr, dr) + hr[3];
        } else {
          t += f1(br, cr, dr) + hr[4];
        }
        t = t | 0;
        t = rotl(t, sr[i]);
        t = (t + er) | 0;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = t;
      }
      t = (H[1] + cl + dr) | 0;
      H[1] = (H[2] + dl + er) | 0;
      H[2] = (H[3] + el + ar) | 0;
      H[3] = (H[4] + al + br) | 0;
      H[4] = (H[0] + bl + cr) | 0;
      H[0] = t;
    }
    function f1(x, y, z) {
      return ((x) ^ (y) ^ (z));
    }
    function f2(x, y, z) {
      return (((x) & (y)) | ((~x) & (z)));
    }
    function f3(x, y, z) {
      return (((x) | (~(y))) ^ (z));
    }
    function f4(x, y, z) {
      return (((x) & (z)) | ((y) & (~(z))));
    }
    function f5(x, y, z) {
      return ((x) ^ ((y) | (~(z))));
    }
    function rotl(x, n) {
      return (x << n) | (x >>> (32 - n));
    }
    function ripemd160(message) {
      var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
      if (typeof message === 'string') {
        message = new Buffer(message, 'utf8');
      }
      var m = bytesToWords(message);
      var nBitsLeft = message.length * 8;
      var nBitsTotal = message.length * 8;
      m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
      for (var i = 0; i < m.length; i += 16) {
        processBlock(H, m, i);
      }
      for (i = 0; i < 5; i++) {
        var H_i = H[i];
        H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
      }
      var digestbytes = wordsToBytes(H);
      return new Buffer(digestbytes);
    }
    module.exports = ripemd160;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/hash", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function Hash(blockSize, finalSize) {
      this._block = new Buffer(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
      this._s = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = new Buffer(data, enc);
      }
      var l = this._len += data.length;
      var s = this._s || 0;
      var f = 0;
      var buffer = this._block;
      while (s < l) {
        var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize));
        var ch = (t - f);
        for (var i = 0; i < ch; i++) {
          buffer[(s % this._blockSize) + i] = data[i + f];
        }
        s += ch;
        f += ch;
        if ((s % this._blockSize) === 0) {
          this._update(buffer);
        }
      }
      this._s = s;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var l = this._len * 8;
      this._block[this._len % this._blockSize] = 0x80;
      this._block.fill(0, this._len % this._blockSize + 1);
      if (l % (this._blockSize * 8) >= this._finalSize * 8) {
        this._update(this._block);
        this._block.fill(0);
      }
      this._block.writeInt32BE(l, this._blockSize - 4);
      var hash = this._update(this._block) || this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error('_update must be implemented by subclass');
    };
    module.exports = Hash;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha1", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 0x67452301 | 0;
      this._b = 0xefcdab89 | 0;
      this._c = 0x98badcfe | 0;
      this._d = 0x10325476 | 0;
      this._e = 0xc3d2e1f0 | 0;
      return this;
    };
    function rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt));
    }
    Sha1.prototype._update = function(M) {
      var W = this._w;
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      var e = this._e;
      var j = 0,
          k;
      function calcW() {
        return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1);
      }
      function loop(w, f) {
        W[j] = w;
        var t = rol(a, 5) + f + e + w + k;
        e = d;
        d = c;
        c = rol(b, 30);
        b = a;
        a = t;
        j++;
      }
      k = 1518500249;
      while (j < 16)
        loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d));
      while (j < 20)
        loop(calcW(), (b & c) | ((~b) & d));
      k = 1859775393;
      while (j < 40)
        loop(calcW(), b ^ c ^ d);
      k = -1894007588;
      while (j < 60)
        loop(calcW(), (b & c) | (b & d) | (c & d));
      k = -899497514;
      while (j < 80)
        loop(calcW(), b ^ c ^ d);
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };
    Sha1.prototype._hash = function() {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha256", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 0x6a09e667 | 0;
      this._b = 0xbb67ae85 | 0;
      this._c = 0x3c6ef372 | 0;
      this._d = 0xa54ff53a | 0;
      this._e = 0x510e527f | 0;
      this._f = 0x9b05688c | 0;
      this._g = 0x1f83d9ab | 0;
      this._h = 0x5be0cd19 | 0;
      return this;
    };
    function S(X, n) {
      return (X >>> n) | (X << (32 - n));
    }
    function R(X, n) {
      return (X >>> n);
    }
    function Ch(x, y, z) {
      return ((x & y) ^ ((~x) & z));
    }
    function Maj(x, y, z) {
      return ((x & y) ^ (x & z) ^ (y & z));
    }
    function Sigma0256(x) {
      return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
    }
    function Sigma1256(x) {
      return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
    }
    function Gamma0256(x) {
      return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
    }
    function Gamma1256(x) {
      return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
    }
    Sha256.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      var j = 0;
      function calcW() {
        return Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16];
      }
      function loop(w) {
        W[j] = w;
        var T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w;
        var T2 = Sigma0256(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + T1;
        d = c;
        c = b;
        b = a;
        a = T1 + T2;
        j++;
      }
      while (j < 16)
        loop(M.readInt32BE(j * 4));
      while (j < 64)
        loop(calcW());
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
      this._f = (f + this._f) | 0;
      this._g = (g + this._g) | 0;
      this._h = (h + this._h) | 0;
    };
    Sha256.prototype._hash = function() {
      var H = new Buffer(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha512", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._a = 0x6a09e667 | 0;
      this._b = 0xbb67ae85 | 0;
      this._c = 0x3c6ef372 | 0;
      this._d = 0xa54ff53a | 0;
      this._e = 0x510e527f | 0;
      this._f = 0x9b05688c | 0;
      this._g = 0x1f83d9ab | 0;
      this._h = 0x5be0cd19 | 0;
      this._al = 0xf3bcc908 | 0;
      this._bl = 0x84caa73b | 0;
      this._cl = 0xfe94f82b | 0;
      this._dl = 0x5f1d36f1 | 0;
      this._el = 0xade682d1 | 0;
      this._fl = 0x2b3e6c1f | 0;
      this._gl = 0xfb41bd6b | 0;
      this._hl = 0x137e2179 | 0;
      return this;
    };
    function S(X, Xl, n) {
      return (X >>> n) | (Xl << (32 - n));
    }
    function Ch(x, y, z) {
      return ((x & y) ^ ((~x) & z));
    }
    function Maj(x, y, z) {
      return ((x & y) ^ (x & z) ^ (y & z));
    }
    Sha512.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      var i = 0,
          j = 0;
      var Wi,
          Wil;
      function calcW() {
        var x = W[j - 15 * 2];
        var xl = W[j - 15 * 2 + 1];
        var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7);
        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7);
        x = W[j - 2 * 2];
        xl = W[j - 2 * 2 + 1];
        var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6);
        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6);
        var Wi7 = W[j - 7 * 2];
        var Wi7l = W[j - 7 * 2 + 1];
        var Wi16 = W[j - 16 * 2];
        var Wi16l = W[j - 16 * 2 + 1];
        Wil = gamma0l + Wi7l;
        Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
        Wil = Wil + gamma1l;
        Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
        Wil = Wil + Wi16l;
        Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
      }
      function loop() {
        W[j] = Wi;
        W[j + 1] = Wil;
        var maj = Maj(a, b, c);
        var majl = Maj(al, bl, cl);
        var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7);
        var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7);
        var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9);
        var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9);
        var Ki = K[j];
        var Kil = K[j + 1];
        var ch = Ch(e, f, g);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l;
        var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
        t1l = t1l + chl;
        t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
        t1l = t1l + Kil;
        t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
        t1l = t1l + Wil;
        t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
        var t2l = sigma0l + majl;
        var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
        h = g;
        hl = gl;
        g = f;
        gl = fl;
        f = e;
        fl = el;
        el = (dl + t1l) | 0;
        e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
        d = c;
        dl = cl;
        c = b;
        cl = bl;
        b = a;
        bl = al;
        al = (t1l + t2l) | 0;
        a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
        i++;
        j += 2;
      }
      while (i < 16) {
        Wi = M.readInt32BE(j * 4);
        Wil = M.readInt32BE(j * 4 + 4);
        loop();
      }
      while (i < 80) {
        calcW();
        loop();
      }
      this._al = (this._al + al) | 0;
      this._bl = (this._bl + bl) | 0;
      this._cl = (this._cl + cl) | 0;
      this._dl = (this._dl + dl) | 0;
      this._el = (this._el + el) | 0;
      this._fl = (this._fl + fl) | 0;
      this._gl = (this._gl + gl) | 0;
      this._hl = (this._hl + hl) | 0;
      this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0;
      this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;
      this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;
      this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
      this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0;
      this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;
      this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;
      this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = new Buffer(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._a, this._al, 0);
      writeInt64BE(this._b, this._bl, 8);
      writeInt64BE(this._c, this._cl, 16);
      writeInt64BE(this._d, this._dl, 24);
      writeInt64BE(this._e, this._el, 32);
      writeInt64BE(this._f, this._fl, 40);
      writeInt64BE(this._g, this._gl, 48);
      writeInt64BE(this._h, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:events@1.0.2/events", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function(type) {
    var er,
        handler,
        len,
        args,
        i,
        listeners;
    if (!this._events)
      this._events = {};
    if (type === 'error') {
      if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (isUndefined(handler))
      return false;
    if (isFunction(handler)) {
      switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    var m;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events)
      this._events = {};
    if (this._events.newListener)
      this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      this._events[type].push(listener);
    else
      this._events[type] = [this._events[type], listener];
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          console.trace();
        }
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list,
        position,
        length,
        i;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
      return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0; ) {
        if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function(type) {
    var key,
        listeners;
    if (!this._events)
      return this;
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener')
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:isarray@0.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-util-is@1.0.1/lib/util", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/lib/_stream_writable", ["github:jspm/nodelibs-buffer@0.1.0", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "npm:stream-browserify@1.0.0/index", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:readable-stream@1.1.13/lib/_stream_duplex", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Writable;
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0").Buffer;
    Writable.WritableState = WritableState;
    var util = require("npm:core-util-is@1.0.1");
    util.inherits = require("npm:inherits@2.0.1");
    var Stream = require("npm:stream-browserify@1.0.0/index");
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {};
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return (state.ending && state.length === 0 && !state.finished && !state.writing);
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:string_decoder@0.10.31/index", ["github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0").Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return ;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = (buffer.length >= 3) ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/lib/_stream_transform", ["npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Transform;
    var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
    var util = require("npm:core-util-is@1.0.1");
    util.inherits = require("npm:inherits@2.0.1");
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/lib/_stream_passthrough", ["npm:readable-stream@1.1.13/lib/_stream_transform", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = require("npm:readable-stream@1.1.13/lib/_stream_transform");
  var util = require("npm:core-util-is@1.0.1");
  util.inherits = require("npm:inherits@2.0.1");
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/writable", ["npm:readable-stream@1.1.13/lib/_stream_writable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_writable");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/duplex", ["npm:readable-stream@1.1.13/lib/_stream_duplex"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/transform", ["npm:readable-stream@1.1.13/lib/_stream_transform"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_transform");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/passthrough", ["npm:readable-stream@1.1.13/lib/_stream_passthrough"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:readable-stream@1.1.13/lib/_stream_passthrough");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hmac@1.1.3/browser", ["npm:create-hash@1.1.1/browser", "npm:inherits@2.0.1", "github:jspm/nodelibs-stream@0.1.0", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var createHash = require("npm:create-hash@1.1.1/browser");
    var inherits = require("npm:inherits@2.0.1");
    var Transform = require("github:jspm/nodelibs-stream@0.1.0").Transform;
    var ZEROS = new Buffer(128);
    ZEROS.fill(0);
    function Hmac(alg, key) {
      Transform.call(this);
      if (typeof key === 'string') {
        key = new Buffer(key);
      }
      var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = createHash(alg).update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = new Buffer(blocksize);
      var opad = this._opad = new Buffer(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
      }
      this._hash = createHash(alg).update(ipad);
    }
    inherits(Hmac, Transform);
    Hmac.prototype.update = function(data, enc) {
      this._hash.update(data, enc);
      return this;
    };
    Hmac.prototype._transform = function(data, _, next) {
      this._hash.update(data);
      next();
    };
    Hmac.prototype._flush = function(next) {
      this.push(this.digest());
      next();
    };
    Hmac.prototype.digest = function(enc) {
      var h = this._hash.digest();
      return createHash(this._alg).update(this._opad).update(h).digest(enc);
    };
    module.exports = function createHmac(alg, key) {
      return new Hmac(alg, key);
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2/algos", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha224',
      id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
    };
    exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha256',
      id: new Buffer('3031300d060960864801650304020105000420', 'hex')
    };
    exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha384',
      id: new Buffer('3041300d060960864801650304020205000430', 'hex')
    };
    exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha512',
      id: new Buffer('3051300d060960864801650304020305000440', 'hex')
    };
    exports['RSA-SHA1'] = {
      sign: 'rsa',
      hash: 'sha1',
      id: new Buffer('3021300906052b0e03021a05000414', 'hex')
    };
    exports['ecdsa-with-SHA1'] = {
      sign: 'ecdsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
      sign: 'dsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
      sign: 'dsa',
      hash: 'sha224',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
      sign: 'dsa',
      hash: 'sha256',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
      sign: 'dsa',
      hash: 'sha384',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
      sign: 'dsa',
      hash: 'sha512',
      id: new Buffer('', 'hex')
    };
    exports['DSA-RIPEMD160'] = {
      sign: 'dsa',
      hash: 'rmd160',
      id: new Buffer('', 'hex')
    };
    exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
      sign: 'rsa',
      hash: 'rmd160',
      id: new Buffer('3021300906052b2403020105000414', 'hex')
    };
    exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
      sign: 'rsa',
      hash: 'md5',
      id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:pbkdf2@3.0.4/browser", ["npm:create-hmac@1.1.3", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var createHmac = require("npm:create-hmac@1.1.3");
    var MAX_ALLOC = Math.pow(2, 30) - 1;
    exports.pbkdf2 = pbkdf2;
    function pbkdf2(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === 'function') {
        callback = digest;
        digest = undefined;
      }
      if (typeof callback !== 'function') {
        throw new Error('No callback provided to pbkdf2');
      }
      var result = pbkdf2Sync(password, salt, iterations, keylen, digest);
      setTimeout(function() {
        callback(undefined, result);
      });
    }
    exports.pbkdf2Sync = pbkdf2Sync;
    function pbkdf2Sync(password, salt, iterations, keylen, digest) {
      if (typeof iterations !== 'number') {
        throw new TypeError('Iterations not a number');
      }
      if (iterations < 0) {
        throw new TypeError('Bad iterations');
      }
      if (typeof keylen !== 'number') {
        throw new TypeError('Key length not a number');
      }
      if (keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError('Bad key length');
      }
      digest = digest || 'sha1';
      if (!Buffer.isBuffer(password))
        password = new Buffer(password, 'binary');
      if (!Buffer.isBuffer(salt))
        salt = new Buffer(salt, 'binary');
      var hLen;
      var l = 1;
      var DK = new Buffer(keylen);
      var block1 = new Buffer(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var r;
      var T;
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length);
        var U = createHmac(digest, password).update(block1).digest();
        if (!hLen) {
          hLen = U.length;
          T = new Buffer(hLen);
          l = Math.ceil(keylen / hLen);
          r = keylen - (l - 1) * hLen;
        }
        U.copy(T, 0, 0, hLen);
        for (var j = 1; j < iterations; j++) {
          U = createHmac(digest, password).update(U).digest();
          for (var k = 0; k < hLen; k++) {
            T[k] ^= U[k];
          }
        }
        var destPos = (i - 1) * hLen;
        var len = (i === l ? r : hLen);
        T.copy(DK, destPos, 0, len);
      }
      return DK;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/aes", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret,
          x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function scrub_vec(v) {
      for (var i = 0; i < v.length; v++) {
        v[i] = 0;
      }
      return false;
    }
    function Global() {
      this.SBOX = [];
      this.INV_SBOX = [];
      this.SUB_MIX = [[], [], [], []];
      this.INV_SUB_MIX = [[], [], [], []];
      this.init();
      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    }
    Global.prototype.init = function() {
      var d,
          i,
          sx,
          t,
          x,
          x2,
          x4,
          x8,
          xi,
          _i;
      d = (function() {
        var _i,
            _results;
        _results = [];
        for (i = _i = 0; _i < 256; i = ++_i) {
          if (i < 128) {
            _results.push(i << 1);
          } else {
            _results.push((i << 1) ^ 0x11b);
          }
        }
        return _results;
      })();
      x = 0;
      xi = 0;
      for (i = _i = 0; _i < 256; i = ++_i) {
        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
        this.SBOX[x] = sx;
        this.INV_SBOX[sx] = x;
        x2 = d[x];
        x4 = d[x2];
        x8 = d[x4];
        t = (d[sx] * 0x101) ^ (sx * 0x1010100);
        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
        this.SUB_MIX[3][x] = t;
        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
        this.INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return true;
    };
    var G = new Global();
    AES.blockSize = 4 * 4;
    AES.prototype.blockSize = AES.blockSize;
    AES.keySize = 256 / 8;
    AES.prototype.keySize = AES.keySize;
    function bufferToArray(buf) {
      var len = buf.length / 4;
      var out = new Array(len);
      var i = -1;
      while (++i < len) {
        out[i] = buf.readUInt32BE(i * 4);
      }
      return out;
    }
    function AES(key) {
      this._key = bufferToArray(key);
      this._doReset();
    }
    AES.prototype._doReset = function() {
      var invKsRow,
          keySize,
          keyWords,
          ksRow,
          ksRows,
          t;
      keyWords = this._key;
      keySize = keyWords.length;
      this._nRounds = keySize + 6;
      ksRows = (this._nRounds + 1) * 4;
      this._keySchedule = [];
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
      }
      this._invKeySchedule = [];
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
      }
      return true;
    };
    AES.prototype.encryptBlock = function(M) {
      M = bufferToArray(new Buffer(M));
      var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function(M) {
      M = bufferToArray(new Buffer(M));
      var temp = [M[3], M[1]];
      M[1] = temp[0];
      M[3] = temp[1];
      var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function() {
      scrub_vec(this._keySchedule);
      scrub_vec(this._invKeySchedule);
      scrub_vec(this._key);
    };
    AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
      var ksRow,
          s0,
          s1,
          s2,
          s3,
          t0,
          t1,
          t2,
          t3;
      s0 = M[0] ^ keySchedule[0];
      s1 = M[1] ^ keySchedule[1];
      s2 = M[2] ^ keySchedule[2];
      s3 = M[3] ^ keySchedule[3];
      ksRow = 4;
      for (var round = 1; round < this._nRounds; round++) {
        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      return [fixup_uint32(t0), fixup_uint32(t1), fixup_uint32(t2), fixup_uint32(t3)];
    };
    exports.AES = AES;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/cipherBase", ["github:jspm/nodelibs-stream@0.1.0", "npm:inherits@2.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Transform = require("github:jspm/nodelibs-stream@0.1.0").Transform;
    var inherits = require("npm:inherits@2.0.1");
    module.exports = CipherBase;
    inherits(CipherBase, Transform);
    function CipherBase() {
      Transform.call(this);
    }
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === 'string') {
        data = new Buffer(data, inputEnc);
      }
      var outData = this._update(data);
      if (outputEnc) {
        outData = outData.toString(outputEnc);
      }
      return outData;
    };
    CipherBase.prototype._transform = function(data, _, next) {
      this.push(this._update(data));
      next();
    };
    CipherBase.prototype._flush = function(next) {
      try {
        this.push(this._final());
      } catch (e) {
        return next(e);
      }
      next();
    };
    CipherBase.prototype.final = function(outputEnc) {
      var outData = this._final() || new Buffer('');
      if (outputEnc) {
        outData = outData.toString(outputEnc);
      }
      return outData;
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports['aes-128-ecb'] = {
    cipher: 'AES',
    key: 128,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-192-ecb'] = {
    cipher: 'AES',
    key: 192,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-256-ecb'] = {
    cipher: 'AES',
    key: 256,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-128-cbc'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-192-cbc'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-256-cbc'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes128'] = exports['aes-128-cbc'];
  exports['aes192'] = exports['aes-192-cbc'];
  exports['aes256'] = exports['aes-256-cbc'];
  exports['aes-128-cfb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-192-cfb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-256-cfb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-128-cfb8'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-192-cfb8'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-256-cfb8'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-128-cfb1'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-192-cfb1'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-256-cfb1'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-128-ofb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-192-ofb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-256-ofb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-128-ctr'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-192-ctr'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-256-ctr'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-128-gcm'] = {
    cipher: 'AES',
    key: 128,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-192-gcm'] = {
    cipher: 'AES',
    key: 192,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-256-gcm'] = {
    cipher: 'AES',
    key: 256,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/EVP_BytesToKey", ["npm:create-hash@1.1.1/md5", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var md5 = require("npm:create-hash@1.1.1/md5");
    module.exports = EVP_BytesToKey;
    function EVP_BytesToKey(password, keyLen, ivLen) {
      if (!Buffer.isBuffer(password)) {
        password = new Buffer(password, 'binary');
      }
      keyLen = keyLen / 8;
      ivLen = ivLen || 0;
      var ki = 0;
      var ii = 0;
      var key = new Buffer(keyLen);
      var iv = new Buffer(ivLen);
      var addmd = 0;
      var md_buf;
      var i;
      var bufs = [];
      while (true) {
        if (addmd++ > 0) {
          bufs.push(md_buf);
        }
        bufs.push(password);
        md_buf = md5(Buffer.concat(bufs));
        bufs = [];
        i = 0;
        if (keyLen > 0) {
          while (true) {
            if (keyLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            key[ki++] = md_buf[i];
            keyLen--;
            i++;
          }
        }
        if (ivLen > 0 && i !== md_buf.length) {
          while (true) {
            if (ivLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            iv[ii++] = md_buf[i];
            ivLen--;
            i++;
          }
        }
        if (keyLen === 0 && ivLen === 0) {
          break;
        }
      }
      for (i = 0; i < md_buf.length; i++) {
        md_buf[i] = 0;
      }
      return {
        key: key,
        iv: iv
      };
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/streamCipher", ["npm:browserify-aes@1.0.1/aes", "npm:browserify-aes@1.0.1/cipherBase", "npm:inherits@2.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = require("npm:browserify-aes@1.0.1/aes");
    var Transform = require("npm:browserify-aes@1.0.1/cipherBase");
    var inherits = require("npm:inherits@2.0.1");
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      iv.copy(this._prev);
      this._mode = mode;
    }
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/ghash", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var zeros = new Buffer(16);
    zeros.fill(0);
    module.exports = GHASH;
    function GHASH(key) {
      this.h = key;
      this.state = new Buffer(16);
      this.state.fill(0);
      this.cache = new Buffer('');
    }
    GHASH.prototype.ghash = function(block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j,
          xi,
          lsb_Vi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0;
        if (xi) {
          Zi = xor(Zi, Vi);
        }
        lsb_Vi = (Vi[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsb_Vi) {
          Vi[0] = Vi[0] ^ (0xe1 << 24);
        }
      }
      this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function(buf) {
      this.cache = Buffer.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer.concat([this.cache, zeros], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl]));
      return this.state;
    };
    function toArray(buf) {
      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
    }
    function fromArray(out) {
      out = out.map(fixup_uint32);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    }
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret,
          x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function xor(a, b) {
      return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/xor", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    module.exports = xor;
    function xor(a, b) {
      var len = Math.min(a.length, b.length);
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out.writeUInt8(a[i] ^ b[i], i);
      }
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/ecb", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
  };
  exports.decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/cbc", ["npm:browserify-aes@1.0.1/xor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var xor = require("npm:browserify-aes@1.0.1/xor");
  exports.encrypt = function(self, block) {
    var data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
  };
  exports.decrypt = function(self, block) {
    var pad = self._prev;
    self._prev = block;
    var out = self._cipher.decryptBlock(block);
    return xor(out, pad);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/cfb", ["npm:browserify-aes@1.0.1/xor", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = require("npm:browserify-aes@1.0.1/xor");
    exports.encrypt = function(self, data, decrypt) {
      var out = new Buffer('');
      var len;
      while (data.length) {
        if (self._cache.length === 0) {
          self._cache = self._cipher.encryptBlock(self._prev);
          self._prev = new Buffer('');
        }
        if (self._cache.length <= data.length) {
          len = self._cache.length;
          out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
          data = data.slice(len);
        } else {
          out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
          break;
        }
      }
      return out;
    };
    function encryptStart(self, data, decrypt) {
      var len = data.length;
      var out = xor(data, self._cache);
      self._cache = self._cache.slice(len);
      self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/cfb8", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad = self._cipher.encryptBlock(self._prev);
      var out = pad[0] ^ byteParam;
      self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])]);
      return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/cfb1", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad;
      var i = -1;
      var len = 8;
      var out = 0;
      var bit,
          value;
      while (++i < len) {
        pad = self._cipher.encryptBlock(self._prev);
        bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += ((value & 0x80) >> (i % 8));
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
      }
      return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
    function shiftIn(buffer, value) {
      var len = buffer.length;
      var i = -1;
      var out = new Buffer(buffer.length);
      buffer = Buffer.concat([buffer, new Buffer([value])]);
      while (++i < len) {
        out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
      }
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/ofb", ["npm:browserify-aes@1.0.1/xor", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = require("npm:browserify-aes@1.0.1/xor");
    function getBlock(self) {
      self._prev = self._cipher.encryptBlock(self._prev);
      return self._prev;
    }
    exports.encrypt = function(self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/modes/ctr", ["npm:browserify-aes@1.0.1/xor", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = require("npm:browserify-aes@1.0.1/xor");
    function getBlock(self) {
      var out = self._cipher.encryptBlock(self._prev);
      incr32(self._prev);
      return out;
    }
    exports.encrypt = function(self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/decrypter", ["npm:browserify-aes@1.0.1/aes", "npm:browserify-aes@1.0.1/cipherBase", "npm:inherits@2.0.1", "npm:browserify-aes@1.0.1/modes", "npm:browserify-aes@1.0.1/streamCipher", "npm:browserify-aes@1.0.1/authCipher", "npm:browserify-aes@1.0.1/EVP_BytesToKey", "npm:browserify-aes@1.0.1/modes/ecb", "npm:browserify-aes@1.0.1/modes/cbc", "npm:browserify-aes@1.0.1/modes/cfb", "npm:browserify-aes@1.0.1/modes/cfb8", "npm:browserify-aes@1.0.1/modes/cfb1", "npm:browserify-aes@1.0.1/modes/ofb", "npm:browserify-aes@1.0.1/modes/ctr", "npm:browserify-aes@1.0.1/modes/ctr", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = require("npm:browserify-aes@1.0.1/aes");
    var Transform = require("npm:browserify-aes@1.0.1/cipherBase");
    var inherits = require("npm:inherits@2.0.1");
    var modes = require("npm:browserify-aes@1.0.1/modes");
    var StreamCipher = require("npm:browserify-aes@1.0.1/streamCipher");
    var AuthCipher = require("npm:browserify-aes@1.0.1/authCipher");
    var ebtk = require("npm:browserify-aes@1.0.1/EVP_BytesToKey");
    inherits(Decipher, Transform);
    function Decipher(mode, key, iv) {
      if (!(this instanceof Decipher)) {
        return new Decipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while ((chunk = this._cache.get(this._autopadding))) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error('data not multiple of block length');
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length) {
        return this.cache;
      }
    };
    function unpad(last) {
      var padded = last[15];
      var i = -1;
      while (++i < padded) {
        if (last[(i + (16 - padded))] !== padded) {
          throw new Error('unable to decrypt data');
        }
      }
      if (padded === 16) {
        return ;
      }
      return last.slice(0, 16 - padded);
    }
    var modelist = {
      ECB: require("npm:browserify-aes@1.0.1/modes/ecb"),
      CBC: require("npm:browserify-aes@1.0.1/modes/cbc"),
      CFB: require("npm:browserify-aes@1.0.1/modes/cfb"),
      CFB8: require("npm:browserify-aes@1.0.1/modes/cfb8"),
      CFB1: require("npm:browserify-aes@1.0.1/modes/cfb1"),
      OFB: require("npm:browserify-aes@1.0.1/modes/ofb"),
      CTR: require("npm:browserify-aes@1.0.1/modes/ctr"),
      GCM: require("npm:browserify-aes@1.0.1/modes/ctr")
    };
    function createDecipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv, true);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv, true);
      }
      return new Decipher(modelist[config.mode], password, iv);
    }
    function createDecipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, config.key, config.iv);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    exports.createDecipher = createDecipher;
    exports.createDecipheriv = createDecipheriv;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:bn.js@2.0.5/lib/bn", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(module, exports) {
    'use strict';
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || 'Assertion failed');
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base, endian) {
      if (number !== null && typeof number === 'object' && Array.isArray(number.words)) {
        return number;
      }
      this.sign = false;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }
      if (number !== null)
        this._init(number || 0, base || 10, endian || 'be');
    }
    if (typeof module === 'object')
      module.exports = BN;
    else
      exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === 'number') {
        if (number < 0) {
          this.sign = true;
          number = -number;
        }
        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000);
          this.words = [number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff, 1];
          this.length = 3;
        }
        return ;
      } else if (typeof number === 'object') {
        return this._initArray(number, base, endian);
      }
      if (base === 'hex')
        base = 16;
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, '');
      var start = 0;
      if (number[0] === '-')
        start++;
      if (base === 16)
        this._parseHex(number, start);
      else
        this._parseBase(number, base, start);
      if (number[0] === '-')
        this.sign = true;
      this.strip();
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      assert(typeof number.length === 'number');
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        this.words[i] = 0;
      var off = 0;
      if (endian === 'be') {
        for (var i = number.length - 1,
            j = 0; i >= 0; i -= 3) {
          var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (var i = 0,
            j = 0; i < number.length; i += 3) {
          var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex(str, start, end) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r <<= 4;
        if (c >= 49 && c <= 54)
          r |= c - 49 + 0xa;
        else if (c >= 17 && c <= 22)
          r |= c - 17 + 0xa;
        else
          r |= c & 0xf;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        this.words[i] = 0;
      var off = 0;
      for (var i = number.length - 6,
          j = 0; i >= start; i -= 6) {
        var w = parseHex(number, i, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
      if (i + 6 !== start) {
        var w = parseHex(number, start, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      }
      this.strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49)
          r += c - 49 + 0xa;
        else if (c >= 17)
          r += c - 17 + 0xa;
        else
          r += c;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0,
          limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
        limbLen++;
      limbLen--;
      limbPow = (limbPow / base) | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000)
          this.words[0] += word;
        else
          this._iaddn(word);
      }
      if (mod !== 0) {
        var pow = 1;
        var word = parseBase(number, i, number.length, base);
        for (var i = 0; i < mod; i++)
          pow *= base;
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000)
          this.words[0] += word;
        else
          this._iaddn(word);
      }
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        dest.words[i] = this.words[i];
      dest.length = this.length;
      dest.sign = this.sign;
      dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0)
        this.length--;
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0)
        this.sign = false;
      return this;
    };
    BN.prototype.inspect = function inspect() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };
    var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      if (base === 16 || base === 'hex') {
        var out = '';
        var off = 0;
        var padding = padding | 0 || 1;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = (((w << off) | carry) & 0xffffff).toString(16);
          carry = (w >>> (24 - off)) & 0xffffff;
          if (carry !== 0 || i !== this.length - 1)
            out = zeros[6 - word.length] + word + out;
          else
            out = word + out;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0)
          out = carry.toString(16) + out;
        while (out.length % padding !== 0)
          out = '0' + out;
        if (this.sign)
          out = '-' + out;
        return out;
      } else if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        var out = '';
        var c = this.clone();
        c.sign = false;
        while (c.cmpn(0) !== 0) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (c.cmpn(0) !== 0)
            out = zeros[groupSize - r.length] + r + out;
          else
            out = r + out;
        }
        if (this.cmpn(0) === 0)
          out = '0' + out;
        if (this.sign)
          out = '-' + out;
        return out;
      } else {
        assert(false, 'Base should be between 2 and 36');
      }
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };
    BN.prototype.toArray = function toArray() {
      this.strip();
      var res = new Array(this.byteLength());
      res[0] = 0;
      var q = this.clone();
      for (var i = 0; q.cmpn(0) !== 0; i++) {
        var b = q.andln(0xff);
        q.ishrn(8);
        res[res.length - i - 1] = b;
      }
      return res;
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 0x1) === 0)
        r++;
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var hi = 0;
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    BN.prototype.zeroBits = function zeroBits() {
      if (this.cmpn(0) === 0)
        return 0;
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.neg = function neg() {
      if (this.cmpn(0) === 0)
        return this.clone();
      var r = this.clone();
      r.sign = !this.sign;
      return r;
    };
    BN.prototype.ior = function ior(num) {
      this.sign = this.sign || num.sign;
      while (this.length < num.length)
        this.words[this.length++] = 0;
      for (var i = 0; i < num.length; i++)
        this.words[i] = this.words[i] | num.words[i];
      return this.strip();
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      else
        return num.clone().ior(this);
    };
    BN.prototype.iand = function iand(num) {
      this.sign = this.sign && num.sign;
      var b;
      if (this.length > num.length)
        b = num;
      else
        b = this;
      for (var i = 0; i < b.length; i++)
        this.words[i] = this.words[i] & num.words[i];
      this.length = b.length;
      return this.strip();
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      else
        return num.clone().iand(this);
    };
    BN.prototype.ixor = function ixor(num) {
      this.sign = this.sign || num.sign;
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++)
        this.words[i] = a.words[i] ^ b.words[i];
      if (this !== a)
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      this.length = a.length;
      return this.strip();
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      else
        return num.clone().ixor(this);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
      var off = (bit / 26) | 0;
      var wbit = bit % 26;
      while (this.length <= off)
        this.words[this.length++] = 0;
      if (val)
        this.words[off] = this.words[off] | (1 << wbit);
      else
        this.words[off] = this.words[off] & ~(1 << wbit);
      return this.strip();
    };
    BN.prototype.iadd = function iadd(num) {
      if (this.sign && !num.sign) {
        this.sign = false;
        var r = this.isub(num);
        this.sign = !this.sign;
        return this._normSign();
      } else if (!this.sign && num.sign) {
        num.sign = false;
        var r = this.isub(num);
        num.sign = true;
        return r._normSign();
      }
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        var r = a.words[i] + b.words[i] + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        var r = a.words[i] + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      if (num.sign && !this.sign) {
        num.sign = false;
        var res = this.sub(num);
        num.sign = true;
        return res;
      } else if (!num.sign && this.sign) {
        this.sign = false;
        var res = num.sub(this);
        this.sign = true;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      else
        return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.sign) {
        num.sign = false;
        var r = this.iadd(num);
        num.sign = true;
        return r._normSign();
      } else if (this.sign) {
        this.sign = false;
        this.iadd(num);
        this.sign = true;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.sign = false;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a;
      var b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        var r = a.words[i] - b.words[i] + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      for (; carry !== 0 && i < a.length; i++) {
        var r = a.words[i] + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      if (carry === 0 && i < a.length && a !== this)
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      this.length = Math.max(this.length, i);
      if (a !== this)
        this.sign = true;
      return this.strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    BN.prototype._smallMulTo = function _smallMulTo(num, out) {
      out.sign = num.sign !== this.sign;
      out.length = this.length + num.length;
      var carry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
        }
        out.words[k] = rword;
        carry = ncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    };
    BN.prototype._bigMulTo = function _bigMulTo(num, out) {
      out.sign = num.sign !== this.sign;
      out.length = this.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    };
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      if (this.length + num.length < 63)
        res = this._smallMulTo(num, out);
      else
        res = this._bigMulTo(num, out);
      return res;
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.imul = function imul(num) {
      if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
        this.words[0] = 0;
        this.length = 1;
        return this;
      }
      var tlen = this.length;
      var nlen = num.length;
      this.sign = num.sign !== this.sign;
      this.length = this.length + num.length;
      this.words[this.length - 1] = 0;
      for (var k = this.length - 2; k >= 0; k--) {
        var carry = 0;
        var rword = 0;
        var maxJ = Math.min(k, nlen - 1);
        for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i];
          var b = num.words[j];
          var r = a * b;
          var lo = r & 0x3ffffff;
          carry += (r / 0x4000000) | 0;
          lo += rword;
          rword = lo & 0x3ffffff;
          carry += lo >>> 26;
        }
        this.words[k] = rword;
        this.words[k + 1] += carry;
        carry = 0;
      }
      var carry = 0;
      for (var i = 1; i < this.length; i++) {
        var w = this.words[i] + carry;
        this.words[i] = w & 0x3ffffff;
        carry = w >>> 26;
      }
      return this.strip();
    };
    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === 'number');
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i] * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += (w / 0x4000000) | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.mul(this);
    };
    BN.prototype.ishln = function ishln(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
      if (r !== 0) {
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] - newCarry) << r;
          this.words[i] = c | carry;
          carry = newCarry >>> (26 - r);
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (var i = this.length - 1; i >= 0; i--)
          this.words[i + s] = this.words[i];
        for (var i = 0; i < s; i++)
          this.words[i] = 0;
        this.length += s;
      }
      return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;
      if (hint)
        h = (hint - (hint % 26)) / 26;
      else
        h = 0;
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s; i++)
          maskedWords.words[i] = this.words[i];
        maskedWords.length = s;
      }
      if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for (var i = 0; i < this.length; i++)
          this.words[i] = this.words[i + s];
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i];
        this.words[i] = (carry << (26 - r)) | (word >>> r);
        carry = word & mask;
      }
      if (maskedWords && carry !== 0)
        maskedWords.words[maskedWords.length++] = carry;
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      this.strip();
      return this;
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        return false;
      }
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(!this.sign, 'imaskn works only with positive numbers');
      if (r !== 0)
        s++;
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === 'number');
      if (num < 0)
        return this.isubn(-num);
      if (this.sign) {
        if (this.length === 1 && this.words[0] < num) {
          this.words[0] = num - this.words[0];
          this.sign = false;
          return this;
        }
        this.sign = false;
        this.isubn(num);
        this.sign = true;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;
        if (i === this.length - 1)
          this.words[i + 1] = 1;
        else
          this.words[i + 1]++;
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === 'number');
      if (num < 0)
        return this.iaddn(-num);
      if (this.sign) {
        this.sign = false;
        this.iaddn(num);
        this.sign = true;
        return this;
      }
      this.words[0] -= num;
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
      return this.strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.sign = false;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      if (this.words.length < len) {
        var t = new Array(len);
        for (var i = 0; i < this.length; i++)
          t[i] = this.words[i];
        this.words = t;
      } else {
        i = this.length;
      }
      this.length = Math.max(this.length, len);
      for (; i < this.length; i++)
        this.words[i] = 0;
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var w = this.words[i + shift] + carry;
        var right = num.words[i] * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - ((right / 0x4000000) | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }
      for (; i < this.length - shift; i++) {
        var w = this.words[i + shift] + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }
      if (carry === 0)
        return this.strip();
      assert(carry === -1);
      carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = -this.words[i] + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }
      this.sign = true;
      return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1];
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.shln(shift);
        a.ishln(shift);
        bhi = b.words[b.length - 1];
      }
      var m = a.length - b.length;
      var q;
      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++)
          q.words[i] = 0;
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (!diff.sign) {
        a = diff;
        if (q)
          q.words[m] = 1;
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];
        qj = Math.min((qj / bhi) | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while (a.sign) {
          qj--;
          a.sign = false;
          a._ishlnsubmul(b, 1, j);
          if (a.cmpn(0) !== 0)
            a.sign = !a.sign;
        }
        if (q)
          q.words[j] = qj;
      }
      if (q)
        q.strip();
      a.strip();
      if (mode !== 'div' && shift !== 0)
        a.ishrn(shift);
      return {
        div: q ? q : null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode) {
      assert(num.cmpn(0) !== 0);
      if (this.sign && !num.sign) {
        var res = this.neg().divmod(num, mode);
        var div;
        var mod;
        if (mode !== 'mod')
          div = res.div.neg();
        if (mode !== 'div')
          mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
        return {
          div: div,
          mod: mod
        };
      } else if (!this.sign && num.sign) {
        var res = this.divmod(num.neg(), mode);
        var div;
        if (mode !== 'mod')
          div = res.div.neg();
        return {
          div: div,
          mod: res.mod
        };
      } else if (this.sign && num.sign) {
        return this.neg().divmod(num.neg(), mode);
      }
      if (num.length > this.length || this.cmp(num) < 0)
        return {
          div: new BN(0),
          mod: this
        };
      if (num.length === 1) {
        if (mode === 'div')
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        else if (mode === 'mod')
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, 'div').div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, 'mod').mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.cmpn(0) === 0)
        return dm.div;
      var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
      var half = num.shrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--)
        acc = (p * acc + this.words[i]) % num;
      return acc;
    };
    BN.prototype.idivn = function idivn(num) {
      assert(num <= 0x3ffffff);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = this.words[i] + carry * 0x4000000;
        this.words[i] = (w / num) | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(!p.sign);
      assert(p.cmpn(0) !== 0);
      var x = this;
      var y = p.clone();
      if (x.sign)
        x = x.mod(p);
      else
        x = x.clone();
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.ishrn(1);
        y.ishrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (x.cmpn(0) !== 0) {
        while (x.isEven()) {
          x.ishrn(1);
          if (A.isEven() && B.isEven()) {
            A.ishrn(1);
            B.ishrn(1);
          } else {
            A.iadd(yp).ishrn(1);
            B.isub(xp).ishrn(1);
          }
        }
        while (y.isEven()) {
          y.ishrn(1);
          if (C.isEven() && D.isEven()) {
            C.ishrn(1);
            D.ishrn(1);
          } else {
            C.iadd(yp).ishrn(1);
            D.isub(xp).ishrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.ishln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert(!p.sign);
      assert(p.cmpn(0) !== 0);
      var a = this;
      var b = p.clone();
      if (a.sign)
        a = a.mod(p);
      else
        a = a.clone();
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        while (a.isEven()) {
          a.ishrn(1);
          if (x1.isEven())
            x1.ishrn(1);
          else
            x1.iadd(delta).ishrn(1);
        }
        while (b.isEven()) {
          b.ishrn(1);
          if (x2.isEven())
            x2.ishrn(1);
          else
            x2.iadd(delta).ishrn(1);
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      if (a.cmpn(1) === 0)
        return x1;
      else
        return x2;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.cmpn(0) === 0)
        return num.clone();
      if (num.cmpn(0) === 0)
        return this.clone();
      var a = this.clone();
      var b = num.clone();
      a.sign = false;
      b.sign = false;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.ishrn(1);
        b.ishrn(1);
      }
      do {
        while (a.isEven())
          a.ishrn(1);
        while (b.isEven())
          b.ishrn(1);
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.ishln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.mod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        for (var i = this.length; i < s + 1; i++)
          this.words[i] = 0;
        this.words[s] |= q;
        this.length = s + 1;
        return this;
      }
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i];
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var sign = num < 0;
      if (sign)
        num = -num;
      if (this.sign && !sign)
        return -1;
      else if (!this.sign && sign)
        return 1;
      num &= 0x3ffffff;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        var w = this.words[0];
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.sign)
        res = -res;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.sign && !num.sign)
        return -1;
      else if (!this.sign && num.sign)
        return 1;
      var res = this.ucmp(num);
      if (this.sign)
        return -res;
      else
        return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      else if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i];
        var b = num.words[i];
        if (a === b)
          continue;
        if (a < b)
          res = -1;
        else if (a > b)
          res = 1;
        break;
      }
      return res;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(!this.sign, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, 'redSqr works only with red numbers');
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, 'redISqr works only with red numbers');
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, 'redSqrt works only with red numbers');
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, 'redInvm works only with red numbers');
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, 'redNeg works only with red numbers');
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, 'redPow(normalNum)');
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).ishln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        r.strip();
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.ishrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 0x3fffff;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++)
        output.words[i] = input.words[i];
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return ;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (var i = 10; i < input.length; i++) {
        var next = input.words[i];
        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
        prev = next;
      }
      input.words[i - 10] = prev >>> 22;
      input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var hi;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i];
        hi = w * 0x40;
        lo += w * 0x3d1;
        hi += (lo / 0x4000000) | 0;
        lo &= 0x3ffffff;
        num.words[i] = lo;
        lo = hi;
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0)
          num.length--;
      }
      return num;
    };
    function P224() {
      MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = num.words[i] * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0)
        num.words[num.length++] = carry;
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === 'k256')
        prime = new K256();
      else if (name === 'p224')
        prime = new P224();
      else if (name === 'p192')
        prime = new P192();
      else if (name === 'p25519')
        prime = new P25519();
      else
        throw new Error('Unknown prime ' + name);
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(!a.sign, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert(!a.sign && !b.sign, 'red works only with positives');
      assert(a.red && a.red === b.red, 'red works only with red numbers');
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.mod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
      var r = a.clone();
      r.sign = !r.sign;
      return r.iadd(this.m)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0)
        res.isub(this.m);
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0)
        res.isub(this.m);
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0)
        res.iadd(this.m);
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0)
        res.iadd(this.m);
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.shln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a);
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.cmpn(0) === 0)
        return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).ishrn(2);
        var r = this.pow(a, pow);
        return r;
      }
      var q = this.m.subn(1);
      var s = 0;
      while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
        s++;
        q.ishrn(1);
      }
      assert(q.cmpn(0) !== 0);
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).ishrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0)
        z.redIAdd(nOne);
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).ishrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++)
          tmp = tmp.redSqr();
        assert(i < m);
        var b = this.pow(c, new BN(1).ishln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.sign) {
        inv.sign = false;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      var w = [];
      if (num.cmpn(0) === 0)
        return new BN(1);
      var q = num.clone();
      while (q.cmpn(0) !== 0) {
        w.push(q.andln(1));
        q.ishrn(1);
      }
      var res = a;
      for (var i = 0; i < w.length; i++, res = this.sqr(res))
        if (w[i] !== 0)
          break;
      if (++i < w.length) {
        for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
          if (w[i] === 0)
            continue;
          res = this.mul(res, q);
        }
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.mod(this.m);
      if (r === num)
        return r.clone();
      else
        return r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0)
        this.shift += 26 - (this.shift % 26);
      this.r = new BN(1).ishln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv.sign = true;
      this.minv = this.minv.mod(this.r);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.shln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).ishrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0)
        res = u.isub(this.m);
      else if (u.cmpn(0) < 0)
        res = u.iadd(this.m);
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
      if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
        return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).ishrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0)
        res = u.isub(this.m);
      else if (u.cmpn(0) < 0)
        res = u.iadd(this.m);
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === 'undefined' || module, this);
  global.define = __define;
  return module.exports;
});

System.register("npm:brorand@1.0.5/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var r;
  module.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
    return r.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  module.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  if (typeof window === 'object') {
    if (window.crypto && window.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else {
      Rand.prototype._rand = function() {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    try {
      var crypto = require('cry' + 'pto');
      Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
      };
    } catch (e) {
      Rand.prototype._rand = function _rand(n) {
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
    }
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:diffie-hellman@3.0.2/lib/primes.json!github:systemjs/plugin-json@0.1.0", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "modp1": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:diffie-hellman@3.0.2/lib/dh", ["npm:bn.js@2.0.5", "npm:miller-rabin@2.0.1", "npm:diffie-hellman@3.0.2/lib/generatePrime", "npm:randombytes@2.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var BN = require("npm:bn.js@2.0.5");
    var MillerRabin = require("npm:miller-rabin@2.0.1");
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN(24);
    var ELEVEN = new BN(11);
    var TEN = new BN(10);
    var THREE = new BN(3);
    var SEVEN = new BN(7);
    var primes = require("npm:diffie-hellman@3.0.2/lib/generatePrime");
    var randomBytes = require("npm:randombytes@2.0.1");
    module.exports = DH;
    function setPublicKey(pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this._pub = new BN(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      this._priv = new BN(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString('hex');
      var hex = [gen, prime.toString(16)].join('_');
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error += 1;
        if (gen === '02' || gen === '05') {
          error += 8;
        } else {
          error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error += 2;
      }
      var rem;
      switch (gen) {
        case '02':
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error += 8;
          }
          break;
        case '05':
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error += 8;
          }
          break;
        default:
          error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    function defineError(self, error) {
      try {
        Object.defineProperty(self, 'verifyError', {
          enumerable: true,
          value: error,
          writable: false
        });
      } catch (e) {
        self.verifyError = error;
      }
    }
    function DH(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN(prime);
      this._prime = BN.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = void 0;
      this._priv = void 0;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
        defineError(this, checkPrime(this.__prime, generator));
      } else {
        defineError(this, 8);
      }
    }
    DH.prototype.generateKeys = function() {
      if (!this._priv) {
        this._priv = new BN(randomBytes(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH.prototype.computeSecret = function(other) {
      other = new BN(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new Buffer(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new Buffer(prime.length - out.length);
        front.fill(0);
        out = Buffer.concat([front, out]);
      }
      return out;
    };
    DH.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH.prototype.setGenerator = function(gen, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(gen)) {
        gen = new Buffer(gen, enc);
      }
      this._gen = new BN(gen);
      return this;
    };
    function formatReturnValue(bn, enc) {
      var buf = new Buffer(bn.toArray());
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:indexof@0.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var indexOf = [].indexOf;
  module.exports = function(arr, obj) {
    if (indexOf)
      return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj)
        return i;
    }
    return -1;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/base/reporter", ["npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var inherits = require("npm:inherits@2.0.1");
  function Reporter(options) {
    this._reporterState = {
      obj: null,
      path: [],
      options: options || {},
      errors: []
    };
  }
  exports.Reporter = Reporter;
  Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
  };
  Reporter.prototype.save = function save() {
    var state = this._reporterState;
    return {
      obj: state.obj,
      pathLen: state.path.length
    };
  };
  Reporter.prototype.restore = function restore(data) {
    var state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
  };
  Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
  };
  Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    var state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
    if (state.obj !== null)
      state.obj[key] = value;
  };
  Reporter.prototype.enterObject = function enterObject() {
    var state = this._reporterState;
    var prev = state.obj;
    state.obj = {};
    return prev;
  };
  Reporter.prototype.leaveObject = function leaveObject(prev) {
    var state = this._reporterState;
    var now = state.obj;
    state.obj = prev;
    return now;
  };
  Reporter.prototype.error = function error(msg) {
    var err;
    var state = this._reporterState;
    var inherited = msg instanceof ReporterError;
    if (inherited) {
      err = msg;
    } else {
      err = new ReporterError(state.path.map(function(elem) {
        return '[' + JSON.stringify(elem) + ']';
      }).join(''), msg.message || msg, msg.stack);
    }
    if (!state.options.partial)
      throw err;
    if (!inherited)
      state.errors.push(err);
    return err;
  };
  Reporter.prototype.wrapResult = function wrapResult(result) {
    var state = this._reporterState;
    if (!state.options.partial)
      return result;
    return {
      result: this.isError(result) ? null : result,
      errors: state.errors
    };
  };
  function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
  }
  ;
  inherits(ReporterError, Error);
  ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + ' at: ' + (this.path || '(shallow)');
    Error.captureStackTrace(this, ReporterError);
    return this;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/base/buffer", ["npm:inherits@2.0.1", "npm:asn1.js@2.0.3/lib/asn1/base/index", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Reporter = require("npm:asn1.js@2.0.3/lib/asn1/base/index").Reporter;
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0").Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer.isBuffer(base)) {
        this.error('Input not Buffer');
        return ;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
      };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || 'DecoderBuffer overrun');
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || 'DecoderBuffer overrun');
      var res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!item || item.constructor.name !== 'EncoderBuffer')
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff))
          return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
      } else if (typeof value === 'string') {
        this.value = value;
        this.length = Buffer.byteLength(value);
      } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error('Unsupported type: ' + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === 'number')
          out[offset] = this.value;
        else if (typeof this.value === 'string')
          out.write(this.value, offset);
        else if (Buffer.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:minimalistic-assert@1.0.0/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  }
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/constants/der", ["npm:asn1.js@2.0.3/lib/asn1/constants/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var constants = require("npm:asn1.js@2.0.3/lib/asn1/constants/index");
  exports.tagClass = {
    0: 'universal',
    1: 'application',
    2: 'context',
    3: 'private'
  };
  exports.tagClassByName = constants._reverse(exports.tagClass);
  exports.tag = {
    0x00: 'end',
    0x01: 'bool',
    0x02: 'int',
    0x03: 'bitstr',
    0x04: 'octstr',
    0x05: 'null_',
    0x06: 'objid',
    0x07: 'objDesc',
    0x08: 'external',
    0x09: 'real',
    0x0a: 'enum',
    0x0b: 'embed',
    0x0c: 'utf8str',
    0x0d: 'relativeOid',
    0x10: 'seq',
    0x11: 'set',
    0x12: 'numstr',
    0x13: 'printstr',
    0x14: 't61str',
    0x15: 'videostr',
    0x16: 'ia5str',
    0x17: 'utctime',
    0x18: 'gentime',
    0x19: 'graphstr',
    0x1a: 'iso646str',
    0x1b: 'genstr',
    0x1c: 'unistr',
    0x1d: 'charstr',
    0x1e: 'bmpstr'
  };
  exports.tagByName = constants._reverse(exports.tag);
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/decoders/der", ["npm:inherits@2.0.1", "npm:asn1.js@2.0.3/lib/asn1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var inherits = require("npm:inherits@2.0.1");
  var asn1 = require("npm:asn1.js@2.0.3/lib/asn1");
  var base = asn1.base;
  var bignum = asn1.bignum;
  var der = asn1.constants.der;
  function DERDecoder(entity) {
    this.enc = 'der';
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  ;
  module.exports = DERDecoder;
  DERDecoder.prototype.decode = function decode(data, options) {
    if (!(data instanceof base.DecoderBuffer))
      data = new base.DecoderBuffer(data, options);
    return this.tree._decode(data, options);
  };
  function DERNode(parent) {
    base.Node.call(this, 'der', parent);
  }
  inherits(DERNode, base.Node);
  DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty())
      return false;
    var state = buffer.save();
    var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag))
      return decodedTag;
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
  };
  DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag))
      return decodedTag;
    var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len))
      return len;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
      return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null)
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    var state = buffer.start();
    var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res))
      return res;
    return buffer.cut(state);
  };
  DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    while (true) {
      var tag = derDecodeTag(buffer, fail);
      if (buffer.isError(tag))
        return tag;
      var len = derDecodeLen(buffer, tag.primitive, fail);
      if (buffer.isError(len))
        return len;
      var res;
      if (tag.primitive || len !== null)
        res = buffer.skip(len);
      else
        res = this._skipUntilEnd(buffer, fail);
      if (buffer.isError(res))
        return res;
      if (tag.tagStr === 'end')
        break;
    }
  };
  DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
    var result = [];
    while (!buffer.isEmpty()) {
      var possibleEnd = this._peekTag(buffer, 'end');
      if (buffer.isError(possibleEnd))
        return possibleEnd;
      var res = decoder.decode(buffer, 'der');
      if (buffer.isError(res) && possibleEnd)
        break;
      result.push(res);
    }
    return result;
  };
  DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === 'octstr') {
      return buffer.raw();
    } else if (tag === 'bitstr') {
      var unused = buffer.readUInt8();
      if (buffer.isError(unused))
        return unused;
      return {
        unused: unused,
        data: buffer.raw()
      };
    } else if (tag === 'ia5str') {
      return buffer.raw().toString();
    } else {
      return this.error('Decoding of string type: ' + tag + ' unsupported');
    }
  };
  DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    var identifiers = [];
    var ident = 0;
    while (!buffer.isEmpty()) {
      var subident = buffer.readUInt8();
      ident <<= 7;
      ident |= subident & 0x7f;
      if ((subident & 0x80) === 0) {
        identifiers.push(ident);
        ident = 0;
      }
    }
    if (subident & 0x80)
      identifiers.push(ident);
    var first = (identifiers[0] / 40) | 0;
    var second = identifiers[0] % 40;
    if (relative)
      result = identifiers;
    else
      result = [first, second].concat(identifiers.slice(1));
    if (values)
      result = values[result.join(' ')];
    return result;
  };
  DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
    var str = buffer.raw().toString();
    if (tag === 'gentime') {
      var year = str.slice(0, 4) | 0;
      var mon = str.slice(4, 6) | 0;
      var day = str.slice(6, 8) | 0;
      var hour = str.slice(8, 10) | 0;
      var min = str.slice(10, 12) | 0;
      var sec = str.slice(12, 14) | 0;
    } else if (tag === 'utctime') {
      var year = str.slice(0, 2) | 0;
      var mon = str.slice(2, 4) | 0;
      var day = str.slice(4, 6) | 0;
      var hour = str.slice(6, 8) | 0;
      var min = str.slice(8, 10) | 0;
      var sec = str.slice(10, 12) | 0;
      if (year < 70)
        year = 2000 + year;
      else
        year = 1900 + year;
    } else {
      return this.error('Decoding ' + tag + ' time is not supported yet');
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
  };
  DERNode.prototype._decodeNull = function decodeNull(buffer) {
    return null;
  };
  DERNode.prototype._decodeBool = function decodeBool(buffer) {
    var res = buffer.readUInt8();
    if (buffer.isError(res))
      return res;
    else
      return res !== 0;
  };
  DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
    var raw = buffer.raw();
    var res = new bignum(raw);
    if (values)
      res = values[res.toString(10)] || res;
    return res;
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === 'function')
      entity = entity(obj);
    return entity._getDecoder('der').tree;
  };
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag))
      return tag;
    var cls = der.tagClass[tag >> 6];
    var primitive = (tag & 0x20) === 0;
    if ((tag & 0x1f) === 0x1f) {
      var oct = tag;
      tag = 0;
      while ((oct & 0x80) === 0x80) {
        oct = buf.readUInt8(fail);
        if (buf.isError(oct))
          return oct;
        tag <<= 7;
        tag |= oct & 0x7f;
      }
    } else {
      tag &= 0x1f;
    }
    var tagStr = der.tag[tag];
    return {
      cls: cls,
      primitive: primitive,
      tag: tag,
      tagStr: tagStr
    };
  }
  function derDecodeLen(buf, primitive, fail) {
    var len = buf.readUInt8(fail);
    if (buf.isError(len))
      return len;
    if (!primitive && len === 0x80)
      return null;
    if ((len & 0x80) === 0) {
      return len;
    }
    var num = len & 0x7f;
    if (num >= 4)
      return buf.error('length octect is too long');
    len = 0;
    for (var i = 0; i < num; i++) {
      len <<= 8;
      var j = buf.readUInt8(fail);
      if (buf.isError(j))
        return j;
      len |= j;
    }
    return len;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/encoders/der", ["npm:inherits@2.0.1", "github:jspm/nodelibs-buffer@0.1.0", "npm:asn1.js@2.0.3/lib/asn1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0").Buffer;
    var asn1 = require("npm:asn1.js@2.0.3/lib/asn1");
    var base = asn1.base;
    var bignum = asn1.bignum;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = 'der';
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    ;
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, 'der', parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 0x80) {
        var header = new Buffer(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i = content.length; i >= 0x100; i >>= 8)
        lenOctets++;
      var header = new Buffer(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 0x80 | lenOctets;
      for (var i = 1 + lenOctets,
          j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 0xff;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === 'octstr')
        return this._createEncoderBuffer(str);
      else if (tag === 'bitstr')
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      else if (tag === 'ia5str')
        return this._createEncoderBuffer(str);
      return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === 'string') {
        if (!values)
          return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id))
          return this.reporter.error('objid not found in values map');
        id = values[id].split(/\s+/g);
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
      }
      if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7)
          size++;
      }
      var objid = new Buffer(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0)
          objid[offset--] = 0x80 | (ident & 0x7f);
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return '0' + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
      if (tag === 'gentime') {
        str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else if (tag === 'utctime') {
        str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
      }
      return this._encodeStr(str, 'octstr');
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer('');
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === 'string') {
        if (!values)
          return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
        var numArray = num.toArray();
        if (num.sign === false && numArray[0] & 0x80) {
          numArray.unshift(0);
        }
        num = new Buffer(numArray);
      }
      if (Buffer.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
        var out = new Buffer(size);
        num.copy(out);
        if (num.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 0x80)
        return this._createEncoderBuffer(num);
      if (num < 0x100)
        return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i = num; i >= 0x100; i >>= 8)
        size++;
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
      }
      if (out[0] & 0x80) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 0xff : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === 'function')
        entity = entity(obj);
      return entity._getEncoder('der').tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state['default'] === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === 'seqof')
        tag = 'seq';
      else if (tag === 'setof')
        tag = 'set';
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === 'number' && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error('Unknown tag: ' + tag);
      if (res >= 0x1f)
        return reporter.error('Multi-octet tag encoding unsupported');
      if (!primitive)
        res |= 0x20;
      res |= (der.tagClassByName[cls || 'universal'] << 6);
      return res;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1/aesid.json!github:systemjs/plugin-json@0.1.0", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1/EVP_BytesToKey", ["npm:create-hash@1.1.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var createHash = require("npm:create-hash@1.1.1");
    module.exports = function evp(password, salt, keyLen) {
      keyLen = keyLen / 8;
      var ki = 0;
      var ii = 0;
      var key = new Buffer(keyLen);
      var addmd = 0;
      var md,
          md_buf;
      var i;
      while (true) {
        md = createHash('md5');
        if (addmd++ > 0) {
          md.update(md_buf);
        }
        md.update(password);
        md.update(salt);
        md_buf = md.digest();
        i = 0;
        if (keyLen > 0) {
          while (true) {
            if (keyLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            key[ki++] = md_buf[i++];
            keyLen--;
          }
        }
        if (keyLen === 0) {
          break;
        }
      }
      for (i = 0; i < md_buf.length; i++) {
        md_buf[i] = 0;
      }
      return key;
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/package.json!github:systemjs/plugin-json@0.1.0", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "name": "elliptic",
    "version": "3.0.4",
    "description": "EC cryptography",
    "main": "lib/elliptic.js",
    "scripts": {"test": "make lint && mocha --reporter=spec test/*-test.js"},
    "repository": {
      "type": "git",
      "url": "git@github.com:indutny/elliptic"
    },
    "keywords": ["EC", "Elliptic", "curve", "Cryptography"],
    "author": "Fedor Indutny <fedor@indutny.com>",
    "license": "MIT",
    "bugs": {"url": "https://github.com/indutny/elliptic/issues"},
    "homepage": "https://github.com/indutny/elliptic",
    "devDependencies": {
      "browserify": "^3.44.2",
      "jscs": "^1.11.3",
      "jshint": "^2.6.0",
      "mocha": "^2.1.0",
      "uglify-js": "^2.4.13"
    },
    "dependencies": {
      "bn.js": "^2.0.0",
      "brorand": "^1.0.1",
      "hash.js": "^1.0.0",
      "inherits": "^2.0.1"
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/utils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  'use strict';
  var utils = exports;
  utils.assert = function assert(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  };
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === 'hex')
      return toHex(arr);
    else
      return arr;
  };
  function getNAF(num, w) {
    var naf = [];
    var ws = 1 << (w + 1);
    var k = num.clone();
    while (k.cmpn(1) >= 0) {
      var z;
      if (k.isOdd()) {
        var mod = k.andln(ws - 1);
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf.push(z);
      var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
      for (var i = 1; i < shift; i++)
        naf.push(0);
      k.ishrn(shift);
    }
    return naf;
  }
  utils.getNAF = getNAF;
  function getJSF(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = (k1.andln(3) + d1) & 3;
      var m24 = (k2.andln(3) + d2) & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        var m8 = (k1.andln(7) + d1) & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        var m8 = (k2.andln(7) + d2) & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.ishrn(1);
      k2.ishrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF;
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash/utils", ["npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var utils = exports;
  var inherits = require("npm:inherits@2.0.1");
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 0xff;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0)
          msg = '0' + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  utils.toArray = toArray;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  function htonl(w) {
    var res = (w >>> 24) | ((w >>> 8) & 0xff00) | ((w << 8) & 0xff0000) | ((w & 0xff) << 24);
    return res >>> 0;
  }
  utils.htonl = htonl;
  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little')
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return '0' + word;
    else if (word.length === 6)
      return '00' + word;
    else if (word.length === 5)
      return '000' + word;
    else if (word.length === 4)
      return '0000' + word;
    else if (word.length === 3)
      return '00000' + word;
    else if (word.length === 2)
      return '000000' + word;
    else if (word.length === 1)
      return '0000000' + word;
    else
      return word;
  }
  utils.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0,
        k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big')
        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
      else
        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0,
        k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = (m >>> 16) & 0xff;
        res[k + 2] = (m >>> 8) & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = (m >>> 16) & 0xff;
        res[k + 1] = (m >>> 8) & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  utils.split32 = split32;
  function rotr32(w, b) {
    return (w >>> b) | (w << (32 - b));
  }
  utils.rotr32 = rotr32;
  function rotl32(w, b) {
    return (w << b) | (w >>> (32 - b));
  }
  utils.rotl32 = rotl32;
  function sum32(a, b) {
    return (a + b) >>> 0;
  }
  utils.sum32 = sum32;
  function sum32_3(a, b, c) {
    return (a + b + c) >>> 0;
  }
  utils.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return (a + b + c + d) >>> 0;
  }
  utils.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
  }
  utils.sum32_5 = sum32_5;
  function assert(cond, msg) {
    if (!cond)
      throw new Error(msg || 'Assertion failed');
  }
  utils.assert = assert;
  utils.inherits = inherits;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  exports.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  ;
  exports.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  ;
  exports.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  ;
  exports.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  ;
  exports.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  ;
  exports.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  ;
  exports.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
  }
  ;
  exports.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  ;
  exports.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  ;
  exports.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  ;
  exports.shr64_lo = shr64_lo;
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash/common", ["npm:hash.js@1.0.3/lib/hash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var hash = require("npm:hash.js@1.0.3/lib/hash");
  var utils = hash.utils;
  var assert = utils.assert;
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  exports.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash/sha", ["npm:hash.js@1.0.3/lib/hash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var hash = require("npm:hash.js@1.0.3/lib/hash");
  var utils = hash.utils;
  var assert = utils.assert;
  var rotr32 = utils.rotr32;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  var BlockHash = hash.common.BlockHash;
  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils.inherits(SHA256, BlockHash);
  exports.sha256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
  }
  utils.inherits(SHA224, SHA256);
  exports.sha224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 7), 'big');
    else
      return utils.split32(this.h.slice(0, 7), 'big');
  };
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils.inherits(SHA512, BlockHash);
  exports.sha512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var c0_hi = s0_512_hi(ah, al);
      var c0_lo = s0_512_lo(ah, al);
      var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
  }
  utils.inherits(SHA384, SHA512);
  exports.sha384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 12), 'big');
    else
      return utils.split32(this.h.slice(0, 12), 'big');
  };
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.W = new Array(80);
  }
  utils.inherits(SHA1, BlockHash);
  exports.sha1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (var i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function ch32(x, y, z) {
    return (x & y) ^ ((~x) & z);
  }
  function maj32(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
  }
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
  }
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
  }
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  function ch64_hi(xh, xl, yh, yl, zh, zl) {
    var r = (xh & yh) ^ ((~xh) & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ ((~xl) & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh, zl) {
    var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash/ripemd", ["npm:hash.js@1.0.3/lib/hash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var hash = require("npm:hash.js@1.0.3/lib/hash");
  var utils = hash.utils;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = hash.common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.endian = 'little';
  }
  utils.inherits(RIPEMD160, BlockHash);
  exports.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'little');
    else
      return utils.split32(this.h, 'little');
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return (x & y) | ((~x) & z);
    else if (j <= 47)
      return (x | (~y)) ^ z;
    else if (j <= 63)
      return (x & z) | (y & (~z));
    else
      return x ^ (y | (~z));
  }
  function K(j) {
    if (j <= 15)
      return 0x00000000;
    else if (j <= 31)
      return 0x5a827999;
    else if (j <= 47)
      return 0x6ed9eba1;
    else if (j <= 63)
      return 0x8f1bbcdc;
    else
      return 0xa953fd4e;
  }
  function Kh(j) {
    if (j <= 15)
      return 0x50a28be6;
    else if (j <= 31)
      return 0x5c4dd124;
    else if (j <= 47)
      return 0x6d703ef3;
    else if (j <= 63)
      return 0x7a6d76e9;
    else
      return 0x00000000;
  }
  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash/hmac", ["npm:hash.js@1.0.3/lib/hash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var hmac = exports;
  var hash = require("npm:hash.js@1.0.3/lib/hash");
  var utils = hash.utils;
  var assert = utils.assert;
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  module.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
    for (var i = 0; i < key.length; i++)
      key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    for (var i = 0; i < key.length; i++)
      key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curve/base", ["npm:bn.js@2.0.5", "npm:elliptic@3.0.4/lib/elliptic"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var bn = require("npm:bn.js@2.0.5");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var getNAF = elliptic.utils.getNAF;
  var getJSF = elliptic.utils.getJSF;
  var assert = elliptic.utils.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new bn(conf.p, 16);
    this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);
    this.zero = new bn(0).toRed(this.red);
    this.one = new bn(1).toRed(this.red);
    this.two = new bn(2).toRed(this.red);
    this.n = conf.n && new bn(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
  }
  module.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1);
    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    for (var j = 0; j < naf.length; j += doubles.step) {
      var nafW = 0;
      for (var k = j + doubles.step - 1; k >= j; k--)
        nafW = (nafW << 1) + naf[k];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (var j = 0; j < repr.length; j++) {
        var nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      for (var k = 0; i >= 0 && naf[i] === 0; i--)
        k++;
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      var z = naf[i];
      assert(z !== 0);
      if (p.type === 'affine') {
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    for (var i = 0; i < len; i++) {
      var p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (var i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a]);
        naf[b] = getNAF(coeffs[b], wndWidth[b]);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      var comb = [points[a], null, null, points[b]];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (var j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (var i = max; i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (var j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      for (var j = 0; j < len; j++) {
        var z = tmp[j];
        var p;
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();
        if (p.type === 'affine')
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (var i = 0; i < len; i++)
      wnd[i] = null;
    return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curve/short", ["npm:elliptic@3.0.4/lib/elliptic/curve/index", "npm:elliptic@3.0.4/lib/elliptic", "npm:bn.js@2.0.5", "npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var curve = require("npm:elliptic@3.0.4/lib/elliptic/curve/index");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var bn = require("npm:bn.js@2.0.5");
  var inherits = require("npm:inherits@2.0.1");
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function ShortCurve(conf) {
    Base.call(this, 'short', conf);
    this.a = new bn(conf.a, 16).toRed(this.red);
    this.b = new bn(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return ;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new bn(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new bn(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new bn(vec.a, 16),
          b: new bn(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta: beta,
      lambda: lambda,
      basis: basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : bn.mont(num);
    var tinv = new bn(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new bn(1);
    var y1 = new bn(0);
    var x2 = new bn(0);
    var y2 = new bn(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.sign) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.sign) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [{
      a: a1,
      b: b1
    }, {
      a: a2,
      b: b2
    }];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
      k1: k1,
      k2: k2
    };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
    x = new bn(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split.k1.sign) {
        split.k1.sign = !split.k1.sign;
        p = p.neg(true);
      }
      if (split.k2.sign) {
        split.k2.sign = !split.k2.sign;
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);
    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new bn(x, 16);
      this.y = new bn(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return ;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string')
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new bn(k, 16);
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new bn(0);
    } else {
      this.x = new bn(x, 16);
      this.y = new bn(y, 16);
      this.z = new bn(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (var i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (var i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new bn(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine')
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curve/mont", ["npm:elliptic@3.0.4/lib/elliptic/curve/index", "npm:bn.js@2.0.5", "npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var curve = require("npm:elliptic@3.0.4/lib/elliptic/curve/index");
  var bn = require("npm:bn.js@2.0.5");
  var inherits = require("npm:inherits@2.0.1");
  var Base = curve.base;
  function MontCurve(conf) {
    Base.call(this, 'mont', conf);
    this.a = new bn(conf.a, 16).toRed(this.red);
    this.b = new bn(conf.b, 16).toRed(this.red);
    this.i4 = new bn(4).toRed(this.red).redInvm();
    this.two = new bn(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new bn(x, 16);
      this.z = new bn(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {};
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curve/edwards", ["npm:elliptic@3.0.4/lib/elliptic/curve/index", "npm:elliptic@3.0.4/lib/elliptic", "npm:bn.js@2.0.5", "npm:inherits@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var curve = require("npm:elliptic@3.0.4/lib/elliptic/curve/index");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var bn = require("npm:bn.js@2.0.5");
  var inherits = require("npm:inherits@2.0.1");
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, 'edwards', conf);
    this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
    this.c = new bn(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new bn(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
    x = new bn(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y = rhs.redMul(lhs.redInvm()).redSqrt();
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y, curve.one);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new bn(x, 16);
      this.y = new bn(y, 16);
      this.z = z ? new bn(z, 16) : this.curve.one;
      this.t = t && new bn(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    if (this.curve.twisted) {
      var e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        var h = this.z.redSqr();
        var j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      var e = c.redAdd(d);
      var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
      var j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/precomputed/secp256k1", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    doubles: {
      step: 4,
      points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
    },
    naf: {
      wnd: 7,
      points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/ec/key", ["npm:bn.js@2.0.5", "npm:elliptic@3.0.4/lib/elliptic"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var bn = require("npm:bn.js@2.0.5");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var utils = elliptic.utils;
  function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  module.exports = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec, {
      pub: pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec, {
      priv: priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return {
        result: false,
        reason: 'Invalid public key'
      };
    if (!pub.validate())
      return {
        result: false,
        reason: 'Public key is not a point'
      };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return {
        result: false,
        reason: 'Public key * N != O'
      };
    return {
      result: true,
      reason: null
    };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }
    if (!enc)
      return this.pub;
    var len = this.ec.curve.p.byteLength();
    var x = this.pub.getX().toArray();
    for (var i = x.length; i < len; i++)
      x.unshift(0);
    var res;
    if (this.ec.curve.type !== 'mont') {
      if (compact) {
        res = [this.pub.getY().isEven() ? 0x02 : 0x03].concat(x);
      } else {
        var y = this.pub.getY().toArray();
        for (var i = y.length; i < len; i++)
          y.unshift(0);
        var res = [0x04].concat(x, y);
      }
    } else {
      res = x;
    }
    return utils.encode(res, enc);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex')
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new bn(key, enc || 16);
    this.priv = this.priv.mod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      this.pub = this.ec.curve.point(key.x, key.y);
      return ;
    }
    key = utils.toArray(key, enc);
    if (this.ec.curve.type !== 'mont')
      return this._importPublicShort(key);
    else
      return this._importPublicMont(key);
  };
  KeyPair.prototype._importPublicShort = function _importPublicShort(key) {
    var len = this.ec.curve.p.byteLength();
    if (key[0] === 0x04 && key.length - 1 === 2 * len) {
      this.pub = this.ec.curve.point(key.slice(1, 1 + len), key.slice(1 + len, 1 + 2 * len));
    } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
      this.pub = this.ec.curve.pointFromX(key[0] === 0x03, key.slice(1, 1 + len));
    }
  };
  KeyPair.prototype._importPublicMont = function _importPublicMont(key) {
    this.pub = this.ec.curve.point(key, 1);
  };
  KeyPair.prototype.derive = function derive(pub) {
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg) {
    return this.ec.sign(msg, this);
  };
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/ec/signature", ["npm:bn.js@2.0.5", "npm:elliptic@3.0.4/lib/elliptic"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var bn = require("npm:bn.js@2.0.5");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var utils = elliptic.utils;
  var assert = utils.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return ;
    assert(options.r && options.s, 'Signature without r or s');
    this.r = new bn(options.r, 16);
    this.s = new bn(options.s, 16);
  }
  module.exports = Signature;
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
      return false;
    var total = data[1];
    if (1 + total > data.length)
      return false;
    var rlen = data[3];
    if (rlen >= 0x80)
      return false;
    if (4 + rlen + 2 >= data.length)
      return false;
    if (data[4 + rlen] !== 0x02)
      return false;
    var slen = data[5 + rlen];
    if (slen >= 0x80)
      return false;
    if (4 + rlen + 2 + slen > data.length)
      return false;
    this.r = new bn(data.slice(4, 4 + rlen));
    this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));
    return true;
  };
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 0x80)
      r = [0].concat(r);
    if (s[0] & 0x80)
      s = [0].concat(s);
    var total = r.length + s.length + 4;
    var res = [0x30, total, 0x02, r.length];
    res = res.concat(r, [0x02, s.length], s);
    return utils.encode(res, enc);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-rsa@2.0.1/index", ["npm:bn.js@2.0.5", "npm:randombytes@2.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var bn = require("npm:bn.js@2.0.5");
    var randomBytes = require("npm:randombytes@2.0.1");
    module.exports = crt;
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
      return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
      };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var mod = bn.mont(priv.modulus);
      var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
      var c1 = blinded.toRed(bn.mont(priv.prime1));
      var c2 = blinded.toRed(bn.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1);
      var m2 = c2.redPow(priv.exponent2);
      m1 = m1.fromRed();
      m2 = m2.fromRed();
      var h = m1.isub(m2).imul(qinv).mod(p);
      h.imul(q);
      m2.iadd(h);
      var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
      if (out.length < len) {
        var prefix = new Buffer(len - out.length);
        prefix.fill(0);
        out = Buffer.concat([prefix, out], len);
      }
      return out;
    }
    crt.getr = getr;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r = new bn(randomBytes(len));
      while (r.cmp(priv.modulus) >= 0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
        r = new bn(randomBytes(len));
      }
      return r;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2/curves", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  exports['1.3.132.0.10'] = 'secp256k1';
  exports['1.3.132.0.33'] = 'p224';
  exports['1.2.840.10045.3.1.1'] = 'p192';
  exports['1.2.840.10045.3.1.7'] = 'p256';
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2/verify", ["npm:parse-asn1@3.0.1", "npm:elliptic@3.0.4", "npm:browserify-sign@3.0.2/curves", "npm:bn.js@2.0.5", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var parseKeys = require("npm:parse-asn1@3.0.1");
    var elliptic = require("npm:elliptic@3.0.4");
    var curves = require("npm:browserify-sign@3.0.2/curves");
    var BN = require("npm:bn.js@2.0.5");
    module.exports = verify;
    function verify(sig, hash, key, signType) {
      var pub = parseKeys(key);
      if (pub.type === 'ec') {
        if (signType !== 'ecdsa') {
          throw new Error('wrong public key type');
        }
        return ecVerify(sig, hash, pub);
      } else if (pub.type === 'dsa') {
        if (signType !== 'dsa') {
          throw new Error('wrong public key type');
        }
        return dsaVerify(sig, hash, pub);
      } else {
        if (signType !== 'rsa') {
          throw new Error('wrong public key type');
        }
      }
      var len = pub.modulus.byteLength();
      var pad = [1];
      var padNum = 0;
      while (hash.length + pad.length + 2 < len) {
        pad.push(0xff);
        padNum++;
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      pad = new Buffer(pad);
      var red = BN.mont(pub.modulus);
      sig = new BN(sig).toRed(red);
      sig = sig.redPow(new BN(pub.publicExponent));
      sig = new Buffer(sig.fromRed().toArray());
      var out = 0;
      if (padNum < 8) {
        out = 1;
      }
      len = Math.min(sig.length, pad.length);
      if (sig.length !== pad.length) {
        out = 1;
      }
      i = -1;
      while (++i < len) {
        out |= (sig[i] ^ pad[i]);
      }
      return out === 0;
    }
    function ecVerify(sig, hash, pub) {
      var curveId = curves[pub.data.algorithm.curve.join('.')];
      if (!curveId)
        throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
      var curve = new elliptic.ec(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve.verify(hash, sig, pubkey);
    }
    function dsaVerify(sig, hash, pub) {
      var p = pub.data.p;
      var q = pub.data.q;
      var g = pub.data.g;
      var y = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, 'der');
      var s = unpacked.s;
      var r = unpacked.r;
      checkValue(s, q);
      checkValue(r, q);
      var montq = BN.mont(q);
      var montp = BN.mont(p);
      var w = s.invm(q);
      var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
      return !v.cmp(r);
    }
    function checkValue(b, q) {
      if (b.cmpn(0) <= 0) {
        throw new Error('invalid sig');
      }
      if (b.cmp(q) >= q) {
        throw new Error('invalid sig');
      }
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:create-ecdh@2.0.1/browser", ["npm:elliptic@3.0.4", "npm:bn.js@2.0.5", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var elliptic = require("npm:elliptic@3.0.4");
    var BN = require("npm:bn.js@2.0.5");
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: 'secp256k1',
        byteLength: 32
      },
      secp224r1: {
        name: 'p224',
        byteLength: 28
      },
      prime256v1: {
        name: 'p256',
        byteLength: 32
      },
      prime192v1: {
        name: 'p192',
        byteLength: 24
      },
      ed25519: {
        name: 'ed25519',
        byteLength: 32
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {name: curve};
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || 'utf8';
      if (!Buffer.isBuffer(other)) {
        other = new Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format) {
      var key = this.keys.getPublic(format === 'compressed', true);
      if (format === 'hybrid') {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      var _priv = new BN(priv);
      _priv = _priv.toString(16);
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf = new Buffer(bn);
      if (len && buf.length < len) {
        var zeros = new Buffer(len - buf.length);
        zeros.fill(0);
        buf = Buffer.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/mgf", ["npm:create-hash@1.1.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var createHash = require("npm:create-hash@1.1.1");
    module.exports = function(seed, len) {
      var t = new Buffer('');
      var i = 0,
          c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    function i2ops(c) {
      var out = new Buffer(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/xor", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function xor(a, b) {
    var len = a.length;
    var i = -1;
    while (++i < len) {
      a[i] ^= b[i];
    }
    return a;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/withPublic", ["npm:bn.js@2.0.5", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var bn = require("npm:bn.js@2.0.5");
    function withPublic(paddedMsg, key) {
      return new Buffer(paddedMsg.toRed(bn.mont(key.modulus)).redPow(new bn(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/privateDecrypt", ["npm:parse-asn1@3.0.1", "npm:public-encrypt@2.0.1/mgf", "npm:public-encrypt@2.0.1/xor", "npm:bn.js@2.0.5", "npm:browserify-rsa@2.0.1", "npm:create-hash@1.1.1", "npm:public-encrypt@2.0.1/withPublic", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var parseKeys = require("npm:parse-asn1@3.0.1");
    var mgf = require("npm:public-encrypt@2.0.1/mgf");
    var xor = require("npm:public-encrypt@2.0.1/xor");
    var bn = require("npm:bn.js@2.0.5");
    var crt = require("npm:browserify-rsa@2.0.1");
    var createHash = require("npm:create-hash@1.1.1");
    var withPublic = require("npm:public-encrypt@2.0.1/withPublic");
    module.exports = function privateDecrypt(private_key, enc, reverse) {
      var padding;
      if (private_key.padding) {
        padding = private_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(private_key);
      var k = key.modulus.byteLength();
      if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
        throw new Error('decryption error');
      }
      var msg;
      if (reverse) {
        msg = withPublic(new bn(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = new Buffer(k - msg.length);
      zBuffer.fill(0);
      msg = Buffer.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error('unknown padding');
      }
    };
    function oaep(key, msg) {
      var n = key.modulus;
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (msg[0] !== 0) {
        throw new Error('decryption error');
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare(iHash, db.slice(0, hLen))) {
        throw new Error('decryption error');
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error('decryption error');
      }
      return db.slice(i);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      var p2 = msg.slice(i - 1, i);
      if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error('decryption error');
      }
      return msg.slice(i);
    }
    function compare(a, b) {
      a = new Buffer(a);
      b = new Buffer(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += (a[i] ^ b[i]);
      }
      return dif;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(undefined) {
      var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
      };
      var root = (objectTypes[typeof window] && window) || this,
          freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      var Rx = {
        internals: {},
        config: {Promise: root.Promise},
        helpers: {}
      };
      var noop = Rx.helpers.noop = function() {},
          notDefined = Rx.helpers.notDefined = function(x) {
            return typeof x === 'undefined';
          },
          identity = Rx.helpers.identity = function(x) {
            return x;
          },
          pluck = Rx.helpers.pluck = function(property) {
            return function(x) {
              return x[property];
            };
          },
          just = Rx.helpers.just = function(value) {
            return function() {
              return value;
            };
          },
          defaultNow = Rx.helpers.defaultNow = Date.now,
          defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y);
          },
          defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : (x < y ? -1 : 0);
          },
          defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString();
          },
          defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
          },
          isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
          },
          asArray = Rx.helpers.asArray = function() {
            return Array.prototype.slice.call(arguments);
          },
          not = Rx.helpers.not = function(a) {
            return !a;
          },
          isFunction = Rx.helpers.isFunction = (function() {
            var isFn = function(value) {
              return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
              isFn = function(value) {
                return typeof value == 'function' && toString.call(value) == '[object Function]';
              };
            }
            return isFn;
          }());
      function cloneArray(arr) {
        for (var a = [],
            i = 0,
            len = arr.length; i < len; i++) {
          a.push(arr[i]);
        }
        return a;
      }
      Rx.config.longStackSupport = false;
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var rStartingLine = captureLine(),
          rFileName;
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var o = observable; !!o; o = o.source) {
            if (o.stack) {
              stacks.unshift(o.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n"),
            desiredLines = [];
        for (var i = 0,
            len = lines.length; i < len; i++) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function captureLine() {
        if (!hasStacks) {
          return ;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return ;
          }
          rFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      var EmptyError = Rx.EmptyError = function() {
        this.message = 'Sequence contains no elements.';
        Error.call(this);
      };
      EmptyError.prototype = Error.prototype;
      var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = 'Object has been disposed';
        Error.call(this);
      };
      ObjectDisposedError.prototype = Error.prototype;
      var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = 'Argument out of range';
        Error.call(this);
      };
      ArgumentOutOfRangeError.prototype = Error.prototype;
      var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || 'This operation is not supported';
        Error.call(this);
      };
      NotSupportedError.prototype = Error.prototype;
      var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || 'This operation is not implemented';
        Error.call(this);
      };
      NotImplementedError.prototype = Error.prototype;
      var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError();
      };
      var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError();
      };
      var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
      if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
      }
      var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
      };
      var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined;
      };
      var isArrayLike = Rx.helpers.isArrayLike = function(o) {
        return o && o.length !== undefined;
      };
      Rx.helpers.iterator = $iterator$;
      var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
          return func;
        }
        switch (argCount) {
          case 0:
            return function() {
              return func.call(thisArg);
            };
          case 1:
            return function(arg) {
              return func.call(thisArg, arg);
            };
          case 2:
            return function(value, index) {
              return func.call(thisArg, value, index);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      };
      var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          errorClass = '[object Error]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var toString = Object.prototype.toString,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          supportsArgsClass = toString.call(arguments) == argsClass,
          supportNodeClass,
          errorProto = Error.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype,
          propertyIsEnumerable = objectProto.propertyIsEnumerable;
      try {
        supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
      } catch (e) {
        supportNodeClass = true;
      }
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
      };
      nonEnumProps[objectClass] = {'constructor': true};
      var support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        },
            props = [];
        ctor.prototype = {
          'valueOf': 1,
          'y': 1
        };
        for (var key in new ctor) {
          props.push(key);
        }
        for (key in arguments) {}
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
      }(1));
      var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
      };
      function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
          return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
          object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function',
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
          if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
            result.push(key);
          }
        }
        if (support.nonEnumShadows && object !== objectProto) {
          var ctor = object.constructor,
              index = -1,
              length = dontEnumsLength;
          if (object === (ctor && ctor.prototype)) {
            var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
          }
          while (++index < length) {
            key = dontEnums[index];
            if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
        }
        return result;
      }
      function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
          var key = props[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
        return object;
      }
      function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
      }
      function isNode(value) {
        return typeof value.toString != 'function' && typeof(value + '') == 'string';
      }
      var isArguments = function(value) {
        return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
      };
      if (!supportsArgsClass) {
        isArguments = function(value) {
          return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
        };
      }
      var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], []);
      };
      function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
          return a !== 0 || (1 / a == 1 / b);
        }
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
          return false;
        }
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) {
          className = objectClass;
        }
        if (otherClass == argsClass) {
          otherClass = objectClass;
        }
        if (className != otherClass) {
          return false;
        }
        switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
          case regexpClass:
          case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
          if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
            return false;
          }
          var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
              ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
          if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == a) {
            return stackB[length] == b;
          }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
          length = a.length;
          size = b.length;
          result = size == length;
          if (result) {
            while (size--) {
              var index = length,
                  value = b[size];
              if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                break;
              }
            }
          }
        } else {
          internalForIn(b, function(value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
            }
          });
          if (result) {
            internalForIn(a, function(value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return (result = --size > -1);
              }
            });
          }
        }
        stackA.pop();
        stackB.pop();
        return result;
      }
      var hasProp = {}.hasOwnProperty,
          slice = Array.prototype.slice;
      var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
          this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
      };
      var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [],
            i = 1,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
        for (var idx = 0,
            ln = sources.length; idx < ln; idx++) {
          var source = sources[idx];
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      };
      var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
          return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
      };
      function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
          a[i] = factory();
        }
        return a;
      }
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      function IndexedItem(id, value) {
        this.id = id;
        this.value = value;
      }
      IndexedItem.prototype.compareTo = function(other) {
        var c = this.value.compareTo(other.value);
        c === 0 && (c = this.id - other.id);
        return c;
      };
      var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
        this.items = new Array(capacity);
        this.length = 0;
      };
      var priorityProto = PriorityQueue.prototype;
      priorityProto.isHigherPriority = function(left, right) {
        return this.items[left].compareTo(this.items[right]) < 0;
      };
      priorityProto.percolate = function(index) {
        if (index >= this.length || index < 0) {
          return ;
        }
        var parent = index - 1 >> 1;
        if (parent < 0 || parent === index) {
          return ;
        }
        if (this.isHigherPriority(index, parent)) {
          var temp = this.items[index];
          this.items[index] = this.items[parent];
          this.items[parent] = temp;
          this.percolate(parent);
        }
      };
      priorityProto.heapify = function(index) {
        +index || (index = 0);
        if (index >= this.length || index < 0) {
          return ;
        }
        var left = 2 * index + 1,
            right = 2 * index + 2,
            first = index;
        if (left < this.length && this.isHigherPriority(left, first)) {
          first = left;
        }
        if (right < this.length && this.isHigherPriority(right, first)) {
          first = right;
        }
        if (first !== index) {
          var temp = this.items[index];
          this.items[index] = this.items[first];
          this.items[first] = temp;
          this.heapify(first);
        }
      };
      priorityProto.peek = function() {
        return this.items[0].value;
      };
      priorityProto.removeAt = function(index) {
        this.items[index] = this.items[--this.length];
        this.items[this.length] = undefined;
        this.heapify();
      };
      priorityProto.dequeue = function() {
        var result = this.peek();
        this.removeAt(0);
        return result;
      };
      priorityProto.enqueue = function(item) {
        var index = this.length++;
        this.items[index] = new IndexedItem(PriorityQueue.count++, item);
        this.percolate(index);
      };
      priorityProto.remove = function(item) {
        for (var i = 0; i < this.length; i++) {
          if (this.items[i].value === item) {
            this.removeAt(i);
            return true;
          }
        }
        return false;
      };
      PriorityQueue.count = 0;
      var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i,
            len;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
          len = args.length;
        } else {
          len = arguments.length;
          args = new Array(len);
          for (i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        for (i = 0; i < len; i++) {
          if (!isDisposable(args[i])) {
            throw new TypeError('Not a disposable');
          }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
      };
      var CompositeDisposablePrototype = CompositeDisposable.prototype;
      CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) {
          item.dispose();
        } else {
          this.disposables.push(item);
          this.length++;
        }
      };
      CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
          var idx = this.disposables.indexOf(item);
          if (idx !== -1) {
            shouldDispose = true;
            this.disposables.splice(idx, 1);
            this.length--;
            item.dispose();
          }
        }
        return shouldDispose;
      };
      CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var len = this.disposables.length,
              currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }
          this.disposables = [];
          this.length = 0;
          for (i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        }
      };
      var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop;
      };
      Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.action();
          this.isDisposed = true;
        }
      };
      var disposableCreate = Disposable.create = function(action) {
        return new Disposable(action);
      };
      var disposableEmpty = Disposable.empty = {dispose: noop};
      var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose);
      };
      var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) {
          throw new ObjectDisposedError();
        }
      };
      var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) {
          throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
      };
      SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SerialDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var RefCountDisposable = Rx.RefCountDisposable = (function() {
        function InnerDisposable(disposable) {
          this.disposable = disposable;
          this.disposable.count++;
          this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function() {
          if (!this.disposable.isDisposed && !this.isInnerDisposed) {
            this.isInnerDisposed = true;
            this.disposable.count--;
            if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
              this.disposable.isDisposed = true;
              this.disposable.underlyingDisposable.dispose();
            }
          }
        };
        function RefCountDisposable(disposable) {
          this.underlyingDisposable = disposable;
          this.isDisposed = false;
          this.isPrimaryDisposed = false;
          this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function() {
          if (!this.isDisposed && !this.isPrimaryDisposed) {
            this.isPrimaryDisposed = true;
            if (this.count === 0) {
              this.isDisposed = true;
              this.underlyingDisposable.dispose();
            }
          }
        };
        RefCountDisposable.prototype.getDisposable = function() {
          return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
      })();
      function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
      }
      function scheduleItem(s, self) {
        if (!self.isDisposed) {
          self.isDisposed = true;
          self.disposable.dispose();
        }
      }
      ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem);
      };
      var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
      };
      ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore());
      };
      ScheduledItem.prototype.compareTo = function(other) {
        return this.comparer(this.dueTime, other.dueTime);
      };
      ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed;
      };
      ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state);
      };
      var Scheduler = Rx.Scheduler = (function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
          this.now = now;
          this._schedule = schedule;
          this._scheduleRelative = scheduleRelative;
          this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function(s) {
          return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
          action();
          return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
          return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function(state, action) {
          return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
          return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
          return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
          timeSpan < 0 && (timeSpan = 0);
          return timeSpan;
        };
        return Scheduler;
      }());
      var normalizeTime = Scheduler.normalize,
          isScheduler = Scheduler.isScheduler;
      (function(schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          recursiveAction(state);
          return group;
        }
        function invokeRecDate(scheduler, pair, method) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2, dueTime1) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          ;
          recursiveAction(state);
          return group;
        }
        function scheduleInnerRecursive(action, self) {
          action(function(dt) {
            self(action, dt);
          });
        }
        schedulerProto.scheduleRecursive = function(action) {
          return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
          return this.scheduleWithState([state, action], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
          return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
          });
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
          return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period, action) {
          return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          if (typeof root.setInterval === 'undefined') {
            throw new NotSupportedError();
          }
          period = normalizeTime(period);
          var s = state,
              id = root.setInterval(function() {
                s = action(s);
              }, period);
          return disposableCreate(function() {
            root.clearInterval(id);
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
          return new CatchScheduler(this, handler);
        };
      }(Scheduler.prototype));
      var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
        function tick(command, recurse) {
          recurse(0, this._period);
          try {
            this._state = this._action(this._state);
          } catch (e) {
            this._cancel.dispose();
            throw e;
          }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
          this._scheduler = scheduler;
          this._state = state;
          this._period = period;
          this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function() {
          var d = new SingleAssignmentDisposable();
          this._cancel = d;
          d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
          return d;
        };
        return SchedulePeriodicRecursive;
      }());
      var immediateScheduler = Scheduler.immediate = (function() {
        function scheduleNow(state, action) {
          return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      }());
      var currentThreadScheduler = Scheduler.currentThread = (function() {
        var queue;
        function runTrampoline() {
          while (queue.length > 0) {
            var item = queue.dequeue();
            !item.isCancelled() && item.invoke();
          }
        }
        function scheduleNow(state, action) {
          var si = new ScheduledItem(this, state, action, this.now());
          if (!queue) {
            queue = new PriorityQueue(4);
            queue.enqueue(si);
            var result = tryCatch(runTrampoline)();
            queue = null;
            if (result === errorObj) {
              return thrower(result.e);
            }
          } else {
            queue.enqueue(si);
          }
          return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
          return !queue;
        };
        return currentScheduler;
      }());
      var scheduleMethod,
          clearMethod;
      var localTimer = (function() {
        var localSetTimeout,
            localClearTimeout = noop;
        if (!!root.setTimeout) {
          localSetTimeout = root.setTimeout;
          localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
          localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn();
          };
        } else {
          throw new NotSupportedError();
        }
        return {
          setTimeout: localSetTimeout,
          clearTimeout: localClearTimeout
        };
      }());
      var localSetTimeout = localTimer.setTimeout,
          localClearTimeout = localTimer.clearTimeout;
      (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
          delete tasksByHandle[handle];
        };
        function runTask(handle) {
          if (currentlyRunning) {
            localSetTimeout(function() {
              runTask(handle);
            }, 0);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunning = true;
              var result = tryCatch(task)();
              clearMethod(handle);
              currentlyRunning = false;
              if (result === errorObj) {
                return thrower(result.e);
              }
            }
          }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
          if (!root.postMessage || root.importScripts) {
            return false;
          }
          var isAsync = false,
              oldHandler = root.onmessage;
          root.onmessage = function() {
            isAsync = true;
          };
          root.postMessage('', '*');
          root.onmessage = oldHandler;
          return isAsync;
        }
        if (isFunction(setImmediate)) {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
              runTask(id);
            });
            return id;
          };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
              runTask(id);
            });
            return id;
          };
        } else if (postMessageSupported()) {
          var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
          function onGlobalPostMessage(event) {
            if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
              runTask(event.data.substring(MSG_PREFIX.length));
            }
          }
          if (root.addEventListener) {
            root.addEventListener('message', onGlobalPostMessage, false);
          } else if (root.attachEvent) {
            root.attachEvent('onmessage', onGlobalPostMessage);
          } else {
            root.onmessage = onGlobalPostMessage;
          }
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.postMessage(MSG_PREFIX + currentId, '*');
            return id;
          };
        } else if (!!root.MessageChannel) {
          var channel = new root.MessageChannel();
          channel.port1.onmessage = function(e) {
            runTask(e.data);
          };
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            channel.port2.postMessage(id);
            return id;
          };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
          scheduleMethod = function(action) {
            var scriptElement = root.document.createElement('script');
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
              runTask(id);
              scriptElement.onreadystatechange = null;
              scriptElement.parentNode.removeChild(scriptElement);
              scriptElement = null;
            };
            root.document.documentElement.appendChild(scriptElement);
            return id;
          };
        } else {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            localSetTimeout(function() {
              runTask(id);
            }, 0);
            return id;
          };
        }
      }());
      var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = (function() {
        function scheduleNow(state, action) {
          var scheduler = this,
              disposable = new SingleAssignmentDisposable();
          var id = scheduleMethod(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          });
          return new CompositeDisposable(disposable, disposableCreate(function() {
            clearMethod(id);
          }));
        }
        function scheduleRelative(state, dueTime, action) {
          var scheduler = this,
              dt = Scheduler.normalize(dueTime),
              disposable = new SingleAssignmentDisposable();
          if (dt === 0) {
            return scheduler.scheduleWithState(state, action);
          }
          var id = localSetTimeout(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          }, dt);
          return new CompositeDisposable(disposable, disposableCreate(function() {
            localClearTimeout(id);
          }));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      })();
      var CatchScheduler = (function(__super__) {
        function scheduleNow(state, action) {
          return this._scheduler.scheduleWithState(state, this._wrap(action));
        }
        function scheduleRelative(state, dueTime, action) {
          return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
        }
        inherits(CatchScheduler, __super__);
        function CatchScheduler(scheduler, handler) {
          this._scheduler = scheduler;
          this._handler = handler;
          this._recursiveOriginal = null;
          this._recursiveWrapper = null;
          __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
        }
        CatchScheduler.prototype._clone = function(scheduler) {
          return new CatchScheduler(scheduler, this._handler);
        };
        CatchScheduler.prototype._wrap = function(action) {
          var parent = this;
          return function(self, state) {
            try {
              return action(parent._getRecursiveWrapper(self), state);
            } catch (e) {
              if (!parent._handler(e)) {
                throw e;
              }
              return disposableEmpty;
            }
          };
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
          if (this._recursiveOriginal !== scheduler) {
            this._recursiveOriginal = scheduler;
            var wrapper = this._clone(scheduler);
            wrapper._recursiveOriginal = scheduler;
            wrapper._recursiveWrapper = wrapper;
            this._recursiveWrapper = wrapper;
          }
          return this._recursiveWrapper;
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          var self = this,
              failed = false,
              d = new SingleAssignmentDisposable();
          d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
            if (failed) {
              return null;
            }
            try {
              return action(state1);
            } catch (e) {
              failed = true;
              if (!self._handler(e)) {
                throw e;
              }
              d.dispose();
              return null;
            }
          }));
          return d;
        };
        return CatchScheduler;
      }(Scheduler));
      var Notification = Rx.Notification = (function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
          this.kind = kind;
          this.value = value;
          this.exception = exception;
          this._accept = accept;
          this._acceptObservable = acceptObservable;
          this.toString = toString;
        }
        Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
          return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function(scheduler) {
          var self = this;
          isScheduler(scheduler) || (scheduler = immediateScheduler);
          return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithState(self, function(_, notification) {
              notification._acceptObservable(observer);
              notification.kind === 'N' && observer.onCompleted();
            });
          });
        };
        return Notification;
      })();
      var notificationCreateOnNext = Notification.createOnNext = (function() {
        function _accept(onNext) {
          return onNext(this.value);
        }
        function _acceptObservable(observer) {
          return observer.onNext(this.value);
        }
        function toString() {
          return 'OnNext(' + this.value + ')';
        }
        return function(value) {
          return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnError = Notification.createOnError = (function() {
        function _accept(onNext, onError) {
          return onError(this.exception);
        }
        function _acceptObservable(observer) {
          return observer.onError(this.exception);
        }
        function toString() {
          return 'OnError(' + this.exception + ')';
        }
        return function(e) {
          return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
        function _accept(onNext, onError, onCompleted) {
          return onCompleted();
        }
        function _acceptObservable(observer) {
          return observer.onCompleted();
        }
        function toString() {
          return 'OnCompleted()';
        }
        return function() {
          return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
      }());
      var Observer = Rx.Observer = function() {};
      Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
          return n.accept(observer);
        };
      };
      Observer.prototype.asObserver = function() {
        return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
      };
      Observer.prototype.checked = function() {
        return new CheckedObserver(this);
      };
      var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
      };
      Observer.fromNotifier = function(handler, thisArg) {
        return new AnonymousObserver(function(x) {
          return handler.call(thisArg, notificationCreateOnNext(x));
        }, function(e) {
          return handler.call(thisArg, notificationCreateOnError(e));
        }, function() {
          return handler.call(thisArg, notificationCreateOnCompleted());
        });
      };
      Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this);
      };
      Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
      };
      var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
          this.isStopped = false;
          __super__.call(this);
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
          if (!this.isStopped) {
            this.next(value);
          }
        };
        AbstractObserver.prototype.onError = function(error) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(error);
          }
        };
        AbstractObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.completed();
          }
        };
        AbstractObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(e);
            return true;
          }
          return false;
        };
        return AbstractObserver;
      }(Observer));
      var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
          __super__.call(this);
          this._onNext = onNext;
          this._onError = onError;
          this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function(value) {
          this._onNext(value);
        };
        AnonymousObserver.prototype.error = function(error) {
          this._onError(error);
        };
        AnonymousObserver.prototype.completed = function() {
          this._onCompleted();
        };
        return AnonymousObserver;
      }(AbstractObserver));
      var CheckedObserver = (function(__super__) {
        inherits(CheckedObserver, __super__);
        function CheckedObserver(observer) {
          __super__.call(this);
          this._observer = observer;
          this._state = 0;
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
          this.checkAccess();
          var res = tryCatch(this._observer.onNext).call(this._observer, value);
          this._state = 0;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onError = function(err) {
          this.checkAccess();
          var res = tryCatch(this._observer.onError).call(this._observer, err);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onCompleted = function() {
          this.checkAccess();
          var res = tryCatch(this._observer.onCompleted).call(this._observer);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.checkAccess = function() {
          if (this._state === 1) {
            throw new Error('Re-entrancy detected');
          }
          if (this._state === 2) {
            throw new Error('Observer completed');
          }
          if (this._state === 0) {
            this._state = 1;
          }
        };
        return CheckedObserver;
      }(Observer));
      var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
          __super__.call(this);
          this.scheduler = scheduler;
          this.observer = observer;
          this.isAcquired = false;
          this.hasFaulted = false;
          this.queue = [];
          this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function(value) {
          var self = this;
          this.queue.push(function() {
            self.observer.onNext(value);
          });
        };
        ScheduledObserver.prototype.error = function(e) {
          var self = this;
          this.queue.push(function() {
            self.observer.onError(e);
          });
        };
        ScheduledObserver.prototype.completed = function() {
          var self = this;
          this.queue.push(function() {
            self.observer.onCompleted();
          });
        };
        ScheduledObserver.prototype.ensureActive = function() {
          var isOwner = false,
              parent = this;
          if (!this.hasFaulted && this.queue.length > 0) {
            isOwner = !this.isAcquired;
            this.isAcquired = true;
          }
          if (isOwner) {
            this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
              var work;
              if (parent.queue.length > 0) {
                work = parent.queue.shift();
              } else {
                parent.isAcquired = false;
                return ;
              }
              try {
                work();
              } catch (ex) {
                parent.queue = [];
                parent.hasFaulted = true;
                throw ex;
              }
              self();
            }));
          }
        };
        ScheduledObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.disposable.dispose();
        };
        return ScheduledObserver;
      }(AbstractObserver));
      var ObserveOnObserver = (function(__super__) {
        inherits(ObserveOnObserver, __super__);
        function ObserveOnObserver(scheduler, observer, cancel) {
          __super__.call(this, scheduler, observer);
          this._cancel = cancel;
        }
        ObserveOnObserver.prototype.next = function(value) {
          __super__.prototype.next.call(this, value);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.error = function(e) {
          __super__.prototype.error.call(this, e);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.completed = function() {
          __super__.prototype.completed.call(this);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this._cancel && this._cancel.dispose();
          this._cancel = null;
        };
        return ObserveOnObserver;
      })(ScheduledObserver);
      var observableProto;
      var Observable = Rx.Observable = (function() {
        function Observable(subscribe) {
          if (Rx.config.longStackSupport && hasStacks) {
            try {
              throw new Error();
            } catch (e) {
              this.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
            var self = this;
            this._subscribe = function(observer) {
              var oldOnError = observer.onError.bind(observer);
              observer.onError = function(err) {
                makeStackTraceLong(err, self);
                oldOnError(err);
              };
              return subscribe.call(self, observer);
            };
          } else {
            this._subscribe = subscribe;
          }
        }
        observableProto = Observable.prototype;
        observableProto.subscribe = observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
          return this._subscribe(typeof observerOrOnNext === 'object' ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
          return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
            onNext.call(thisArg, x);
          } : onNext));
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
          return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
            onError.call(thisArg, e);
          } : onError));
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
          return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
            onCompleted.call(thisArg);
          } : onCompleted));
        };
        return Observable;
      })();
      var ObservableBase = Rx.ObservableBase = (function(__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.subscribeCore).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function ObservableBase() {
          __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
      }(Observable));
      var Enumerable = Rx.internals.Enumerable = function() {};
      var ConcatEnumerableObservable = (function(__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function(e, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        function InnerObserver(o, s, e) {
          this.o = o;
          this.s = s;
          this.e = e;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.s(this.e);
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
            return true;
          }
          return false;
        };
        return ConcatEnumerableObservable;
      }(ObservableBase));
      Enumerable.prototype.concat = function() {
        return new ConcatEnumerableObservable(this);
      };
      var CatchErrorObservable = (function(__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function(o) {
          var e = this.sources[$iterator$]();
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return lastException !== null ? o.onError(lastException) : o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, self, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return CatchErrorObservable;
      }(ObservableBase));
      Enumerable.prototype.catchError = function() {
        return new CatchErrorObservable(this);
      };
      Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
          var exceptions = new Subject(),
              notifier = new Subject(),
              handled = notificationHandler(exceptions),
              notificationDisposable = handled.subscribe(notifier);
          var e = sources[$iterator$]();
          var isDisposed,
              lastException,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursive(function(self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              if (lastException) {
                o.onError(lastException);
              } else {
                o.onCompleted();
              }
              return ;
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var outer = new SingleAssignmentDisposable();
            var inner = new SingleAssignmentDisposable();
            subscription.setDisposable(new CompositeDisposable(inner, outer));
            outer.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(exn) {
              inner.setDisposable(notifier.subscribe(self, function(ex) {
                o.onError(ex);
              }, function() {
                o.onCompleted();
              }));
              exceptions.onNext(exn);
            }, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        });
      };
      var RepeatEnumerable = (function(__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
          this.v = v;
          this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function() {
          return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
          this.v = p.v;
          this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function() {
          if (this.l === 0) {
            return doneEnumerator;
          }
          if (this.l > 0) {
            this.l--;
          }
          return {
            done: false,
            value: this.v
          };
        };
        return RepeatEnumerable;
      }(Enumerable));
      var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
      };
      var OfEnumerable = (function(__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
          this.s = s;
          this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function() {
          return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
          this.i = -1;
          this.s = p.s;
          this.l = this.s.length;
          this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function() {
          return ++this.i < this.l ? {
            done: false,
            value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
          } : doneEnumerator;
        };
        return OfEnumerable;
      }(Enumerable));
      var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
      };
      observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(new ObserveOnObserver(scheduler, observer));
        }, source);
      };
      observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              d = new SerialDisposable();
          d.setDisposable(m);
          m.setDisposable(scheduler.schedule(function() {
            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
          }));
          return d;
        }, source);
      };
      var FromPromiseObservable = (function(__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
          this.p = p;
          __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function(o) {
          this.p.then(function(data) {
            o.onNext(data);
            o.onCompleted();
          }, function(err) {
            o.onError(err);
          });
          return disposableEmpty;
        };
        return FromPromiseObservable;
      }(ObservableBase));
      var observableFromPromise = Observable.fromPromise = function(promise) {
        return new FromPromiseObservable(promise);
      };
      observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
          throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function(resolve, reject) {
          var value,
              hasValue = false;
          source.subscribe(function(v) {
            value = v;
            hasValue = true;
          }, reject, function() {
            hasValue && resolve(value);
          });
        });
      };
      var ToArrayObservable = (function(__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.a = [];
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.a.push(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onNext(this.a);
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return ToArrayObservable;
      }(ObservableBase));
      observableProto.toArray = function() {
        return new ToArrayObservable(this);
      };
      Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
      };
      var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
          var result;
          try {
            result = observableFactory();
          } catch (e) {
            return observableThrow(e).subscribe(observer);
          }
          isPromise(result) && (result = observableFromPromise(result));
          return result.subscribe(observer);
        });
      };
      var EmptyObservable = (function(__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
          this.scheduler = scheduler;
          __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
          var sink = new EmptySink(observer, this);
          return sink.run();
        };
        function EmptySink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          state.onCompleted();
        }
        EmptySink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
      }(ObservableBase));
      var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new EmptyObservable(scheduler);
      };
      var FromObservable = (function(__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
          this.iterable = iterable;
          this.mapper = mapper;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromSink(observer, this);
          return sink.run();
        };
        return FromObservable;
      }(ObservableBase));
      var FromSink = (function() {
        function FromSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        FromSink.prototype.run = function() {
          var list = Object(this.parent.iterable),
              it = getIterable(list),
              observer = this.observer,
              mapper = this.parent.mapper;
          function loopRecursive(i, recurse) {
            try {
              var next = it.next();
            } catch (e) {
              return observer.onError(e);
            }
            if (next.done) {
              return observer.onCompleted();
            }
            var result = next.value;
            if (mapper) {
              try {
                result = mapper(result, i);
              } catch (e) {
                return observer.onError(e);
              }
            }
            observer.onNext(result);
            recurse(i + 1);
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
      }());
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function StringIterable(str) {
        this._s = s;
      }
      StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s);
      };
      function StringIterator(str) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
      }
      StringIterator.prototype[$iterator$] = function() {
        return this;
      };
      StringIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._s.charAt(this._i++)
        } : doneEnumerator;
      };
      function ArrayIterable(a) {
        this._a = a;
      }
      ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a);
      };
      function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
      }
      ArrayIterator.prototype[$iterator$] = function() {
        return this;
      };
      ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._a[this._i++]
        } : doneEnumerator;
      };
      function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
      }
      function isNan(n) {
        return n !== n;
      }
      function getIterable(o) {
        var i = o[$iterator$],
            it;
        if (!i && typeof o === 'string') {
          it = new StringIterable(o);
          return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
          it = new ArrayIterable(o);
          return it[$iterator$]();
        }
        if (!i) {
          throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
      }
      function sign(value) {
        var number = +value;
        if (number === 0) {
          return number;
        }
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      }
      function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
          return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
          return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
          return 0;
        }
        if (len > maxSafeInteger) {
          return maxSafeInteger;
        }
        return len;
      }
      var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
          throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
          throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
          var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
      };
      var FromArrayObservable = (function(__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
          this.args = args;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromArraySink(observer, this);
          return sink.run();
        };
        return FromArrayObservable;
      }(ObservableBase));
      function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            observer.onNext(args[i]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      };
      Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
          var first = true;
          return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
            var hasResult,
                result;
            try {
              if (first) {
                first = false;
              } else {
                state = iterate(state);
              }
              hasResult = condition(state);
              hasResult && (result = resultSelector(state));
            } catch (e) {
              return o.onError(e);
            }
            if (hasResult) {
              o.onNext(result);
              self(state);
            } else {
              o.onCompleted();
            }
          });
        });
      };
      var NeverObservable = (function(__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
          __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
          return disposableEmpty;
        };
        return NeverObservable;
      }(ObservableBase));
      var observableNever = Observable.never = function() {
        return new NeverObservable();
      };
      function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      }
      Observable.of = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
      };
      Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
      };
      var PairsObservable = (function(__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
          this.obj = obj;
          this.keys = Object.keys(obj);
          this.scheduler = scheduler;
          __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
          var sink = new PairsSink(observer, this);
          return sink.run();
        };
        return PairsObservable;
      }(ObservableBase));
      function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            var key = keys[i];
            observer.onNext([key, obj[key]]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
      };
      var RangeObservable = (function(__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
          this.start = start;
          this.rangeCount = count;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
          var sink = new RangeSink(observer, this);
          return sink.run();
        };
        return RangeObservable;
      }(ObservableBase));
      var RangeSink = (function() {
        function RangeSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        RangeSink.prototype.run = function() {
          var start = this.parent.start,
              count = this.parent.rangeCount,
              observer = this.observer;
          function loopRecursive(i, recurse) {
            if (i < count) {
              observer.onNext(start + i);
              recurse(i + 1);
            } else {
              observer.onCompleted();
            }
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
      }());
      Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
      };
      var RepeatObservable = (function(__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
          this.value = value;
          this.repeatCount = repeatCount == null ? -1 : repeatCount;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
          var sink = new RepeatSink(observer, this);
          return sink.run();
        };
        return RepeatObservable;
      }(ObservableBase));
      function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;
        function loopRecursive(i, recurse) {
          if (i === -1 || i > 0) {
            observer.onNext(value);
            i > 0 && i--;
          }
          if (i === 0) {
            return observer.onCompleted();
          }
          recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
      };
      Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
      };
      var JustObservable = (function(__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
          this.value = value;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function(observer) {
          var sink = new JustSink(observer, this);
          return sink.run();
        };
        function JustSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          var value = state[0],
              observer = state[1];
          observer.onNext(value);
          observer.onCompleted();
        }
        JustSink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState([this.parent.value, this.observer], scheduleItem);
        };
        return JustObservable;
      }(ObservableBase));
      var observableReturn = Observable['return'] = Observable.just = Observable.returnValue = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
      };
      var ThrowObservable = (function(__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
          this.error = error;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function(o) {
          var sink = new ThrowSink(o, this);
          return sink.run();
        };
        function ThrowSink(o, p) {
          this.o = o;
          this.p = p;
        }
        function scheduleItem(s, state) {
          var e = state[0],
              o = state[1];
          o.onError(e);
        }
        ThrowSink.prototype.run = function() {
          return this.p.scheduler.scheduleWithState([this.p.error, this.o], scheduleItem);
        };
        return ThrowObservable;
      }(ObservableBase));
      var observableThrow = Observable['throw'] = Observable.throwError = Observable.throwException = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
      };
      Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(observer) {
          var disposable = disposableEmpty,
              resource,
              source;
          try {
            resource = resourceFactory();
            resource && (disposable = resource);
            source = observableFactory(resource);
          } catch (exception) {
            return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
          }
          return new CompositeDisposable(source.subscribe(observer), disposable);
        });
      };
      observableProto.amb = function(rightSource) {
        var leftSource = this;
        return new AnonymousObservable(function(observer) {
          var choice,
              leftChoice = 'L',
              rightChoice = 'R',
              leftSubscription = new SingleAssignmentDisposable(),
              rightSubscription = new SingleAssignmentDisposable();
          isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
          function choiceL() {
            if (!choice) {
              choice = leftChoice;
              rightSubscription.dispose();
            }
          }
          function choiceR() {
            if (!choice) {
              choice = rightChoice;
              leftSubscription.dispose();
            }
          }
          leftSubscription.setDisposable(leftSource.subscribe(function(left) {
            choiceL();
            choice === leftChoice && observer.onNext(left);
          }, function(err) {
            choiceL();
            choice === leftChoice && observer.onError(err);
          }, function() {
            choiceL();
            choice === leftChoice && observer.onCompleted();
          }));
          rightSubscription.setDisposable(rightSource.subscribe(function(right) {
            choiceR();
            choice === rightChoice && observer.onNext(right);
          }, function(err) {
            choiceR();
            choice === rightChoice && observer.onError(err);
          }, function() {
            choiceR();
            choice === rightChoice && observer.onCompleted();
          }));
          return new CompositeDisposable(leftSubscription, rightSubscription);
        });
      };
      Observable.amb = function() {
        var acc = observableNever(),
            items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        function func(previous, current) {
          return previous.amb(current);
        }
        for (var i = 0,
            len = items.length; i < len; i++) {
          acc = func(acc, items[i]);
        }
        return acc;
      };
      function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
          var d1 = new SingleAssignmentDisposable(),
              subscription = new SerialDisposable();
          subscription.setDisposable(d1);
          d1.setDisposable(source.subscribe(function(x) {
            o.onNext(x);
          }, function(e) {
            try {
              var result = handler(e);
            } catch (ex) {
              return o.onError(ex);
            }
            isPromise(result) && (result = observableFromPromise(result));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(result.subscribe(o));
          }, function(x) {
            o.onCompleted(x);
          }));
          return subscription;
        }, source);
      }
      observableProto['catch'] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
        return typeof handlerOrSecond === 'function' ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
      };
      var observableCatch = Observable.catchError = Observable['catch'] = Observable.catchException = function() {
        var items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        return enumerableOf(items).catchError();
      };
      observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          args[0].unshift(this);
        } else {
          args.unshift(this);
        }
        return combineLatest.apply(this, args);
      };
      var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              falseFactory = function() {
                return false;
              },
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              isDone = arrayInitialize(n, falseFactory),
              values = new Array(n);
          function next(i) {
            hasValue[i] = true;
            if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
              try {
                var res = resultSelector.apply(null, values);
              } catch (e) {
                return o.onError(e);
              }
              o.onNext(res);
            } else if (isDone.filter(function(x, j) {
              return j !== i;
            }).every(identity)) {
              o.onCompleted();
            }
          }
          function done(i) {
            isDone[i] = true;
            isDone.every(identity) && o.onCompleted();
          }
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                values[i] = x;
                next(i);
              }, function(e) {
                o.onError(e);
              }, function() {
                done(i);
              }));
              subscriptions[i] = sad;
            }(idx));
          }
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      observableProto.concat = function() {
        for (var args = [],
            i = 0,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
      };
      var ConcatObservable = (function(__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function(o) {
          var sink = new ConcatSink(this.sources, o);
          return sink.run();
        };
        function ConcatSink(sources, o) {
          this.sources = sources;
          this.o = o;
        }
        ConcatSink.prototype.run = function() {
          var isDisposed,
              subscription = new SerialDisposable(),
              sources = this.sources,
              length = sources.length,
              o = this.o;
          var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function(i, self) {
            if (isDisposed) {
              return ;
            }
            if (i === length) {
              return o.onCompleted();
            }
            var currentValue = sources[i];
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              self(i + 1);
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return ConcatObservable;
      }(ObservableBase));
      var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(arguments.length);
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ConcatObservable(args);
      };
      observableProto.concatAll = observableProto.concatObservable = function() {
        return this.merge(1);
      };
      var MergeObservable = (function(__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
          this.source = source;
          this.maxConcurrent = maxConcurrent;
          __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable();
          g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
          return g;
        };
        return MergeObservable;
      }(ObservableBase));
      var MergeObserver = (function() {
        function MergeObserver(o, max, g) {
          this.o = o;
          this.max = max;
          this.g = g;
          this.done = false;
          this.q = [];
          this.activeCount = 0;
          this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(xs) && (xs = observableFromPromise(xs));
          sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          if (this.activeCount < this.max) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
          } else {
            this.q.push(innerSource);
          }
        };
        MergeObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.activeCount === 0 && this.o.onCompleted();
          }
        };
        MergeObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var parent = this.parent;
            parent.g.remove(this.sad);
            if (parent.q.length > 0) {
              parent.handleSubscribe(parent.q.shift());
            } else {
              parent.activeCount--;
              parent.done && parent.activeCount === 0 && parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeObserver;
      }());
      observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
      };
      var observableMerge = Observable.merge = function() {
        var scheduler,
            sources = [],
            i,
            len = arguments.length;
        if (!arguments[0]) {
          scheduler = immediateScheduler;
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else if (isScheduler(arguments[0])) {
          scheduler = arguments[0];
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else {
          scheduler = immediateScheduler;
          for (i = 0; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        if (Array.isArray(sources[0])) {
          sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
      };
      var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
      };
      CompositeError.prototype = Error.prototype;
      Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          var len = arguments.length;
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function(o) {
          var group = new CompositeDisposable(),
              m = new SingleAssignmentDisposable(),
              isStopped = false,
              errors = [];
          function setCompletion() {
            if (errors.length === 0) {
              o.onCompleted();
            } else if (errors.length === 1) {
              o.onError(errors[0]);
            } else {
              o.onError(new CompositeError(errors));
            }
          }
          group.add(m);
          m.setDisposable(source.subscribe(function(innerSource) {
            var innerSubscription = new SingleAssignmentDisposable();
            group.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              errors.push(e);
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }, function() {
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }));
          }, function(e) {
            errors.push(e);
            isStopped = true;
            group.length === 1 && setCompletion();
          }, function() {
            isStopped = true;
            group.length === 1 && setCompletion();
          }));
          return group;
        });
      };
      var MergeAllObservable = (function(__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable(),
              m = new SingleAssignmentDisposable();
          g.add(m);
          m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
          return g;
        };
        function MergeAllObserver(o, g) {
          this.o = o;
          this.g = g;
          this.isStopped = false;
          this.done = false;
        }
        MergeAllObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)));
        };
        MergeAllObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeAllObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.g.length === 1 && this.o.onCompleted();
          }
        };
        MergeAllObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, g, sad) {
          this.parent = parent;
          this.g = g;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            var parent = this.parent;
            this.isStopped = true;
            parent.g.remove(this.sad);
            parent.done && parent.g.length === 1 && parent.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeAllObservable;
      }(ObservableBase));
      observableProto.mergeAll = observableProto.mergeObservable = function() {
        return new MergeAllObservable(this);
      };
      observableProto.onErrorResumeNext = function(second) {
        if (!second) {
          throw new Error('Second observable is required');
        }
        return onErrorResumeNext([this, second]);
      };
      var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        return new AnonymousObservable(function(observer) {
          var pos = 0,
              subscription = new SerialDisposable(),
              cancelable = immediateScheduler.scheduleRecursive(function(self) {
                var current,
                    d;
                if (pos < sources.length) {
                  current = sources[pos++];
                  isPromise(current) && (current = observableFromPromise(current));
                  d = new SingleAssignmentDisposable();
                  subscription.setDisposable(d);
                  d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
                } else {
                  observer.onCompleted();
                }
              });
          return new CompositeDisposable(subscription, cancelable);
        });
      };
      observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var isOpen = false;
          var disposables = new CompositeDisposable(source.subscribe(function(left) {
            isOpen && o.onNext(left);
          }, function(e) {
            o.onError(e);
          }, function() {
            isOpen && o.onCompleted();
          }));
          isPromise(other) && (other = observableFromPromise(other));
          var rightSubscription = new SingleAssignmentDisposable();
          disposables.add(rightSubscription);
          rightSubscription.setDisposable(other.subscribe(function() {
            isOpen = true;
            rightSubscription.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            rightSubscription.dispose();
          }));
          return disposables;
        }, source);
      };
      var SwitchObservable = (function(__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function(o) {
          var inner = new SerialDisposable(),
              s = this.source.subscribe(new SwitchObserver(o, inner));
          return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
          this.o = o;
          this.inner = inner;
          this.stopped = false;
          this.latest = 0;
          this.hasLatest = false;
          this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var d = new SingleAssignmentDisposable(),
              id = ++this.latest;
          this.hasLatest = true;
          this.inner.setDisposable(d);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        SwitchObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.stopped = true;
            !this.hasLatest && this.o.onCompleted();
          }
        };
        SwitchObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, id) {
          this.parent = parent;
          this.id = id;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.latest === this.id && this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            if (this.parent.latest === this.id) {
              this.parent.hasLatest = false;
              this.parent.isStopped && this.parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return SwitchObservable;
      }(ObservableBase));
      observableProto['switch'] = observableProto.switchLatest = function() {
        return new SwitchObservable(this);
      };
      var TakeUntilObservable = (function(__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
          this.source = source;
          this.other = isPromise(other) ? observableFromPromise(other) : other;
          __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function(o) {
          return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TakeUntilObservable;
      }(ObservableBase));
      observableProto.takeUntil = function(other) {
        return new TakeUntilObservable(this, other);
      };
      function falseFactory() {
        return false;
      }
      observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop(),
            source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(observer) {
          var n = args.length,
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              values = new Array(n);
          var subscriptions = new Array(n + 1);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var other = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(other) && (other = observableFromPromise(other));
              sad.setDisposable(other.subscribe(function(x) {
                values[i] = x;
                hasValue[i] = true;
                hasValueAll = hasValue.every(identity);
              }, function(e) {
                observer.onError(e);
              }, noop));
              subscriptions[i] = sad;
            }(idx));
          }
          var sad = new SingleAssignmentDisposable();
          sad.setDisposable(source.subscribe(function(x) {
            var allValues = [x].concat(values);
            if (!hasValueAll) {
              return ;
            }
            var res = tryCatch(resultSelector).apply(null, allValues);
            if (res === errorObj) {
              return observer.onError(res.e);
            }
            observer.onNext(res);
          }, function(e) {
            observer.onError(e);
          }, function() {
            observer.onCompleted();
          }));
          subscriptions[n] = sad;
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(o) {
          var index = 0,
              len = second.length;
          return first.subscribe(function(left) {
            if (index < len) {
              var right = second[index++],
                  res = tryCatch(resultSelector)(left, right);
              if (res === errorObj) {
                return o.onError(res.e);
              }
              o.onNext(res);
            } else {
              o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, first);
      }
      function falseFactory() {
        return false;
      }
      function emptyArrayFactory() {
        return [];
      }
      observableProto.zip = function() {
        if (Array.isArray(arguments[0])) {
          return zipArray.apply(this, arguments);
        }
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var parent = this,
            resultSelector = args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              queues = arrayInitialize(n, emptyArrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var queuedValues = queues.map(function(x) {
                    return x.shift();
                  }),
                      res = tryCatch(resultSelector).apply(parent, queuedValues);
                  if (res === errorObj) {
                    return o.onError(res.e);
                  }
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
              subscriptions[i] = sad;
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        }, parent);
      };
      Observable.zip = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
      };
      function falseFactory() {
        return false;
      }
      function arrayFactory() {
        return [];
      }
      Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          var len = arguments.length;
          sources = new Array(len);
          for (var i = 0; i < len; i++) {
            sources[i] = arguments[i];
          }
        }
        return new AnonymousObservable(function(o) {
          var n = sources.length,
              queues = arrayInitialize(n, arrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              subscriptions[i] = new SingleAssignmentDisposable();
              subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var res = queues.map(function(x) {
                    return x.shift();
                  });
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  return o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        });
      };
      observableProto.asObservable = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(o);
        }, source);
      };
      observableProto.bufferWithCount = function(count, skip) {
        if (typeof skip !== 'number') {
          skip = count;
        }
        return this.windowWithCount(count, skip).selectMany(function(x) {
          return x.toArray();
        }).where(function(x) {
          return x.length > 0;
        });
      };
      observableProto.dematerialize = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(function(x) {
            return x.accept(o);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      observableProto.distinctUntilChanged = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hasCurrentKey = false,
              currentKey;
          return source.subscribe(function(value) {
            var key = value;
            if (keySelector) {
              key = tryCatch(keySelector)(value);
              if (key === errorObj) {
                return o.onError(key.e);
              }
            }
            if (hasCurrentKey) {
              var comparerEquals = tryCatch(comparer)(currentKey, key);
              if (comparerEquals === errorObj) {
                return o.onError(comparerEquals.e);
              }
            }
            if (!hasCurrentKey || !comparerEquals) {
              hasCurrentKey = true;
              currentKey = key;
              o.onNext(value);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var TapObservable = (function(__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
          this.source = source;
          this.t = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop, onCompleted || noop) : observerOrOnNext;
          __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.t));
        };
        function InnerObserver(o, t) {
          this.o = o;
          this.t = t;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var res = tryCatch(this.t.onNext).call(this.t, x);
          if (res === errorObj) {
            this.o.onError(res.e);
          }
          this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onError).call(this.t, err);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onCompleted).call(this.t);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TapObservable;
      }(ObservableBase));
      observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
      };
      observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext);
      };
      observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError);
      };
      observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted);
      };
      observableProto['finally'] = observableProto.ensure = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var subscription;
          try {
            subscription = source.subscribe(observer);
          } catch (e) {
            action();
            throw e;
          }
          return disposableCreate(function() {
            try {
              subscription.dispose();
            } catch (e) {
              throw e;
            } finally {
              action();
            }
          });
        }, this);
      };
      observableProto.finallyAction = function(action) {
        return this.ensure(action);
      };
      var IgnoreElementsObservable = (function(__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true;
          }
          return false;
        };
        return IgnoreElementsObservable;
      }(ObservableBase));
      observableProto.ignoreElements = function() {
        return new IgnoreElementsObservable(this);
      };
      observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(function(value) {
            observer.onNext(notificationCreateOnNext(value));
          }, function(e) {
            observer.onNext(notificationCreateOnError(e));
            observer.onCompleted();
          }, function() {
            observer.onNext(notificationCreateOnCompleted());
            observer.onCompleted();
          });
        }, source);
      };
      observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
      };
      observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
      };
      observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
      };
      var ScanObservable = (function(__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
          this.source = source;
          this.accumulator = accumulator;
          this.hasSeed = hasSeed;
          this.seed = seed;
          __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function(observer) {
          return this.source.subscribe(new ScanObserver(observer, this));
        };
        return ScanObservable;
      }(ObservableBase));
      function ScanObserver(observer, parent) {
        this.observer = observer;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      ScanObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        !this.hasValue && (this.hasValue = true);
        try {
          if (this.hasAccumulation) {
            this.accumulation = this.accumulator(this.accumulation, x);
          } else {
            this.accumulation = this.hasSeed ? this.accumulator(this.seed, x) : x;
            this.hasAccumulation = true;
          }
        } catch (e) {
          return this.observer.onError(e);
        }
        this.observer.onNext(this.accumulation);
      };
      ScanObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
        }
      };
      ScanObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          !this.hasValue && this.hasSeed && this.observer.onNext(this.seed);
          this.observer.onCompleted();
        }
      };
      ScanObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      ScanObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
          return true;
        }
        return false;
      };
      observableProto.scan = function() {
        var hasSeed = false,
            seed,
            accumulator,
            source = this;
        if (arguments.length === 2) {
          hasSeed = true;
          seed = arguments[0];
          accumulator = arguments[1];
        } else {
          accumulator = arguments[0];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
      };
      observableProto.skipLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && o.onNext(q.shift());
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.startWith = function() {
        var values,
            scheduler,
            start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
          scheduler = arguments[0];
          start = 1;
        } else {
          scheduler = immediateScheduler;
        }
        for (var args = [],
            i = start,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return enumerableOf([observableFromArray(args, scheduler), this]).concat();
      };
      observableProto.takeLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onNext(q);
            o.onCompleted();
          });
        }, source);
      };
      observableProto.windowWithCount = function(count, skip) {
        var source = this;
        +count || (count = 0);
        Math.abs(count) === Infinity && (count = 0);
        if (count <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        skip == null && (skip = count);
        +skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              refCountDisposable = new RefCountDisposable(m),
              n = 0,
              q = [];
          function createWindow() {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          createWindow();
          m.setDisposable(source.subscribe(function(x) {
            for (var i = 0,
                len = q.length; i < len; i++) {
              q[i].onNext(x);
            }
            var c = n - count + 1;
            c >= 0 && c % skip === 0 && q.shift().onCompleted();
            ++n % skip === 0 && createWindow();
          }, function(e) {
            while (q.length > 0) {
              q.shift().onError(e);
            }
            observer.onError(e);
          }, function() {
            while (q.length > 0) {
              q.shift().onCompleted();
            }
            observer.onCompleted();
          }));
          return refCountDisposable;
        }, source);
      };
      function concatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).concatAll();
      }
      observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.concatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          });
        }
        return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
          return selector;
        });
      };
      observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNextFunc(x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onErrorFunc(err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompletedFunc();
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, this).concatAll();
      };
      observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
          var found = false;
          return source.subscribe(function(x) {
            found = true;
            observer.onNext(x);
          }, function(e) {
            observer.onError(e);
          }, function() {
            !found && observer.onNext(defaultValue);
            observer.onCompleted();
          });
        }, source);
      };
      function arrayIndexOfComparer(array, item, comparer) {
        for (var i = 0,
            len = array.length; i < len; i++) {
          if (comparer(array[i], item)) {
            return i;
          }
        }
        return -1;
      }
      function HashSet(comparer) {
        this.comparer = comparer;
        this.set = [];
      }
      HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue;
      };
      observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hashSet = new HashSet(comparer);
          return source.subscribe(function(x) {
            var key = x;
            if (keySelector) {
              try {
                key = keySelector(x);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            hashSet.push(key) && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var MapObservable = (function(__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
          this.source = source;
          this.selector = bindCallback(selector, thisArg, 3);
          __super__.call(this);
        }
        function innerMap(selector, self) {
          return function(x, i, o) {
            return selector.call(this, self.selector(x, i, o), i, o);
          };
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
          return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
          this.o = o;
          this.selector = selector;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var result = tryCatch(this.selector)(x, this.i++, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return MapObservable;
      }(ObservableBase));
      observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function() {
          return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
      };
      observableProto.pluck = function() {
        var args = arguments,
            len = arguments.length;
        if (len === 0) {
          throw new Error('List of properties cannot be empty.');
        }
        return this.map(function(x) {
          var currentProp = x;
          for (var i = 0; i < len; i++) {
            var p = currentProp[args[i]];
            if (typeof p !== 'undefined') {
              currentProp = p;
            } else {
              return undefined;
            }
          }
          return currentProp;
        });
      };
      observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNext.call(thisArg, x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onError.call(thisArg, err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompleted.call(thisArg);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, source).mergeAll();
      };
      function flatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).mergeAll();
      }
      observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.flatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          }, thisArg);
        }
        return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
          return selector;
        });
      };
      observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
        return this.select(selector, thisArg).switchLatest();
      };
      var SkipObservable = (function(__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
          this.source = source;
          this.skipCount = count;
          __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
          this.c = c;
          this.r = c;
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          if (this.r <= 0) {
            this.o.onNext(x);
          } else {
            this.r--;
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return SkipObservable;
      }(ObservableBase));
      observableProto.skip = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
      };
      observableProto.skipWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = false;
          return source.subscribe(function(x) {
            if (!running) {
              try {
                running = !callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            running && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.take = function(count, scheduler) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
          return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var remaining = count;
          return source.subscribe(function(x) {
            if (remaining-- > 0) {
              o.onNext(x);
              remaining <= 0 && o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = true;
          return source.subscribe(function(x) {
            if (running) {
              try {
                running = callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
              if (running) {
                o.onNext(x);
              } else {
                o.onCompleted();
              }
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      var FilterObservable = (function(__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
          this.source = source;
          this.predicate = bindCallback(predicate, thisArg, 3);
          __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
          return function(x, i, o) {
            return self.predicate(x, i, o) && predicate.call(this, x, i, o);
          };
        }
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
          return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
          this.o = o;
          this.predicate = predicate;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
          if (shouldYield === errorObj) {
            return this.o.onError(shouldYield.e);
          }
          shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return FilterObservable;
      }(ObservableBase));
      observableProto.filter = observableProto.where = function(predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
      };
      observableProto.transduce = function(transducer) {
        var source = this;
        function transformForObserver(o) {
          return {
            '@@transducer/init': function() {
              return o;
            },
            '@@transducer/step': function(obs, input) {
              return obs.onNext(input);
            },
            '@@transducer/result': function(obs) {
              return obs.onCompleted();
            }
          };
        }
        return new AnonymousObservable(function(o) {
          var xform = transducer(transformForObserver(o));
          return source.subscribe(function(v) {
            try {
              xform['@@transducer/step'](o, v);
            } catch (e) {
              o.onError(e);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            xform['@@transducer/result'](o);
          });
        }, source);
      };
      var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              subscribe = state[1];
          var sub = tryCatch(subscribe)(ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function AnonymousObservable(subscribe, parent) {
          this.source = parent;
          function s(observer) {
            var ado = new AutoDetachObserver(observer),
                state = [ado, subscribe];
            if (currentThreadScheduler.scheduleRequired()) {
              currentThreadScheduler.scheduleWithState(state, setDisposable);
            } else {
              setDisposable(null, state);
            }
            return ado;
          }
          __super__.call(this, s);
        }
        return AnonymousObservable;
      }(Observable));
      var AutoDetachObserver = (function(__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
          __super__.call(this);
          this.observer = observer;
          this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
          var result = tryCatch(this.observer.onNext).call(this.observer, value);
          if (result === errorObj) {
            this.dispose();
            thrower(result.e);
          }
        };
        AutoDetachObserverPrototype.error = function(err) {
          var result = tryCatch(this.observer.onError).call(this.observer, err);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function() {
          var result = tryCatch(this.observer.onCompleted).call(this.observer);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
          this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function() {
          return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.m.dispose();
        };
        return AutoDetachObserver;
      }(AbstractObserver));
      var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      };
      InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
          var idx = this.subject.observers.indexOf(this.observer);
          this.subject.observers.splice(idx, 1);
          this.observer = null;
        }
      };
      var Subject = Rx.Subject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
            return disposableEmpty;
          }
          observer.onCompleted();
          return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
          __super__.call(this, subscribe);
          this.isDisposed = false, this.isStopped = false, this.observers = [];
          this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
          hasObservers: function() {
            return this.observers.length > 0;
          },
          onCompleted: function() {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onCompleted();
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.error = error;
              this.hasError = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (!this.isStopped) {
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onNext(value);
              }
            }
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
          }
        });
        Subject.create = function(observer, observable) {
          return new AnonymousSubject(observer, observable);
        };
        return Subject;
      }(Observable));
      var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
          } else if (this.hasValue) {
            observer.onNext(this.value);
            observer.onCompleted();
          } else {
            observer.onCompleted();
          }
          return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
          __super__.call(this, subscribe);
          this.isDisposed = false;
          this.isStopped = false;
          this.hasValue = false;
          this.observers = [];
          this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
          hasObservers: function() {
            checkDisposed(this);
            return this.observers.length > 0;
          },
          onCompleted: function() {
            var i,
                len;
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              var os = cloneArray(this.observers),
                  len = os.length;
              if (this.hasValue) {
                for (i = 0; i < len; i++) {
                  var o = os[i];
                  o.onNext(this.value);
                  o.onCompleted();
                }
              } else {
                for (i = 0; i < len; i++) {
                  os[i].onCompleted();
                }
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.hasError = true;
              this.error = error;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (this.isStopped) {
              return ;
            }
            this.value = value;
            this.hasValue = true;
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
            this.exception = null;
            this.value = null;
          }
        });
        return AsyncSubject;
      }(Observable));
      var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
          return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
          this.observer = observer;
          this.observable = observable;
          __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
          onCompleted: function() {
            this.observer.onCompleted();
          },
          onError: function(error) {
            this.observer.onError(error);
          },
          onNext: function(value) {
            this.observer.onNext(value);
          }
        });
        return AnonymousSubject;
      }(Observable));
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function() {
          return Rx;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = Rx).Rx = Rx;
        } else {
          freeExports.Rx = Rx;
        }
      } else {
        root.Rx = Rx;
      }
      var rEndingLine = captureLine();
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.aggregates", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        CompositeDisposable = Rx.CompositeDisposable,
        AnonymousObservable = Rx.AnonymousObservable,
        disposableEmpty = Rx.Disposable.empty,
        isEqual = Rx.internals.isEqual,
        helpers = Rx.helpers,
        not = helpers.not,
        defaultComparer = helpers.defaultComparer,
        identity = helpers.identity,
        defaultSubComparer = helpers.defaultSubComparer,
        isFunction = helpers.isFunction,
        isPromise = helpers.isPromise,
        isArrayLike = helpers.isArrayLike,
        isIterable = helpers.isIterable,
        inherits = Rx.internals.inherits,
        observableFromPromise = Observable.fromPromise,
        observableFrom = Observable.from,
        bindCallback = Rx.internals.bindCallback,
        EmptyError = Rx.EmptyError,
        ObservableBase = Rx.ObservableBase,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function extremaBy(source, keySelector, comparer) {
      return new AnonymousObservable(function(o) {
        var hasValue = false,
            lastKey = null,
            list = [];
        return source.subscribe(function(x) {
          var comparison,
              key;
          try {
            key = keySelector(x);
          } catch (ex) {
            o.onError(ex);
            return ;
          }
          comparison = 0;
          if (!hasValue) {
            hasValue = true;
            lastKey = key;
          } else {
            try {
              comparison = comparer(key, lastKey);
            } catch (ex1) {
              o.onError(ex1);
              return ;
            }
          }
          if (comparison > 0) {
            lastKey = key;
            list = [];
          }
          if (comparison >= 0) {
            list.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(list);
          o.onCompleted();
        });
      }, source);
    }
    function firstOnly(x) {
      if (x.length === 0) {
        throw new EmptyError();
      }
      return x[0];
    }
    observableProto.aggregate = function() {
      var hasSeed = false,
          accumulator,
          seed,
          source = this;
      if (arguments.length === 2) {
        hasSeed = true;
        seed = arguments[0];
        accumulator = arguments[1];
      } else {
        accumulator = arguments[0];
      }
      return new AnonymousObservable(function(o) {
        var hasAccumulation,
            accumulation,
            hasValue;
        return source.subscribe(function(x) {
          !hasValue && (hasValue = true);
          try {
            if (hasAccumulation) {
              accumulation = accumulator(accumulation, x);
            } else {
              accumulation = hasSeed ? accumulator(seed, x) : x;
              hasAccumulation = true;
            }
          } catch (e) {
            return o.onError(e);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          hasValue && o.onNext(accumulation);
          !hasValue && hasSeed && o.onNext(seed);
          !hasValue && !hasSeed && o.onError(new EmptyError());
          o.onCompleted();
        });
      }, source);
    };
    var ReduceObservable = (function(__super__) {
      inherits(ReduceObservable, __super__);
      function ReduceObservable(source, acc, hasSeed, seed) {
        this.source = source;
        this.acc = acc;
        this.hasSeed = hasSeed;
        this.seed = seed;
        __super__.call(this);
      }
      ReduceObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new InnerObserver(observer, this));
      };
      function InnerObserver(o, parent) {
        this.o = o;
        this.acc = parent.acc;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.result = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        !this.hasValue && (this.hasValue = true);
        if (this.hasAccumulation) {
          this.result = tryCatch(this.acc)(this.result, x);
        } else {
          this.result = this.hasSeed ? tryCatch(this.acc)(this.seed, x) : x;
          this.hasAccumulation = true;
        }
        if (this.result === errorObj) {
          this.o.onError(this.result.e);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasValue && this.o.onNext(this.result);
          !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
          !this.hasValue && !this.hasSeed && this.o.onError(new EmptyError());
          this.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      return ReduceObservable;
    }(ObservableBase));
    observableProto.reduce = function(accumulator) {
      var hasSeed = false;
      if (arguments.length === 2) {
        hasSeed = true;
        var seed = arguments[1];
      }
      return new ReduceObservable(this, accumulator, hasSeed, seed);
    };
    observableProto.some = function(predicate, thisArg) {
      var source = this;
      return predicate ? source.filter(predicate, thisArg).some() : new AnonymousObservable(function(observer) {
        return source.subscribe(function() {
          observer.onNext(true);
          observer.onCompleted();
        }, function(e) {
          observer.onError(e);
        }, function() {
          observer.onNext(false);
          observer.onCompleted();
        });
      }, source);
    };
    observableProto.any = function() {
      return this.some.apply(this, arguments);
    };
    observableProto.isEmpty = function() {
      return this.any().map(not);
    };
    observableProto.every = function(predicate, thisArg) {
      return this.filter(function(v) {
        return !predicate(v);
      }, thisArg).some().map(not);
    };
    observableProto.all = function() {
      return this.every.apply(this, arguments);
    };
    observableProto.includes = function(searchElement, fromIndex) {
      var source = this;
      function comparer(a, b) {
        return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
      }
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(false);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i++ >= n && comparer(x, searchElement)) {
            o.onNext(true);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(false);
          o.onCompleted();
        });
      }, this);
    };
    observableProto.contains = function(searchElement, fromIndex) {
      observableProto.includes(searchElement, fromIndex);
    };
    observableProto.count = function(predicate, thisArg) {
      return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
        return count + 1;
      }, 0);
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(-1);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i >= n && x === searchElement) {
            o.onNext(i);
            o.onCompleted();
          }
          i++;
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(-1);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.sum = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
        return prev + curr;
      }, 0);
    };
    observableProto.minBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, function(x, y) {
        return comparer(x, y) * -1;
      });
    };
    observableProto.min = function(comparer) {
      return this.minBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.maxBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, comparer);
    };
    observableProto.max = function(comparer) {
      return this.maxBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.average = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).average() : this.reduce(function(prev, cur) {
        return {
          sum: prev.sum + cur,
          count: prev.count + 1
        };
      }, {
        sum: 0,
        count: 0
      }).map(function(s) {
        if (s.count === 0) {
          throw new EmptyError();
        }
        return s.sum / s.count;
      });
    };
    observableProto.sequenceEqual = function(second, comparer) {
      var first = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var donel = false,
            doner = false,
            ql = [],
            qr = [];
        var subscription1 = first.subscribe(function(x) {
          var equal,
              v;
          if (qr.length > 0) {
            v = qr.shift();
            try {
              equal = comparer(v, x);
            } catch (e) {
              o.onError(e);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (doner) {
            o.onNext(false);
            o.onCompleted();
          } else {
            ql.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          donel = true;
          if (ql.length === 0) {
            if (qr.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (doner) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
        isPromise(second) && (second = observableFromPromise(second));
        var subscription2 = second.subscribe(function(x) {
          var equal;
          if (ql.length > 0) {
            var v = ql.shift();
            try {
              equal = comparer(v, x);
            } catch (exception) {
              o.onError(exception);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (donel) {
            o.onNext(false);
            o.onCompleted();
          } else {
            qr.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          doner = true;
          if (qr.length === 0) {
            if (ql.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (donel) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        return new CompositeDisposable(subscription1, subscription2);
      }, first);
    };
    function elementAtOrDefault(source, index, hasDefault, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError();
      }
      return new AnonymousObservable(function(o) {
        var i = index;
        return source.subscribe(function(x) {
          if (i-- === 0) {
            o.onNext(x);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new ArgumentOutOfRangeError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.elementAt = function(index) {
      return elementAtOrDefault(this, index, false);
    };
    observableProto.elementAtOrDefault = function(index, defaultValue) {
      return elementAtOrDefault(this, index, true, defaultValue);
    };
    function singleOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          if (seenValue) {
            o.onError(new Error('Sequence contains more than one element'));
          } else {
            value = x;
            seenValue = true;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.single = function(predicate, thisArg) {
      return predicate && isFunction(predicate) ? this.where(predicate, thisArg).single() : singleOrDefaultAsync(this, false);
    };
    observableProto.singleOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate && isFunction(predicate) ? this.filter(predicate, thisArg).singleOrDefault(null, defaultValue) : singleOrDefaultAsync(this, true, defaultValue);
    };
    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        return source.subscribe(function(x) {
          o.onNext(x);
          o.onCompleted();
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.first = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).first() : firstOrDefaultAsync(this, false);
    };
    observableProto.firstOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate).firstOrDefault(null, defaultValue) : firstOrDefaultAsync(this, true, defaultValue);
    };
    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          value = x;
          seenValue = true;
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.last = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).last() : lastOrDefaultAsync(this, false);
    };
    observableProto.lastOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate, thisArg).lastOrDefault(null, defaultValue) : lastOrDefaultAsync(this, true, defaultValue);
    };
    function findValue(source, predicate, thisArg, yieldIndex) {
      var callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0;
        return source.subscribe(function(x) {
          var shouldRun;
          try {
            shouldRun = callback(x, i, source);
          } catch (e) {
            o.onError(e);
            return ;
          }
          if (shouldRun) {
            o.onNext(yieldIndex ? i : x);
            o.onCompleted();
          } else {
            i++;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(yieldIndex ? -1 : undefined);
          o.onCompleted();
        });
      }, source);
    }
    observableProto.find = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, false);
    };
    observableProto.findIndex = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, true);
    };
    observableProto.toSet = function() {
      if (typeof root.Set === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var s = new root.Set();
        return source.subscribe(function(x) {
          s.add(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(s);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.toMap = function(keySelector, elementSelector) {
      if (typeof root.Map === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var m = new root.Map();
        return source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            o.onError(e);
            return ;
          }
          var element = x;
          if (elementSelector) {
            try {
              element = elementSelector(x);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          m.set(key, element);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(m);
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.async", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx.binding", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        observableFromPromise = Observable.fromPromise,
        observableThrow = Observable.throwError,
        AnonymousObservable = Rx.AnonymousObservable,
        AsyncSubject = Rx.AsyncSubject,
        disposableCreate = Rx.Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        immediateScheduler = Rx.Scheduler.immediate,
        timeoutScheduler = Rx.Scheduler['default'],
        isScheduler = Rx.Scheduler.isScheduler,
        slice = Array.prototype.slice;
    var fnString = 'function',
        throwString = 'throw',
        isObject = Rx.internals.isObject;
    function toThunk(obj, ctx) {
      if (Array.isArray(obj)) {
        return objectToThunk.call(ctx, obj);
      }
      if (isGeneratorFunction(obj)) {
        return observableSpawn(obj.call(ctx));
      }
      if (isGenerator(obj)) {
        return observableSpawn(obj);
      }
      if (isObservable(obj)) {
        return observableToThunk(obj);
      }
      if (isPromise(obj)) {
        return promiseToThunk(obj);
      }
      if (typeof obj === fnString) {
        return obj;
      }
      if (isObject(obj) || Array.isArray(obj)) {
        return objectToThunk.call(ctx, obj);
      }
      return obj;
    }
    function objectToThunk(obj) {
      var ctx = this;
      return function(done) {
        var keys = Object.keys(obj),
            pending = keys.length,
            results = new obj.constructor(),
            finished;
        if (!pending) {
          timeoutScheduler.schedule(function() {
            done(null, results);
          });
          return ;
        }
        for (var i = 0,
            len = keys.length; i < len; i++) {
          run(obj[keys[i]], keys[i]);
        }
        function run(fn, key) {
          if (finished) {
            return ;
          }
          try {
            fn = toThunk(fn, ctx);
            if (typeof fn !== fnString) {
              results[key] = fn;
              return --pending || done(null, results);
            }
            fn.call(ctx, function(err, res) {
              if (finished) {
                return ;
              }
              if (err) {
                finished = true;
                return done(err);
              }
              results[key] = res;
              --pending || done(null, results);
            });
          } catch (e) {
            finished = true;
            done(e);
          }
        }
      };
    }
    function observableToThunk(observable) {
      return function(fn) {
        var value,
            hasValue = false;
        observable.subscribe(function(v) {
          value = v;
          hasValue = true;
        }, fn, function() {
          hasValue && fn(null, value);
        });
      };
    }
    function promiseToThunk(promise) {
      return function(fn) {
        promise.then(function(res) {
          fn(null, res);
        }, fn);
      };
    }
    function isObservable(obj) {
      return obj && typeof obj.subscribe === fnString;
    }
    function isGeneratorFunction(obj) {
      return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
    }
    function isGenerator(obj) {
      return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
    }
    var observableSpawn = Rx.spawn = function(fn) {
      var isGenFun = isGeneratorFunction(fn);
      return function(done) {
        var ctx = this,
            gen = fn;
        if (isGenFun) {
          for (var args = [],
              i = 0,
              len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
          }
          var len = args.length,
              hasCallback = len && typeof args[len - 1] === fnString;
          done = hasCallback ? args.pop() : handleError;
          gen = fn.apply(this, args);
        } else {
          done = done || handleError;
        }
        next();
        function exit(err, res) {
          timeoutScheduler.schedule(done.bind(ctx, err, res));
        }
        function next(err, res) {
          var ret;
          if (arguments.length > 2) {
            for (var res = [],
                i = 1,
                len = arguments.length; i < len; i++) {
              res.push(arguments[i]);
            }
          }
          if (err) {
            try {
              ret = gen[throwString](err);
            } catch (e) {
              return exit(e);
            }
          }
          if (!err) {
            try {
              ret = gen.next(res);
            } catch (e) {
              return exit(e);
            }
          }
          if (ret.done) {
            return exit(null, ret.value);
          }
          ret.value = toThunk(ret.value, ctx);
          if (typeof ret.value === fnString) {
            var called = false;
            try {
              ret.value.call(ctx, function() {
                if (called) {
                  return ;
                }
                called = true;
                next.apply(ctx, arguments);
              });
            } catch (e) {
              timeoutScheduler.schedule(function() {
                if (called) {
                  return ;
                }
                called = true;
                next.call(ctx, e);
              });
            }
            return ;
          }
          next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
        }
      };
    };
    function handleError(err) {
      if (!err) {
        return ;
      }
      timeoutScheduler.schedule(function() {
        throw err;
      });
    }
    Observable.start = function(func, context, scheduler) {
      return observableToAsync(func, context, scheduler)();
    };
    var observableToAsync = Observable.toAsync = function(func, context, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return function() {
        var args = arguments,
            subject = new AsyncSubject();
        scheduler.schedule(function() {
          var result;
          try {
            result = func.apply(context, args);
          } catch (e) {
            subject.onError(e);
            return ;
          }
          subject.onNext(result);
          subject.onCompleted();
        });
        return subject.asObservable();
      };
    };
    Observable.fromCallback = function(func, context, selector) {
      return function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new AnonymousObservable(function(observer) {
          function handler() {
            var len = arguments.length,
                results = new Array(len);
            for (var i = 0; i < len; i++) {
              results[i] = arguments[i];
            }
            if (selector) {
              try {
                results = selector.apply(context, results);
              } catch (e) {
                return observer.onError(e);
              }
              observer.onNext(results);
            } else {
              if (results.length <= 1) {
                observer.onNext.apply(observer, results);
              } else {
                observer.onNext(results);
              }
            }
            observer.onCompleted();
          }
          args.push(handler);
          func.apply(context, args);
        }).publishLast().refCount();
      };
    };
    Observable.fromNodeCallback = function(func, context, selector) {
      return function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new AnonymousObservable(function(observer) {
          function handler(err) {
            if (err) {
              observer.onError(err);
              return ;
            }
            var len = arguments.length,
                results = [];
            for (var i = 1; i < len; i++) {
              results[i - 1] = arguments[i];
            }
            if (selector) {
              try {
                results = selector.apply(context, results);
              } catch (e) {
                return observer.onError(e);
              }
              observer.onNext(results);
            } else {
              if (results.length <= 1) {
                observer.onNext.apply(observer, results);
              } else {
                observer.onNext(results);
              }
            }
            observer.onCompleted();
          }
          args.push(handler);
          func.apply(context, args);
        }).publishLast().refCount();
      };
    };
    function createListener(element, name, handler) {
      if (element.addEventListener) {
        element.addEventListener(name, handler, false);
        return disposableCreate(function() {
          element.removeEventListener(name, handler, false);
        });
      }
      throw new Error('No listener found');
    }
    function createEventListener(el, eventName, handler) {
      var disposables = new CompositeDisposable();
      var toStr = Object.prototype.toString;
      if (toStr.call(el) === '[object NodeList]' || toStr.call(el) === '[object HTMLCollection]') {
        for (var i = 0,
            len = el.length; i < len; i++) {
          disposables.add(createEventListener(el.item(i), eventName, handler));
        }
      } else if (el) {
        disposables.add(createListener(el, eventName, handler));
      }
      return disposables;
    }
    Rx.config.useNativeEvents = false;
    Observable.fromEvent = function(element, eventName, selector) {
      if (element.addListener) {
        return fromEventPattern(function(h) {
          element.addListener(eventName, h);
        }, function(h) {
          element.removeListener(eventName, h);
        }, selector);
      }
      if (!Rx.config.useNativeEvents) {
        if (typeof element.on === 'function' && typeof element.off === 'function') {
          return fromEventPattern(function(h) {
            element.on(eventName, h);
          }, function(h) {
            element.off(eventName, h);
          }, selector);
        }
      }
      return new AnonymousObservable(function(observer) {
        return createEventListener(element, eventName, function handler(e) {
          var results = e;
          if (selector) {
            try {
              results = selector(arguments);
            } catch (err) {
              return observer.onError(err);
            }
          }
          observer.onNext(results);
        });
      }).publish().refCount();
    };
    var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector) {
      return new AnonymousObservable(function(observer) {
        function innerHandler(e) {
          var result = e;
          if (selector) {
            try {
              result = selector(arguments);
            } catch (err) {
              return observer.onError(err);
            }
          }
          observer.onNext(result);
        }
        var returnValue = addHandler(innerHandler);
        return disposableCreate(function() {
          if (removeHandler) {
            removeHandler(innerHandler, returnValue);
          }
        });
      }).publish().refCount();
    };
    Observable.startAsync = function(functionAsync) {
      var promise;
      try {
        promise = functionAsync();
      } catch (e) {
        return observableThrow(e);
      }
      return observableFromPromise(promise);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.backpressure", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        CompositeDisposable = Rx.CompositeDisposable,
        Notification = Rx.Notification,
        Subject = Rx.Subject,
        Observer = Rx.Observer,
        disposableEmpty = Rx.Disposable.empty,
        disposableCreate = Rx.Disposable.create,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        timeoutScheduler = Rx.Scheduler.timeout,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        identity = Rx.helpers.identity,
        isScheduler = Rx.Scheduler.isScheduler,
        isFunction = Rx.helpers.isFunction,
        checkDisposed = Rx.Disposable.checkDisposed;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    Rx.Pauser = (function(__super__) {
      inherits(Pauser, __super__);
      function Pauser() {
        __super__.call(this);
      }
      Pauser.prototype.pause = function() {
        this.onNext(false);
      };
      Pauser.prototype.resume = function() {
        this.onNext(true);
      };
      return Pauser;
    }(Subject));
    var PausableObservable = (function(__super__) {
      inherits(PausableObservable, __super__);
      function subscribe(observer) {
        var conn = this.source.publish(),
            subscription = conn.subscribe(observer),
            connection = disposableEmpty;
        var pausable = this.pauser.distinctUntilChanged().subscribe(function(b) {
          if (b) {
            connection = conn.connect();
          } else {
            connection.dispose();
            connection = disposableEmpty;
          }
        });
        return new CompositeDisposable(subscription, connection, pausable);
      }
      function PausableObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableObservable;
    }(Observable));
    observableProto.pausable = function(pauser) {
      return new PausableObservable(this, pauser);
    };
    function combineLatestSource(source, subject, resultSelector) {
      return new AnonymousObservable(function(o) {
        var hasValue = [false, false],
            hasValueAll = false,
            isDone = false,
            values = new Array(2),
            err;
        function next(x, i) {
          values[i] = x;
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            if (err) {
              return o.onError(err);
            }
            var res = tryCatch(resultSelector).apply(null, values);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            o.onNext(res);
          }
          isDone && values[1] && o.onCompleted();
        }
        return new CompositeDisposable(source.subscribe(function(x) {
          next(x, 0);
        }, function(e) {
          if (values[1]) {
            o.onError(e);
          } else {
            err = e;
          }
        }, function() {
          isDone = true;
          values[1] && o.onCompleted();
        }), subject.subscribe(function(x) {
          next(x, 1);
        }, function(e) {
          o.onError(e);
        }, function() {
          isDone = true;
          next(true, 1);
        }));
      }, source);
    }
    var PausableBufferedObservable = (function(__super__) {
      inherits(PausableBufferedObservable, __super__);
      function subscribe(o) {
        var q = [],
            previousShouldFire;
        function drainQueue() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
        }
        var subscription = combineLatestSource(this.source, this.pauser.distinctUntilChanged().startWith(false), function(data, shouldFire) {
          return {
            data: data,
            shouldFire: shouldFire
          };
        }).subscribe(function(results) {
          if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              drainQueue();
            }
          } else {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              o.onNext(results.data);
            } else {
              q.push(results.data);
            }
          }
        }, function(err) {
          drainQueue();
          o.onError(err);
        }, function() {
          drainQueue();
          o.onCompleted();
        });
        return subscription;
      }
      function PausableBufferedObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableBufferedObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableBufferedObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableBufferedObservable;
    }(Observable));
    observableProto.pausableBuffered = function(subject) {
      return new PausableBufferedObservable(this, subject);
    };
    var ControlledObservable = (function(__super__) {
      inherits(ControlledObservable, __super__);
      function subscribe(observer) {
        return this.source.subscribe(observer);
      }
      function ControlledObservable(source, enableQueue, scheduler) {
        __super__.call(this, subscribe, source);
        this.subject = new ControlledSubject(enableQueue, scheduler);
        this.source = source.multicast(this.subject).refCount();
      }
      ControlledObservable.prototype.request = function(numberOfItems) {
        return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
      };
      return ControlledObservable;
    }(Observable));
    var ControlledSubject = (function(__super__) {
      function subscribe(observer) {
        return this.subject.subscribe(observer);
      }
      inherits(ControlledSubject, __super__);
      function ControlledSubject(enableQueue, scheduler) {
        enableQueue == null && (enableQueue = true);
        __super__.call(this, subscribe);
        this.subject = new Subject();
        this.enableQueue = enableQueue;
        this.queue = enableQueue ? [] : null;
        this.requestedCount = 0;
        this.requestedDisposable = disposableEmpty;
        this.error = null;
        this.hasFailed = false;
        this.hasCompleted = false;
        this.scheduler = scheduler || currentThreadScheduler;
      }
      addProperties(ControlledSubject.prototype, Observer, {
        onCompleted: function() {
          this.hasCompleted = true;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onCompleted();
          } else {
            this.queue.push(Notification.createOnCompleted());
          }
        },
        onError: function(error) {
          this.hasFailed = true;
          this.error = error;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onError(error);
          } else {
            this.queue.push(Notification.createOnError(error));
          }
        },
        onNext: function(value) {
          var hasRequested = false;
          if (this.requestedCount === 0) {
            this.enableQueue && this.queue.push(Notification.createOnNext(value));
          } else {
            (this.requestedCount !== -1 && this.requestedCount-- === 0) && this.disposeCurrentRequest();
            hasRequested = true;
          }
          hasRequested && this.subject.onNext(value);
        },
        _processRequest: function(numberOfItems) {
          if (this.enableQueue) {
            while ((this.queue.length >= numberOfItems && numberOfItems > 0) || (this.queue.length > 0 && this.queue[0].kind !== 'N')) {
              var first = this.queue.shift();
              first.accept(this.subject);
              if (first.kind === 'N') {
                numberOfItems--;
              } else {
                this.disposeCurrentRequest();
                this.queue = [];
              }
            }
            return {
              numberOfItems: numberOfItems,
              returnValue: this.queue.length !== 0
            };
          }
          return {
            numberOfItems: numberOfItems,
            returnValue: false
          };
        },
        request: function(number) {
          this.disposeCurrentRequest();
          var self = this;
          this.requestedDisposable = this.scheduler.scheduleWithState(number, function(s, i) {
            var r = self._processRequest(i),
                remaining = r.numberOfItems;
            if (!r.returnValue) {
              self.requestedCount = remaining;
              self.requestedDisposable = disposableCreate(function() {
                self.requestedCount = 0;
              });
            }
          });
          return this.requestedDisposable;
        },
        disposeCurrentRequest: function() {
          this.requestedDisposable.dispose();
          this.requestedDisposable = disposableEmpty;
        }
      });
      return ControlledSubject;
    }(Observable));
    observableProto.controlled = function(enableQueue, scheduler) {
      if (enableQueue && isScheduler(enableQueue)) {
        scheduler = enableQueue;
        enableQueue = true;
      }
      if (enableQueue == null) {
        enableQueue = true;
      }
      return new ControlledObservable(this, enableQueue, scheduler);
    };
    var StopAndWaitObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(1);
        });
        return this.subscription;
      }
      inherits(StopAndWaitObservable, __super__);
      function StopAndWaitObservable(source) {
        __super__.call(this, subscribe, source);
        this.source = source;
      }
      var StopAndWaitObserver = (function(__sub__) {
        inherits(StopAndWaitObserver, __sub__);
        function StopAndWaitObserver(observer, observable, cancel) {
          __sub__.call(this);
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
        }
        var stopAndWaitObserverProto = StopAndWaitObserver.prototype;
        stopAndWaitObserverProto.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        stopAndWaitObserverProto.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        stopAndWaitObserverProto.next = function(value) {
          this.observer.onNext(value);
          var self = this;
          timeoutScheduler.schedule(function() {
            self.observable.source.request(1);
          });
        };
        stopAndWaitObserverProto.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return StopAndWaitObserver;
      }(AbstractObserver));
      return StopAndWaitObservable;
    }(Observable));
    ControlledObservable.prototype.stopAndWait = function() {
      return new StopAndWaitObservable(this);
    };
    var WindowedObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new WindowedObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(self.windowSize);
        });
        return this.subscription;
      }
      inherits(WindowedObservable, __super__);
      function WindowedObservable(source, windowSize) {
        __super__.call(this, subscribe, source);
        this.source = source;
        this.windowSize = windowSize;
      }
      var WindowedObserver = (function(__sub__) {
        inherits(WindowedObserver, __sub__);
        function WindowedObserver(observer, observable, cancel) {
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
          this.received = 0;
        }
        var windowedObserverPrototype = WindowedObserver.prototype;
        windowedObserverPrototype.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        windowedObserverPrototype.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        windowedObserverPrototype.next = function(value) {
          this.observer.onNext(value);
          this.received = ++this.received % this.observable.windowSize;
          if (this.received === 0) {
            var self = this;
            timeoutScheduler.schedule(function() {
              self.observable.source.request(self.observable.windowSize);
            });
          }
        };
        windowedObserverPrototype.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return WindowedObserver;
      }(AbstractObserver));
      return WindowedObservable;
    }(Observable));
    ControlledObservable.prototype.windowed = function(windowSize) {
      return new WindowedObservable(this, windowSize);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.binding", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        Subject = Rx.Subject,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        ScheduledObserver = Rx.internals.ScheduledObserver,
        disposableCreate = Rx.Disposable.create,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        isFunction = Rx.helpers.isFunction,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        checkDisposed = Rx.Disposable.checkDisposed;
    function cloneArray(arr) {
      var len = arr.length,
          a = new Array(len);
      for (var i = 0; i < len; i++) {
        a[i] = arr[i];
      }
      return a;
    }
    observableProto.multicast = function(subjectOrSubjectSelector, selector) {
      var source = this;
      return typeof subjectOrSubjectSelector === 'function' ? new AnonymousObservable(function(observer) {
        var connectable = source.multicast(subjectOrSubjectSelector());
        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
      }, source) : new ConnectableObservable(source, subjectOrSubjectSelector);
    };
    observableProto.publish = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new Subject();
      }, selector) : this.multicast(new Subject());
    };
    observableProto.share = function() {
      return this.publish().refCount();
    };
    observableProto.publishLast = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new AsyncSubject();
      }, selector) : this.multicast(new AsyncSubject());
    };
    observableProto.publishValue = function(initialValueOrSelector, initialValue) {
      return arguments.length === 2 ? this.multicast(function() {
        return new BehaviorSubject(initialValue);
      }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
    };
    observableProto.shareValue = function(initialValue) {
      return this.publishValue(initialValue).refCount();
    };
    observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new ReplaySubject(bufferSize, windowSize, scheduler);
      }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
    };
    observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {
      return this.replay(null, bufferSize, windowSize, scheduler).refCount();
    };
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var BehaviorSubject = Rx.BehaviorSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          observer.onNext(this.value);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(BehaviorSubject, __super__);
      function BehaviorSubject(value) {
        __super__.call(this, subscribe);
        this.value = value, this.observers = [], this.isDisposed = false, this.isStopped = false, this.hasError = false;
      }
      addProperties(BehaviorSubject.prototype, Observer, {
        getValue: function() {
          checkDisposed(this);
          if (this.hasError) {
            throw this.error;
          }
          return this.value;
        },
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onCompleted();
          }
          this.observers.length = 0;
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.hasError = true;
          this.error = error;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onError(error);
          }
          this.observers.length = 0;
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.value = value;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.value = null;
          this.exception = null;
        }
      });
      return BehaviorSubject;
    }(Observable));
    var ReplaySubject = Rx.ReplaySubject = (function(__super__) {
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function createRemovableDisposable(subject, observer) {
        return disposableCreate(function() {
          observer.dispose();
          !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
        });
      }
      function subscribe(observer) {
        var so = new ScheduledObserver(this.scheduler, observer),
            subscription = createRemovableDisposable(this, so);
        checkDisposed(this);
        this._trim(this.scheduler.now());
        this.observers.push(so);
        for (var i = 0,
            len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }
        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }
        so.ensureActive();
        return subscription;
      }
      inherits(ReplaySubject, __super__);
      function ReplaySubject(bufferSize, windowSize, scheduler) {
        this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
        this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
        this.scheduler = scheduler || currentThreadScheduler;
        this.q = [];
        this.observers = [];
        this.isStopped = false;
        this.isDisposed = false;
        this.hasError = false;
        this.error = null;
        __super__.call(this, subscribe);
      }
      addProperties(ReplaySubject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        _trim: function(now) {
          while (this.q.length > this.bufferSize) {
            this.q.shift();
          }
          while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
            this.q.shift();
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          var now = this.scheduler.now();
          this.q.push({
            interval: now,
            value: value
          });
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onNext(value);
            observer.ensureActive();
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onError(error);
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onCompleted();
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      return ReplaySubject;
    }(Observable));
    var ConnectableObservable = Rx.ConnectableObservable = (function(__super__) {
      inherits(ConnectableObservable, __super__);
      function ConnectableObservable(source, subject) {
        var hasSubscription = false,
            subscription,
            sourceObservable = source.asObservable();
        this.connect = function() {
          if (!hasSubscription) {
            hasSubscription = true;
            subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function() {
              hasSubscription = false;
            }));
          }
          return subscription;
        };
        __super__.call(this, function(o) {
          return subject.subscribe(o);
        });
      }
      ConnectableObservable.prototype.refCount = function() {
        var connectableSubscription,
            count = 0,
            source = this;
        return new AnonymousObservable(function(observer) {
          var shouldConnect = ++count === 1,
              subscription = source.subscribe(observer);
          shouldConnect && (connectableSubscription = source.connect());
          return function() {
            subscription.dispose();
            --count === 0 && connectableSubscription.dispose();
          };
        });
      };
      return ConnectableObservable;
    }(Observable));
    observableProto.singleInstance = function() {
      var source = this,
          hasObservable = false,
          observable;
      function getObservable() {
        if (!hasObservable) {
          hasObservable = true;
          observable = source.finally(function() {
            hasObservable = false;
          }).publish().refCount();
        }
        return observable;
      }
      ;
      return new AnonymousObservable(function(o) {
        return getObservable().subscribe(o);
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.coincidence", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        Subject = Rx.Subject,
        observableProto = Observable.prototype,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        AnonymousObservable = Rx.AnonymousObservable,
        observerCreate = Rx.Observer.create,
        addRef = Rx.internals.addRef,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        noop = Rx.helpers.noop,
        identity = Rx.helpers.identity,
        isPromise = Rx.helpers.isPromise,
        observableFromPromise = Observable.fromPromise,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var Dictionary = (function() {
      var primes = [1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647],
          noSuchkey = "no such key",
          duplicatekey = "duplicate key";
      function isPrime(candidate) {
        if ((candidate & 1) === 0) {
          return candidate === 2;
        }
        var num1 = Math.sqrt(candidate),
            num2 = 3;
        while (num2 <= num1) {
          if (candidate % num2 === 0) {
            return false;
          }
          num2 += 2;
        }
        return true;
      }
      function getPrime(min) {
        var index,
            num,
            candidate;
        for (index = 0; index < primes.length; ++index) {
          num = primes[index];
          if (num >= min) {
            return num;
          }
        }
        candidate = min | 1;
        while (candidate < primes[primes.length - 1]) {
          if (isPrime(candidate)) {
            return candidate;
          }
          candidate += 2;
        }
        return min;
      }
      function stringHashFn(str) {
        var hash = 757602046;
        if (!str.length) {
          return hash;
        }
        for (var i = 0,
            len = str.length; i < len; i++) {
          var character = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + character;
          hash = hash & hash;
        }
        return hash;
      }
      function numberHashFn(key) {
        var c2 = 0x27d4eb2d;
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
      }
      var getHashCode = (function() {
        var uniqueIdCounter = 0;
        return function(obj) {
          if (obj == null) {
            throw new Error(noSuchkey);
          }
          if (typeof obj === 'string') {
            return stringHashFn(obj);
          }
          if (typeof obj === 'number') {
            return numberHashFn(obj);
          }
          if (typeof obj === 'boolean') {
            return obj === true ? 1 : 0;
          }
          if (obj instanceof Date) {
            return numberHashFn(obj.valueOf());
          }
          if (obj instanceof RegExp) {
            return stringHashFn(obj.toString());
          }
          if (typeof obj.valueOf === 'function') {
            var valueOf = obj.valueOf();
            if (typeof valueOf === 'number') {
              return numberHashFn(valueOf);
            }
            if (typeof valueOf === 'string') {
              return stringHashFn(valueOf);
            }
          }
          if (obj.hashCode) {
            return obj.hashCode();
          }
          var id = 17 * uniqueIdCounter++;
          obj.hashCode = function() {
            return id;
          };
          return id;
        };
      }());
      function newEntry() {
        return {
          key: null,
          value: null,
          next: 0,
          hashCode: 0
        };
      }
      function Dictionary(capacity, comparer) {
        if (capacity < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (capacity > 0) {
          this._initialize(capacity);
        }
        this.comparer = comparer || defaultComparer;
        this.freeCount = 0;
        this.size = 0;
        this.freeList = -1;
      }
      var dictionaryProto = Dictionary.prototype;
      dictionaryProto._initialize = function(capacity) {
        var prime = getPrime(capacity),
            i;
        this.buckets = new Array(prime);
        this.entries = new Array(prime);
        for (i = 0; i < prime; i++) {
          this.buckets[i] = -1;
          this.entries[i] = newEntry();
        }
        this.freeList = -1;
      };
      dictionaryProto.add = function(key, value) {
        this._insert(key, value, true);
      };
      dictionaryProto._insert = function(key, value, add) {
        if (!this.buckets) {
          this._initialize(0);
        }
        var index3,
            num = getHashCode(key) & 2147483647,
            index1 = num % this.buckets.length;
        for (var index2 = this.buckets[index1]; index2 >= 0; index2 = this.entries[index2].next) {
          if (this.entries[index2].hashCode === num && this.comparer(this.entries[index2].key, key)) {
            if (add) {
              throw new Error(duplicatekey);
            }
            this.entries[index2].value = value;
            return ;
          }
        }
        if (this.freeCount > 0) {
          index3 = this.freeList;
          this.freeList = this.entries[index3].next;
          --this.freeCount;
        } else {
          if (this.size === this.entries.length) {
            this._resize();
            index1 = num % this.buckets.length;
          }
          index3 = this.size;
          ++this.size;
        }
        this.entries[index3].hashCode = num;
        this.entries[index3].next = this.buckets[index1];
        this.entries[index3].key = key;
        this.entries[index3].value = value;
        this.buckets[index1] = index3;
      };
      dictionaryProto._resize = function() {
        var prime = getPrime(this.size * 2),
            numArray = new Array(prime);
        for (index = 0; index < numArray.length; ++index) {
          numArray[index] = -1;
        }
        var entryArray = new Array(prime);
        for (index = 0; index < this.size; ++index) {
          entryArray[index] = this.entries[index];
        }
        for (var index = this.size; index < prime; ++index) {
          entryArray[index] = newEntry();
        }
        for (var index1 = 0; index1 < this.size; ++index1) {
          var index2 = entryArray[index1].hashCode % prime;
          entryArray[index1].next = numArray[index2];
          numArray[index2] = index1;
        }
        this.buckets = numArray;
        this.entries = entryArray;
      };
      dictionaryProto.remove = function(key) {
        if (this.buckets) {
          var num = getHashCode(key) & 2147483647,
              index1 = num % this.buckets.length,
              index2 = -1;
          for (var index3 = this.buckets[index1]; index3 >= 0; index3 = this.entries[index3].next) {
            if (this.entries[index3].hashCode === num && this.comparer(this.entries[index3].key, key)) {
              if (index2 < 0) {
                this.buckets[index1] = this.entries[index3].next;
              } else {
                this.entries[index2].next = this.entries[index3].next;
              }
              this.entries[index3].hashCode = -1;
              this.entries[index3].next = this.freeList;
              this.entries[index3].key = null;
              this.entries[index3].value = null;
              this.freeList = index3;
              ++this.freeCount;
              return true;
            } else {
              index2 = index3;
            }
          }
        }
        return false;
      };
      dictionaryProto.clear = function() {
        var index,
            len;
        if (this.size <= 0) {
          return ;
        }
        for (index = 0, len = this.buckets.length; index < len; ++index) {
          this.buckets[index] = -1;
        }
        for (index = 0; index < this.size; ++index) {
          this.entries[index] = newEntry();
        }
        this.freeList = -1;
        this.size = 0;
      };
      dictionaryProto._findEntry = function(key) {
        if (this.buckets) {
          var num = getHashCode(key) & 2147483647;
          for (var index = this.buckets[num % this.buckets.length]; index >= 0; index = this.entries[index].next) {
            if (this.entries[index].hashCode === num && this.comparer(this.entries[index].key, key)) {
              return index;
            }
          }
        }
        return -1;
      };
      dictionaryProto.count = function() {
        return this.size - this.freeCount;
      };
      dictionaryProto.tryGetValue = function(key) {
        var entry = this._findEntry(key);
        return entry >= 0 ? this.entries[entry].value : undefined;
      };
      dictionaryProto.getValues = function() {
        var index = 0,
            results = [];
        if (this.entries) {
          for (var index1 = 0; index1 < this.size; index1++) {
            if (this.entries[index1].hashCode >= 0) {
              results[index++] = this.entries[index1].value;
            }
          }
        }
        return results;
      };
      dictionaryProto.get = function(key) {
        var entry = this._findEntry(key);
        if (entry >= 0) {
          return this.entries[entry].value;
        }
        throw new Error(noSuchkey);
      };
      dictionaryProto.set = function(key, value) {
        this._insert(key, value, false);
      };
      dictionaryProto.containskey = function(key) {
        return this._findEntry(key) >= 0;
      };
      return Dictionary;
    }());
    observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(observer) {
        var group = new CompositeDisposable();
        var leftDone = false,
            rightDone = false;
        var leftId = 0,
            rightId = 0;
        var leftMap = new Dictionary(),
            rightMap = new Dictionary();
        group.add(left.subscribe(function(value) {
          var id = leftId++;
          var md = new SingleAssignmentDisposable();
          leftMap.add(id, value);
          group.add(md);
          var expire = function() {
            leftMap.remove(id) && leftMap.count() === 0 && leftDone && observer.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = leftDurationSelector(value);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
          rightMap.getValues().forEach(function(v) {
            var result;
            try {
              result = resultSelector(value, v);
            } catch (exn) {
              observer.onError(exn);
              return ;
            }
            observer.onNext(result);
          });
        }, observer.onError.bind(observer), function() {
          leftDone = true;
          (rightDone || leftMap.count() === 0) && observer.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          var md = new SingleAssignmentDisposable();
          rightMap.add(id, value);
          group.add(md);
          var expire = function() {
            rightMap.remove(id) && rightMap.count() === 0 && rightDone && observer.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = rightDurationSelector(value);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
          leftMap.getValues().forEach(function(v) {
            var result;
            try {
              result = resultSelector(v, value);
            } catch (exn) {
              observer.onError(exn);
              return ;
            }
            observer.onNext(result);
          });
        }, observer.onError.bind(observer), function() {
          rightDone = true;
          (leftDone || rightMap.count() === 0) && observer.onCompleted();
        }));
        return group;
      }, left);
    };
    observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(observer) {
        var group = new CompositeDisposable();
        var r = new RefCountDisposable(group);
        var leftMap = new Dictionary(),
            rightMap = new Dictionary();
        var leftId = 0,
            rightId = 0;
        function handleError(e) {
          return function(v) {
            v.onError(e);
          };
        }
        ;
        group.add(left.subscribe(function(value) {
          var s = new Subject();
          var id = leftId++;
          leftMap.add(id, s);
          var result;
          try {
            result = resultSelector(value, addRef(s, r));
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          observer.onNext(result);
          rightMap.getValues().forEach(function(v) {
            s.onNext(v);
          });
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var expire = function() {
            leftMap.remove(id) && s.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = leftDurationSelector(value);
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
          }, expire));
        }, function(e) {
          leftMap.getValues().forEach(handleError(e));
          observer.onError(e);
        }, observer.onCompleted.bind(observer)));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          rightMap.add(id, value);
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var expire = function() {
            rightMap.remove(id);
            group.remove(md);
          };
          var duration;
          try {
            duration = rightDurationSelector(value);
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
          }, expire));
          leftMap.getValues().forEach(function(v) {
            v.onNext(value);
          });
        }, function(e) {
          leftMap.getValues().forEach(handleError(e));
          observer.onError(e);
        }));
        return r;
      }, left);
    };
    observableProto.buffer = function(bufferOpeningsOrClosingSelector, bufferClosingSelector) {
      return this.window.apply(this, arguments).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
      }
      return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
    };
    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
      return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {
        return win;
      });
    }
    function observableWindowWithBoundaries(windowBoundaries) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var win = new Subject(),
            d = new CompositeDisposable(),
            r = new RefCountDisposable(d);
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
        d.add(windowBoundaries.subscribe(function(w) {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        return r;
      }, source);
    }
    function observableWindowWithClosingSelector(windowClosingSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            r = new RefCountDisposable(d),
            win = new Subject();
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        function createWindowClose() {
          var windowClose;
          try {
            windowClose = windowClosingSelector();
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
          var m1 = new SingleAssignmentDisposable();
          m.setDisposable(m1);
          m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {
            win.onError(err);
            observer.onError(err);
          }, function() {
            win.onCompleted();
            win = new Subject();
            observer.onNext(addRef(win, r));
            createWindowClose();
          }));
        }
        createWindowClose();
        return r;
      }, source);
    }
    observableProto.pairwise = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var previous,
            hasPrevious = false;
        return source.subscribe(function(x) {
          if (hasPrevious) {
            observer.onNext([previous, x]);
          } else {
            hasPrevious = true;
          }
          previous = x;
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
      }, source);
    };
    observableProto.partition = function(predicate, thisArg) {
      return [this.filter(predicate, thisArg), this.filter(function(x, i, o) {
        return !predicate.call(thisArg, x, i, o);
      })];
    };
    observableProto.groupBy = function(keySelector, elementSelector, comparer) {
      return this.groupByUntil(keySelector, elementSelector, observableNever, comparer);
    };
    observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector, comparer) {
      var source = this;
      elementSelector || (elementSelector = identity);
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(observer) {
        function handleError(e) {
          return function(item) {
            item.onError(e);
          };
        }
        var map = new Dictionary(0, comparer),
            groupDisposable = new CompositeDisposable(),
            refCountDisposable = new RefCountDisposable(groupDisposable);
        groupDisposable.add(source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          var fireNewMapEntry = false,
              writer = map.tryGetValue(key);
          if (!writer) {
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          }
          if (fireNewMapEntry) {
            var group = new GroupedObservable(key, writer, refCountDisposable),
                durationGroup = new GroupedObservable(key, writer);
            try {
              duration = durationSelector(durationGroup);
            } catch (e) {
              map.getValues().forEach(handleError(e));
              observer.onError(e);
              return ;
            }
            observer.onNext(group);
            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);
            var expire = function() {
              map.remove(key) && writer.onCompleted();
              groupDisposable.remove(md);
            };
            md.setDisposable(duration.take(1).subscribe(noop, function(exn) {
              map.getValues().forEach(handleError(exn));
              observer.onError(exn);
            }, expire));
          }
          var element;
          try {
            element = elementSelector(x);
          } catch (e) {
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          writer.onNext(element);
        }, function(ex) {
          map.getValues().forEach(handleError(ex));
          observer.onError(ex);
        }, function() {
          map.getValues().forEach(function(item) {
            item.onCompleted();
          });
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    var GroupedObservable = (function(__super__) {
      inherits(GroupedObservable, __super__);
      function subscribe(observer) {
        return this.underlyingObservable.subscribe(observer);
      }
      function GroupedObservable(key, underlyingObservable, mergedDisposable) {
        __super__.call(this, subscribe);
        this.key = key;
        this.underlyingObservable = !mergedDisposable ? underlyingObservable : new AnonymousObservable(function(observer) {
          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
        });
      }
      return GroupedObservable;
    }(Observable));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.experimental", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableConcat = Observable.concat,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        SerialDisposable = Rx.SerialDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        Enumerator = Rx.internals.Enumerator,
        Enumerable = Rx.internals.Enumerable,
        enumerableOf = Enumerable.of,
        immediateScheduler = Rx.Scheduler.immediate,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        slice = Array.prototype.slice,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        inherits = Rx.internals.inherits,
        bindCallback = Rx.internals.bindCallback,
        addProperties = Rx.internals.addProperties,
        helpers = Rx.helpers,
        noop = helpers.noop,
        isPromise = helpers.isPromise,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var WhileEnumerable = (function(__super__) {
      inherits(WhileEnumerable, __super__);
      function WhileEnumerable(c, s) {
        this.c = c;
        this.s = s;
      }
      WhileEnumerable.prototype[$iterator$] = function() {
        var self = this;
        return {next: function() {
            return self.c() ? {
              done: false,
              value: self.s
            } : {
              done: true,
              value: void 0
            };
          }};
      };
      return WhileEnumerable;
    }(Enumerable));
    function enumerableWhile(condition, source) {
      return new WhileEnumerable(condition, source);
    }
    observableProto.letBind = observableProto['let'] = function(func) {
      return func(this);
    };
    Observable['if'] = Observable.ifThen = function(condition, thenSource, elseSourceOrScheduler) {
      return observableDefer(function() {
        elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
        isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
        isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
        typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
        return condition() ? thenSource : elseSourceOrScheduler;
      });
    };
    Observable['for'] = Observable.forIn = function(sources, resultSelector, thisArg) {
      return enumerableOf(sources, resultSelector, thisArg).concat();
    };
    var observableWhileDo = Observable['while'] = Observable.whileDo = function(condition, source) {
      isPromise(source) && (source = observableFromPromise(source));
      return enumerableWhile(condition, source).concat();
    };
    observableProto.doWhile = function(condition) {
      return observableConcat([this, observableWhileDo(condition, this)]);
    };
    Observable['case'] = Observable.switchCase = function(selector, sources, defaultSourceOrScheduler) {
      return observableDefer(function() {
        isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
        defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
        typeof defaultSourceOrScheduler.now === 'function' && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
        var result = sources[selector()];
        isPromise(result) && (result = observableFromPromise(result));
        return result || defaultSourceOrScheduler;
      });
    };
    observableProto.expand = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var q = [],
            m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            activeCount = 0,
            isAcquired = false;
        var ensureActive = function() {
          var isOwner = false;
          if (q.length > 0) {
            isOwner = !isAcquired;
            isAcquired = true;
          }
          if (isOwner) {
            m.setDisposable(scheduler.scheduleRecursive(function(self) {
              var work;
              if (q.length > 0) {
                work = q.shift();
              } else {
                isAcquired = false;
                return ;
              }
              var m1 = new SingleAssignmentDisposable();
              d.add(m1);
              m1.setDisposable(work.subscribe(function(x) {
                observer.onNext(x);
                var result = null;
                try {
                  result = selector(x);
                } catch (e) {
                  observer.onError(e);
                }
                q.push(result);
                activeCount++;
                ensureActive();
              }, observer.onError.bind(observer), function() {
                d.remove(m1);
                activeCount--;
                if (activeCount === 0) {
                  observer.onCompleted();
                }
              }));
              self();
            }));
          }
        };
        q.push(source);
        activeCount++;
        ensureActive();
        return d;
      }, this);
    };
    Observable.forkJoin = function() {
      var allSources = [];
      if (Array.isArray(arguments[0])) {
        allSources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          allSources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(subscriber) {
        var count = allSources.length;
        if (count === 0) {
          subscriber.onCompleted();
          return disposableEmpty;
        }
        var group = new CompositeDisposable(),
            finished = false,
            hasResults = new Array(count),
            hasCompleted = new Array(count),
            results = new Array(count);
        for (var idx = 0; idx < count; idx++) {
          (function(i) {
            var source = allSources[i];
            isPromise(source) && (source = observableFromPromise(source));
            group.add(source.subscribe(function(value) {
              if (!finished) {
                hasResults[i] = true;
                results[i] = value;
              }
            }, function(e) {
              finished = true;
              subscriber.onError(e);
              group.dispose();
            }, function() {
              if (!finished) {
                if (!hasResults[i]) {
                  subscriber.onCompleted();
                  return ;
                }
                hasCompleted[i] = true;
                for (var ix = 0; ix < count; ix++) {
                  if (!hasCompleted[ix]) {
                    return ;
                  }
                }
                finished = true;
                subscriber.onNext(results);
                subscriber.onCompleted();
              }
            }));
          })(idx);
        }
        return group;
      });
    };
    observableProto.forkJoin = function(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var leftStopped = false,
            rightStopped = false,
            hasLeft = false,
            hasRight = false,
            lastLeft,
            lastRight,
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(second) && (second = observableFromPromise(second));
        leftSubscription.setDisposable(first.subscribe(function(left) {
          hasLeft = true;
          lastLeft = left;
        }, function(err) {
          rightSubscription.dispose();
          observer.onError(err);
        }, function() {
          leftStopped = true;
          if (rightStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        rightSubscription.setDisposable(second.subscribe(function(right) {
          hasRight = true;
          lastRight = right;
        }, function(err) {
          leftSubscription.dispose();
          observer.onError(err);
        }, function() {
          rightStopped = true;
          if (leftStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      }, first);
    };
    observableProto.manySelect = observableProto.extend = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return observableDefer(function() {
        var chain;
        return source.map(function(x) {
          var curr = new ChainObservable(x);
          chain && chain.onNext(x);
          chain = curr;
          return curr;
        }).tap(noop, function(e) {
          chain && chain.onError(e);
        }, function() {
          chain && chain.onCompleted();
        }).observeOn(scheduler).map(selector);
      }, source);
    };
    var ChainObservable = (function(__super__) {
      function subscribe(observer) {
        var self = this,
            g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(function() {
          observer.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(observer));
        }));
        return g;
      }
      inherits(ChainObservable, __super__);
      function ChainObservable(head) {
        __super__.call(this, subscribe);
        this.head = head;
        this.tail = new AsyncSubject();
      }
      addProperties(ChainObservable.prototype, Observer, {
        onCompleted: function() {
          this.onNext(Observable.empty());
        },
        onError: function(e) {
          this.onNext(Observable.throwError(e));
        },
        onNext: function(v) {
          this.tail.onNext(v);
          this.tail.onCompleted();
        }
      });
      return ChainObservable;
    }(Observable));
    observableProto.exclusive = function() {
      var sources = this;
      return new AnonymousObservable(function(observer) {
        var hasCurrent = false,
            isStopped = false,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            innerSubscription.setDisposable(innerSource.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              if (isStopped && g.length === 1) {
                observer.onCompleted();
              }
            }));
          }
        }, observer.onError.bind(observer), function() {
          isStopped = true;
          if (!hasCurrent && g.length === 1) {
            observer.onCompleted();
          }
        }));
        return g;
      }, this);
    };
    observableProto.exclusiveMap = function(selector, thisArg) {
      var sources = this,
          selectorFunc = bindCallback(selector, thisArg, 3);
      return new AnonymousObservable(function(observer) {
        var index = 0,
            hasCurrent = false,
            isStopped = true,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              var result;
              try {
                result = selectorFunc(x, index++, innerSource);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
            }, function(e) {
              observer.onError(e);
            }, function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              if (isStopped && g.length === 1) {
                observer.onCompleted();
              }
            }));
          }
        }, function(e) {
          observer.onError(e);
        }, function() {
          isStopped = true;
          if (g.length === 1 && !hasCurrent) {
            observer.onCompleted();
          }
        }));
        return g;
      }, this);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.joinpatterns", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableThrow = Observable.throwError,
        observerCreate = Rx.Observer.create,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        AbstractObserver = Rx.internals.AbstractObserver,
        noop = Rx.helpers.noop,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        Enumerable = Rx.internals.Enumerable,
        Enumerator = Rx.internals.Enumerator,
        $iterator$ = Rx.iterator,
        doneEnumerator = Rx.doneEnumerator;
    var Map = root.Map || (function() {
      function Map() {
        this._keys = [];
        this._values = [];
      }
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i !== -1 ? this._values[i] : undefined;
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        i !== -1 && (this._values[i] = value);
        this._values[this._keys.push(key) - 1] = value;
      };
      Map.prototype.forEach = function(callback, thisArg) {
        for (var i = 0,
            len = this._keys.length; i < len; i++) {
          callback.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    function Pattern(patterns) {
      this.patterns = patterns;
    }
    Pattern.prototype.and = function(other) {
      return new Pattern(this.patterns.concat(other));
    };
    Pattern.prototype.thenDo = function(selector) {
      return new Plan(this, selector);
    };
    function Plan(expression, selector) {
      this.expression = expression;
      this.selector = selector;
    }
    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {
      var self = this;
      var joinObservers = [];
      for (var i = 0,
          len = this.expression.patterns.length; i < len; i++) {
        joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
      }
      var activePlan = new ActivePlan(joinObservers, function() {
        var result;
        try {
          result = self.selector.apply(self, arguments);
        } catch (e) {
          observer.onError(e);
          return ;
        }
        observer.onNext(result);
      }, function() {
        for (var j = 0,
            jlen = joinObservers.length; j < jlen; j++) {
          joinObservers[j].removeActivePlan(activePlan);
        }
        deactivate(activePlan);
      });
      for (i = 0, len = joinObservers.length; i < len; i++) {
        joinObservers[i].addActivePlan(activePlan);
      }
      return activePlan;
    };
    function planCreateObserver(externalSubscriptions, observable, onError) {
      var entry = externalSubscriptions.get(observable);
      if (!entry) {
        var observer = new JoinObserver(observable, onError);
        externalSubscriptions.set(observable, observer);
        return observer;
      }
      return entry;
    }
    function ActivePlan(joinObserverArray, onNext, onCompleted) {
      this.joinObserverArray = joinObserverArray;
      this.onNext = onNext;
      this.onCompleted = onCompleted;
      this.joinObservers = new Map();
      for (var i = 0,
          len = this.joinObserverArray.length; i < len; i++) {
        var joinObserver = this.joinObserverArray[i];
        this.joinObservers.set(joinObserver, joinObserver);
      }
    }
    ActivePlan.prototype.dequeue = function() {
      this.joinObservers.forEach(function(v) {
        v.queue.shift();
      });
    };
    ActivePlan.prototype.match = function() {
      var i,
          len,
          hasValues = true;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        if (this.joinObserverArray[i].queue.length === 0) {
          hasValues = false;
          break;
        }
      }
      if (hasValues) {
        var firstValues = [],
            isCompleted = false;
        for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
          firstValues.push(this.joinObserverArray[i].queue[0]);
          this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
        }
        if (isCompleted) {
          this.onCompleted();
        } else {
          this.dequeue();
          var values = [];
          for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
            values.push(firstValues[i].value);
          }
          this.onNext.apply(this, values);
        }
      }
    };
    var JoinObserver = (function(__super__) {
      inherits(JoinObserver, __super__);
      function JoinObserver(source, onError) {
        __super__.call(this);
        this.source = source;
        this.onError = onError;
        this.queue = [];
        this.activePlans = [];
        this.subscription = new SingleAssignmentDisposable();
        this.isDisposed = false;
      }
      var JoinObserverPrototype = JoinObserver.prototype;
      JoinObserverPrototype.next = function(notification) {
        if (!this.isDisposed) {
          if (notification.kind === 'E') {
            return this.onError(notification.exception);
          }
          this.queue.push(notification);
          var activePlans = this.activePlans.slice(0);
          for (var i = 0,
              len = activePlans.length; i < len; i++) {
            activePlans[i].match();
          }
        }
      };
      JoinObserverPrototype.error = noop;
      JoinObserverPrototype.completed = noop;
      JoinObserverPrototype.addActivePlan = function(activePlan) {
        this.activePlans.push(activePlan);
      };
      JoinObserverPrototype.subscribe = function() {
        this.subscription.setDisposable(this.source.materialize().subscribe(this));
      };
      JoinObserverPrototype.removeActivePlan = function(activePlan) {
        this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
        this.activePlans.length === 0 && this.dispose();
      };
      JoinObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        if (!this.isDisposed) {
          this.isDisposed = true;
          this.subscription.dispose();
        }
      };
      return JoinObserver;
    }(AbstractObserver));
    observableProto.and = function(right) {
      return new Pattern([this, right]);
    };
    observableProto.thenDo = function(selector) {
      return new Pattern([this]).thenDo(selector);
    };
    Observable.when = function() {
      var len = arguments.length,
          plans;
      if (Array.isArray(arguments[0])) {
        plans = arguments[0];
      } else {
        plans = new Array(len);
        for (var i = 0; i < len; i++) {
          plans[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(o) {
        var activePlans = [],
            externalSubscriptions = new Map();
        var outObserver = observerCreate(function(x) {
          o.onNext(x);
        }, function(err) {
          externalSubscriptions.forEach(function(v) {
            v.onError(err);
          });
          o.onError(err);
        }, function(x) {
          o.onCompleted();
        });
        try {
          for (var i = 0,
              len = plans.length; i < len; i++) {
            activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {
              var idx = activePlans.indexOf(activePlan);
              activePlans.splice(idx, 1);
              activePlans.length === 0 && o.onCompleted();
            }));
          }
        } catch (e) {
          observableThrow(e).subscribe(o);
        }
        var group = new CompositeDisposable();
        externalSubscriptions.forEach(function(joinObserver) {
          joinObserver.subscribe();
          group.add(joinObserver);
        });
        return group;
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.sorting", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableNever = Observable.never,
        isEqual = Rx.internals.isEqual,
        defaultSubComparer = Rx.helpers.defaultSubComparer;
    observableProto.jortSort = function() {
      return this.jortSortUntil(observableNever());
    };
    observableProto.jortSortUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var arr = [];
        return source.takeUntil(other).subscribe(arr.push.bind(arr), observer.onError.bind(observer), function() {
          var sorted = arr.slice(0).sort(defaultSubComparer);
          observer.onNext(isEqual(arr, sorted));
          observer.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.virtualtime", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Scheduler = Rx.Scheduler,
        PriorityQueue = Rx.internals.PriorityQueue,
        ScheduledItem = Rx.internals.ScheduledItem,
        SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive,
        disposableEmpty = Rx.Disposable.empty,
        inherits = Rx.internals.inherits,
        defaultSubComparer = Rx.helpers.defaultSubComparer,
        notImplemented = Rx.helpers.notImplemented;
    Rx.VirtualTimeScheduler = (function(__super__) {
      function localNow() {
        return this.toDateTimeOffset(this.clock);
      }
      function scheduleNow(state, action) {
        return this.scheduleAbsoluteWithState(state, this.clock, action);
      }
      function scheduleRelative(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      inherits(VirtualTimeScheduler, __super__);
      function VirtualTimeScheduler(initialClock, comparer) {
        this.clock = initialClock;
        this.comparer = comparer;
        this.isEnabled = false;
        this.queue = new PriorityQueue(1024);
        __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
      VirtualTimeSchedulerPrototype.add = notImplemented;
      VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
      VirtualTimeSchedulerPrototype.toRelative = notImplemented;
      VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function(state, period, action) {
        var s = new SchedulePeriodicRecursive(this, state, period, action);
        return s.start();
      };
      VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function(state, dueTime, action) {
        var runAt = this.add(this.clock, dueTime);
        return this.scheduleAbsoluteWithState(state, runAt, action);
      };
      VirtualTimeSchedulerPrototype.scheduleRelative = function(dueTime, action) {
        return this.scheduleRelativeWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.start = function() {
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
        }
      };
      VirtualTimeSchedulerPrototype.stop = function() {
        this.isEnabled = false;
      };
      VirtualTimeSchedulerPrototype.advanceTo = function(time) {
        var dueToClock = this.comparer(this.clock, time);
        if (this.comparer(this.clock, time) > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null && this.comparer(next.dueTime, time) <= 0) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
          this.clock = time;
        }
      };
      VirtualTimeSchedulerPrototype.advanceBy = function(time) {
        var dt = this.add(this.clock, time),
            dueToClock = this.comparer(this.clock, dt);
        if (dueToClock > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        this.advanceTo(dt);
      };
      VirtualTimeSchedulerPrototype.sleep = function(time) {
        var dt = this.add(this.clock, time);
        if (this.comparer(this.clock, dt) >= 0) {
          throw new ArgumentOutOfRangeError();
        }
        this.clock = dt;
      };
      VirtualTimeSchedulerPrototype.getNext = function() {
        while (this.queue.length > 0) {
          var next = this.queue.peek();
          if (next.isCancelled()) {
            this.queue.dequeue();
          } else {
            return next;
          }
        }
        return null;
      };
      VirtualTimeSchedulerPrototype.scheduleAbsolute = function(dueTime, action) {
        return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        var self = this;
        function run(scheduler, state1) {
          self.queue.remove(si);
          return action(scheduler, state1);
        }
        var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
        this.queue.enqueue(si);
        return si.disposable;
      };
      return VirtualTimeScheduler;
    }(Scheduler));
    Rx.HistoricalScheduler = (function(__super__) {
      inherits(HistoricalScheduler, __super__);
      function HistoricalScheduler(initialClock, comparer) {
        var clock = initialClock == null ? 0 : initialClock;
        var cmp = comparer || defaultSubComparer;
        __super__.call(this, clock, cmp);
      }
      var HistoricalSchedulerProto = HistoricalScheduler.prototype;
      HistoricalSchedulerProto.add = function(absolute, relative) {
        return absolute + relative;
      };
      HistoricalSchedulerProto.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      HistoricalSchedulerProto.toRelative = function(timeSpan) {
        return timeSpan;
      };
      return HistoricalScheduler;
    }(Rx.VirtualTimeScheduler));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.testing", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx.virtualtime", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observer = Rx.Observer,
        Observable = Rx.Observable,
        Notification = Rx.Notification,
        VirtualTimeScheduler = Rx.VirtualTimeScheduler,
        Disposable = Rx.Disposable,
        disposableEmpty = Disposable.empty,
        disposableCreate = Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        inherits = Rx.internals.inherits,
        defaultComparer = Rx.internals.isEqual;
    function OnNextPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnNextPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'N') {
        return false;
      }
      return this.predicate(other.value);
    };
    function OnErrorPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnErrorPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'E') {
        return false;
      }
      return this.predicate(other.exception);
    };
    var ReactiveTest = Rx.ReactiveTest = {
      created: 100,
      subscribed: 200,
      disposed: 1000,
      onNext: function(ticks, value) {
        return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
      },
      onError: function(ticks, error) {
        return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
      },
      onCompleted: function(ticks) {
        return new Recorded(ticks, Notification.createOnCompleted());
      },
      subscribe: function(start, end) {
        return new Subscription(start, end);
      }
    };
    var Recorded = Rx.Recorded = function(time, value, comparer) {
      this.time = time;
      this.value = value;
      this.comparer = comparer || defaultComparer;
    };
    Recorded.prototype.equals = function(other) {
      return this.time === other.time && this.comparer(this.value, other.value);
    };
    Recorded.prototype.toString = function() {
      return this.value.toString() + '@' + this.time;
    };
    var Subscription = Rx.Subscription = function(start, end) {
      this.subscribe = start;
      this.unsubscribe = end || Number.MAX_VALUE;
    };
    Subscription.prototype.equals = function(other) {
      return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
    };
    Subscription.prototype.toString = function() {
      return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
    };
    var MockDisposable = Rx.MockDisposable = function(scheduler) {
      this.scheduler = scheduler;
      this.disposes = [];
      this.disposes.push(this.scheduler.clock);
    };
    MockDisposable.prototype.dispose = function() {
      this.disposes.push(this.scheduler.clock);
    };
    var MockObserver = (function(__super__) {
      inherits(MockObserver, __super__);
      function MockObserver(scheduler) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.messages = [];
      }
      var MockObserverPrototype = MockObserver.prototype;
      MockObserverPrototype.onNext = function(value) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
      };
      MockObserverPrototype.onError = function(exception) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(exception)));
      };
      MockObserverPrototype.onCompleted = function() {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
      };
      return MockObserver;
    })(Observer);
    function MockPromise(scheduler, messages) {
      var self = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0,
          len = this.messages.length; i < len; i++) {
        var message = this.messages[i],
            notification = message.value;
        (function(innerNotification) {
          scheduler.scheduleAbsoluteWithState(null, message.time, function() {
            var obs = self.observers.slice(0);
            for (var j = 0,
                jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }
    MockPromise.prototype.then = function(onResolved, onRejected) {
      var self = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var newPromise;
      var observer = Rx.Observer.create(function(x) {
        var retValue = onResolved(x);
        if (retValue && typeof retValue.then === 'function') {
          newPromise = retValue;
        } else {
          var ticks = self.scheduler.clock;
          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
        }
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      }, function(err) {
        onRejected(err);
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      });
      this.observers.push(observer);
      return newPromise || new MockPromise(this.scheduler, this.messages);
    };
    var HotObservable = (function(__super__) {
      function subscribe(observer) {
        var observable = this;
        this.observers.push(observer);
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        return disposableCreate(function() {
          var idx = observable.observers.indexOf(observer);
          observable.observers.splice(idx, 1);
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        });
      }
      inherits(HotObservable, __super__);
      function HotObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        var message,
            notification,
            observable = this;
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
        this.observers = [];
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            scheduler.scheduleAbsoluteWithState(null, message.time, function() {
              var obs = observable.observers.slice(0);
              for (var j = 0,
                  jLen = obs.length; j < jLen; j++) {
                innerNotification.accept(obs[j]);
              }
              return disposableEmpty;
            });
          })(notification);
        }
      }
      return HotObservable;
    })(Observable);
    var ColdObservable = (function(__super__) {
      function subscribe(observer) {
        var message,
            notification,
            observable = this;
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        var d = new CompositeDisposable();
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            d.add(observable.scheduler.scheduleRelativeWithState(null, message.time, function() {
              innerNotification.accept(observer);
              return disposableEmpty;
            }));
          })(notification);
        }
        return disposableCreate(function() {
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
          d.dispose();
        });
      }
      inherits(ColdObservable, __super__);
      function ColdObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
      }
      return ColdObservable;
    })(Observable);
    Rx.TestScheduler = (function(__super__) {
      inherits(TestScheduler, __super__);
      function baseComparer(x, y) {
        return x > y ? 1 : (x < y ? -1 : 0);
      }
      function TestScheduler() {
        __super__.call(this, 0, baseComparer);
      }
      TestScheduler.prototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        dueTime <= this.clock && (dueTime = this.clock + 1);
        return __super__.prototype.scheduleAbsoluteWithState.call(this, state, dueTime, action);
      };
      TestScheduler.prototype.add = function(absolute, relative) {
        return absolute + relative;
      };
      TestScheduler.prototype.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      TestScheduler.prototype.toRelative = function(timeSpan) {
        return timeSpan;
      };
      TestScheduler.prototype.startWithTiming = function(create, created, subscribed, disposed) {
        var observer = this.createObserver(),
            source,
            subscription;
        this.scheduleAbsoluteWithState(null, created, function() {
          source = create();
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, subscribed, function() {
          subscription = source.subscribe(observer);
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, disposed, function() {
          subscription.dispose();
          return disposableEmpty;
        });
        this.start();
        return observer;
      };
      TestScheduler.prototype.startWithDispose = function(create, disposed) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, disposed);
      };
      TestScheduler.prototype.startWithCreate = function(create) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, ReactiveTest.disposed);
      };
      TestScheduler.prototype.createHotObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new HotObservable(this, args);
      };
      TestScheduler.prototype.createColdObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ColdObservable(this, args);
      };
      TestScheduler.prototype.createResolvedPromise = function(ticks, value) {
        return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
      };
      TestScheduler.prototype.createRejectedPromise = function(ticks, reason) {
        return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
      };
      TestScheduler.prototype.createObserver = function() {
        return new MockObserver(this);
      };
      return TestScheduler;
    })(VirtualTimeScheduler);
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.time", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        observableThrow = Observable.throwException,
        observableFromArray = Observable.fromArray,
        timeoutScheduler = Rx.Scheduler['default'],
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        Subject = Rx.Subject,
        addRef = Rx.internals.addRef,
        normalizeTime = Rx.Scheduler.normalize,
        helpers = Rx.helpers,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function observableTimerDate(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithAbsolute(dueTime, function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
      return new AnonymousObservable(function(observer) {
        var d = dueTime,
            p = normalizeTime(period);
        return scheduler.scheduleRecursiveWithAbsoluteAndState(0, d, function(count, self) {
          if (p > 0) {
            var now = scheduler.now();
            d = d + p;
            d <= now && (d = now + p);
          }
          observer.onNext(count);
          self(count + 1, d);
        });
      });
    }
    function observableTimerTimeSpan(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithRelative(normalizeTime(dueTime), function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
      return dueTime === period ? new AnonymousObservable(function(observer) {
        return scheduler.schedulePeriodicWithState(0, period, function(count) {
          observer.onNext(count);
          return count + 1;
        });
      }) : observableDefer(function() {
        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
      });
    }
    var observableinterval = Observable.interval = function(period, scheduler) {
      return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
    };
    var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {
      var period;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (periodOrScheduler !== undefined && typeof periodOrScheduler === 'number') {
        period = periodOrScheduler;
      } else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }
      if (dueTime instanceof Date && period === undefined) {
        return observableTimerDate(dueTime.getTime(), scheduler);
      }
      if (dueTime instanceof Date && period !== undefined) {
        period = periodOrScheduler;
        return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler);
      }
      return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
    };
    function observableDelayTimeSpan(source, dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        var active = false,
            cancelable = new SerialDisposable(),
            exception = null,
            q = [],
            running = false,
            subscription;
        subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {
          var d,
              shouldRun;
          if (notification.value.kind === 'E') {
            q = [];
            q.push(notification);
            exception = notification.value.exception;
            shouldRun = !running;
          } else {
            q.push({
              value: notification.value,
              timestamp: notification.timestamp + dueTime
            });
            shouldRun = !active;
            active = true;
          }
          if (shouldRun) {
            if (exception !== null) {
              observer.onError(exception);
            } else {
              d = new SingleAssignmentDisposable();
              cancelable.setDisposable(d);
              d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function(self) {
                var e,
                    recurseDueTime,
                    result,
                    shouldRecurse;
                if (exception !== null) {
                  return ;
                }
                running = true;
                do {
                  result = null;
                  if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                    result = q.shift().value;
                  }
                  if (result !== null) {
                    result.accept(observer);
                  }
                } while (result !== null);
                shouldRecurse = false;
                recurseDueTime = 0;
                if (q.length > 0) {
                  shouldRecurse = true;
                  recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
                } else {
                  active = false;
                }
                e = exception;
                running = false;
                if (e !== null) {
                  observer.onError(e);
                } else if (shouldRecurse) {
                  self(recurseDueTime);
                }
              }));
            }
          }
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    }
    function observableDelayDate(source, dueTime, scheduler) {
      return observableDefer(function() {
        return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
      });
    }
    observableProto.delay = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return dueTime instanceof Date ? observableDelayDate(this, dueTime.getTime(), scheduler) : observableDelayTimeSpan(this, dueTime, scheduler);
    };
    observableProto.debounce = observableProto.throttleWithTimeout = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var cancelable = new SerialDisposable(),
            hasvalue = false,
            value,
            id = 0;
        var subscription = source.subscribe(function(x) {
          hasvalue = true;
          value = x;
          id++;
          var currentId = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function() {
            hasvalue && id === currentId && observer.onNext(value);
            hasvalue = false;
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasvalue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasvalue && observer.onNext(value);
          observer.onCompleted();
          hasvalue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, this);
    };
    observableProto.throttle = function(dueTime, scheduler) {
      return this.debounce(dueTime, scheduler);
    };
    observableProto.windowWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      var source = this,
          timeShift;
      timeShiftOrScheduler == null && (timeShift = timeSpan);
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (typeof timeShiftOrScheduler === 'number') {
        timeShift = timeShiftOrScheduler;
      } else if (isScheduler(timeShiftOrScheduler)) {
        timeShift = timeSpan;
        scheduler = timeShiftOrScheduler;
      }
      return new AnonymousObservable(function(observer) {
        var groupDisposable,
            nextShift = timeShift,
            nextSpan = timeSpan,
            q = [],
            refCountDisposable,
            timerD = new SerialDisposable(),
            totalTime = 0;
        groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);
        function createTimer() {
          var m = new SingleAssignmentDisposable(),
              isSpan = false,
              isShift = false;
          timerD.setDisposable(m);
          if (nextSpan === nextShift) {
            isSpan = true;
            isShift = true;
          } else if (nextSpan < nextShift) {
            isSpan = true;
          } else {
            isShift = true;
          }
          var newTotalTime = isSpan ? nextSpan : nextShift,
              ts = newTotalTime - totalTime;
          totalTime = newTotalTime;
          if (isSpan) {
            nextSpan += timeShift;
          }
          if (isShift) {
            nextShift += timeShift;
          }
          m.setDisposable(scheduler.scheduleWithRelative(ts, function() {
            if (isShift) {
              var s = new Subject();
              q.push(s);
              observer.onNext(addRef(s, refCountDisposable));
            }
            isSpan && q.shift().onCompleted();
            createTimer();
          }));
        }
        ;
        q.push(new Subject());
        observer.onNext(addRef(q[0], refCountDisposable));
        createTimer();
        groupDisposable.add(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
        }, function(e) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onError(e);
          }
          observer.onError(e);
        }, function() {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.windowWithTimeOrCount = function(timeSpan, count, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var timerD = new SerialDisposable(),
            groupDisposable = new CompositeDisposable(timerD),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            n = 0,
            windowId = 0,
            s = new Subject();
        function createTimer(id) {
          var m = new SingleAssignmentDisposable();
          timerD.setDisposable(m);
          m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function() {
            if (id !== windowId) {
              return ;
            }
            n = 0;
            var newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
            createTimer(newId);
          }));
        }
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(0);
        groupDisposable.add(source.subscribe(function(x) {
          var newId = 0,
              newWindow = false;
          s.onNext(x);
          if (++n === count) {
            newWindow = true;
            n = 0;
            newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
          }
          newWindow && createTimer(newId);
        }, function(e) {
          s.onError(e);
          observer.onError(e);
        }, function() {
          s.onCompleted();
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.bufferWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      return this.windowWithTime.apply(this, arguments).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.bufferWithTimeOrCount = function(timeSpan, count, scheduler) {
      return this.windowWithTimeOrCount(timeSpan, count, scheduler).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.timeInterval = function(scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return observableDefer(function() {
        var last = scheduler.now();
        return source.map(function(x) {
          var now = scheduler.now(),
              span = now - last;
          last = now;
          return {
            value: x,
            interval: span
          };
        });
      });
    };
    observableProto.timestamp = function(scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return this.map(function(x) {
        return {
          value: x,
          timestamp: scheduler.now()
        };
      });
    };
    function sampleObservable(source, sampler) {
      return new AnonymousObservable(function(o) {
        var atEnd = false,
            value,
            hasValue = false;
        function sampleSubscribe() {
          if (hasValue) {
            hasValue = false;
            o.onNext(value);
          }
          atEnd && o.onCompleted();
        }
        var sourceSubscription = new SingleAssignmentDisposable();
        sourceSubscription.setDisposable(source.subscribe(function(newValue) {
          hasValue = true;
          value = newValue;
        }, function(e) {
          o.onError(e);
        }, function() {
          atEnd = true;
          sourceSubscription.dispose();
        }));
        return new CompositeDisposable(sourceSubscription, sampler.subscribe(sampleSubscribe, function(e) {
          o.onError(e);
        }, sampleSubscribe));
      }, source);
    }
    observableProto.sample = observableProto.throttleLatest = function(intervalOrSampler, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return typeof intervalOrSampler === 'number' ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler);
    };
    observableProto.timeout = function(dueTime, other, scheduler) {
      (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(observer) {
        var id = 0,
            original = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable(),
            switched = false,
            timer = new SerialDisposable();
        subscription.setDisposable(original);
        function createTimer() {
          var myId = id;
          timer.setDisposable(scheduler[schedulerMethod](dueTime, function() {
            if (id === myId) {
              isPromise(other) && (other = observableFromPromise(other));
              subscription.setDisposable(other.subscribe(observer));
            }
          }));
        }
        createTimer();
        original.setDisposable(source.subscribe(function(x) {
          if (!switched) {
            id++;
            observer.onNext(x);
            createTimer();
          }
        }, function(e) {
          if (!switched) {
            id++;
            observer.onError(e);
          }
        }, function() {
          if (!switched) {
            id++;
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithAbsoluteAndState(initialState, scheduler.now(), function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithRelativeAndState(initialState, 0, function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    observableProto.delaySubscription = function(dueTime, scheduler) {
      var scheduleMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var d = new SerialDisposable();
        d.setDisposable(scheduler[scheduleMethod](dueTime, function() {
          d.setDisposable(source.subscribe(o));
        }));
        return d;
      }, this);
    };
    observableProto.delayWithSelector = function(subscriptionDelay, delayDurationSelector) {
      var source = this,
          subDelay,
          selector;
      if (isFunction(subscriptionDelay)) {
        selector = subscriptionDelay;
      } else {
        subDelay = subscriptionDelay;
        selector = delayDurationSelector;
      }
      return new AnonymousObservable(function(observer) {
        var delays = new CompositeDisposable(),
            atEnd = false,
            subscription = new SerialDisposable();
        function start() {
          subscription.setDisposable(source.subscribe(function(x) {
            var delay = tryCatch(selector)(x);
            if (delay === errorObj) {
              return observer.onError(delay.e);
            }
            var d = new SingleAssignmentDisposable();
            delays.add(d);
            d.setDisposable(delay.subscribe(function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }, function(e) {
              observer.onError(e);
            }, function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }));
          }, function(e) {
            observer.onError(e);
          }, function() {
            atEnd = true;
            subscription.dispose();
            done();
          }));
        }
        function done() {
          atEnd && delays.length === 0 && observer.onCompleted();
        }
        if (!subDelay) {
          start();
        } else {
          subscription.setDisposable(subDelay.subscribe(start, function(e) {
            observer.onError(e);
          }, start));
        }
        return new CompositeDisposable(subscription, delays);
      }, this);
    };
    observableProto.timeoutWithSelector = function(firstTimeout, timeoutdurationSelector, other) {
      if (arguments.length === 1) {
        timeoutdurationSelector = firstTimeout;
        firstTimeout = observableNever();
      }
      other || (other = observableThrow(new Error('Timeout')));
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription = new SerialDisposable(),
            timer = new SerialDisposable(),
            original = new SingleAssignmentDisposable();
        subscription.setDisposable(original);
        var id = 0,
            switched = false;
        function setTimer(timeout) {
          var myId = id;
          function timerWins() {
            return id === myId;
          }
          var d = new SingleAssignmentDisposable();
          timer.setDisposable(d);
          d.setDisposable(timeout.subscribe(function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
            d.dispose();
          }, function(e) {
            timerWins() && observer.onError(e);
          }, function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
          }));
        }
        ;
        setTimer(firstTimeout);
        function observerWins() {
          var res = !switched;
          if (res) {
            id++;
          }
          return res;
        }
        original.setDisposable(source.subscribe(function(x) {
          if (observerWins()) {
            observer.onNext(x);
            var timeout;
            try {
              timeout = timeoutdurationSelector(x);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
          }
        }, function(e) {
          observerWins() && observer.onError(e);
        }, function() {
          observerWins() && observer.onCompleted();
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    observableProto.debounceWithSelector = function(durationSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var value,
            hasValue = false,
            cancelable = new SerialDisposable(),
            id = 0;
        var subscription = source.subscribe(function(x) {
          var throttle;
          try {
            throttle = durationSelector(x);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(throttle) && (throttle = observableFromPromise(throttle));
          hasValue = true;
          value = x;
          id++;
          var currentid = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(throttle.subscribe(function() {
            hasValue && id === currentid && observer.onNext(value);
            hasValue = false;
            d.dispose();
          }, observer.onError.bind(observer), function() {
            hasValue && id === currentid && observer.onNext(value);
            hasValue = false;
            d.dispose();
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasValue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasValue && observer.onNext(value);
          observer.onCompleted();
          hasValue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    };
    observableProto.throttleWithSelector = function(durationSelector) {
      return this.debounceWithSelector(durationSelector);
    };
    observableProto.skipLastWithTime = function(duration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0) {
            var next = q.shift();
            if (now - next.interval <= duration) {
              o.onNext(next.value);
            }
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBufferWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now(),
              res = [];
          while (q.length > 0) {
            var next = q.shift();
            now - next.interval <= duration && res.push(next.value);
          }
          o.onNext(res);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.skipWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var open = false;
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && observer.onNext(x);
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
      }, source);
    };
    observableProto.skipUntilWithTime = function(startTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = startTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        var open = false;
        return new CompositeDisposable(scheduler[schedulerMethod](startTime, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
      }, source);
    };
    observableProto.takeUntilWithTime = function(endTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = endTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler[schedulerMethod](endTime, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.throttleFirst = function(windowDuration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var duration = +windowDuration || 0;
      if (duration <= 0) {
        throw new RangeError('windowDuration cannot be less or equal zero.');
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var lastOnNext = 0;
        return source.subscribe(function(x) {
          var now = scheduler.now();
          if (lastOnNext === 0 || now - lastOnNext >= duration) {
            lastOnNext = now;
            o.onNext(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/lib/invariant", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var invariant = function(condition, format, a, b, c, d, e, f) {
    if (false) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
      }
      error.framesToPop = 1;
      throw error;
    }
  };
  module.exports = invariant;
  global.define = __define;
  return module.exports;
});

System.register("src/rules-engine-ng2/app/rules-engine-ng2.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-sm-12\">\n            <div class=\"row page-title-search\">\n                <div class=\"col-sm-8\">\n                    <h1>DotCMS Rules Engine</h1>\n                </div>\n                <div class=\"col-sm-4\">\n                    <form class=\"form-horizontal\">\n                        <div class=\"form-group has-feedback\">\n                            <div class=\"col-sm-12\">\n                                <input type=\"text\" class=\"form-control\" placeholder=\"Start typing to filter rules...\">\n                                <span class=\"glyphicon glyphicon-search form-control-feedback\"></span>\n                            </div>\n                        </div>\n                    </form>\n                </div>\n            </div>\n\n            <hr/>\n\n            <rule class=\"row\" *for=\"var r of rules; var i=index\"\n                  [rule]=\"r\"\n                  [index]=\"i + 1\"></rule>\n\n        </div>\n    </div>\n</div>";
  global.define = __define;
  return module.exports;
});

System.register("src/rules-engine-ng2/app/rule.tpl.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"panel panel-default rule\" [control-group]=\"form\">\n  <div class=\"panel-heading\">\n    <div class=\"row\">\n      <div class=\"col-sm-8\">\n        <input type=\"text\" class=\"form-control  rule-title\" placeholder=\"Describe the rule\" control=\"name\">\n      </div>\n      <div class=\"col-sm-4\">\n        <div class=\"operations rule-operations\">\n          <label for=\"\">Fire on:</label>\n          <div class=\"btn-group\">\n            <button type=\"button\" class=\"btn btn-default\">Every page</button>\n            <button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\" aria-expanded=\"false\">\n              <span class=\"caret\"></span>\n              <span class=\"sr-only\">Toggle Dropdown</span>\n            </button>\n            <ul class=\"dropdown-menu\" role=\"menu\">\n              <li><a href=\"#\">Once per visit</a></li>\n              <li><a href=\"#\">Once per visitor</a></li>\n            </ul>\n          </div>\n          <div class=\"separator\"></div>\n          <button type=\"button\" class=\"btn btn-default btn-md\" aria-label=\"Toggle collapse clause group\" (click)=\"toggleCollapse()\">\n            <span class=\"glyphicon glyphicon-resize-vertical\" aria-hidden=\"true\"></span>\n          </button>\n          <button type=\"button\" class=\"btn btn-default btn-md\" arial-label=\"Add new rule\" (click)=\"addRule()\">\n            <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span>\n          </button>\n          <button type=\"button\" class=\"btn btn-default btn-md btn-danger\" aria-label=\"Delete Rule\" (click)=\"removeRule()\">\n            <span class=\"glyphicon glyphicon-trash\"></span>\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"panel-body collapse\" [class.in]=\"!isCollapse\">\n    <div class=\"section-separator\">\n      <h2>When</h2>\n      <hr/>\n    </div>\n    <clause-group *for=\"var cg of rule.groups; var i=index\"\n                    [rule]=\"rule\"\n                    [group]=\"cg\"\n                    [index]=\"i + 1\">\n    </clause-group>\n\n    <div class=\"section-separator\">\n      <h2>Then</h2>\n      <hr/>\n    </div>\n\n    <div class=\"panel panel-default actions\">\n      <ul class=\"list-group\">\n        <rule-action *for=\"var act of rule.ruleActions; var i=index\"\n                     [rule]=\"rule\"\n                     [rule-action]=\"act\"\n                     [index]=\"i + 1\">\n        </rule-action>\n      </ul>\n    </div>\n    <button class=\"btn btn-default\" \">\n      <span class=\"glyphicon glyphicon-plus-sign\"></span>\n      <span>Add Action</span>\n    </button>\n\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register("src/rules-engine-ng2/app/rule-action.tpl.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<li class=\"list-group-item action-item\">\n  <div class=\"row\">\n    <div class=\"col-sm-10\">\n      <input type=\"text\" class=\"form-control\" placeholder=\"Action Description\" control=\"name\" />\n    </div>\n    <div class=\"col-sm-2\">\n      <div class=\"operations actions-operations\">\n        <button type=\"button\" class=\"btn btn-default btn-md\" aria-label=\"Add Action\" (click)=\"addRuleAction(rule)\">\n          <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span>\n        </button>\n        <button type=\"button\" class=\"btn btn-default btn-md btn-danger\" aria-label=\"Remove Action\" (click)=\"removeAction(action)\">\n          <span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"></span>\n        </button>\n      </div>\n    </div>\n  </div>\n</li>\n\n";
  global.define = __define;
  return module.exports;
});

System.register("src/rules-engine-ng2/app/clause-group.tpl.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"clause-group-separator\" *if=\"index > 1\">\n  <div class=\"row\">\n    <div class=\"col-sm-1\">\n      <button class=\"btn btn-default field-operator\" (click)=\"toggleOperator(rule, group)\">\n        {{group.operator}}\n      </button>\n    </div>\n  </div>\n</div>\n\n<div class=\"panel panel-default clause-group\">\n  <div class=\"panel-heading\">\n    <div class=\"row\">\n      <div class=\"col-xs-6\">\n        <button type=\"button\" class=\"btn btn-default btn-md js-info-button\" data-toggle=\"popover\" data-placement=\"top\" title=\"Teaser about the rule\" data-content=\"Visitor is from France, user is anonymous and device is tablet\">\n          <span class=\"glyphicon glyphicon-question-sign js-info-button\" aria-hidden=\"true\"></span>\n        </button>\n        <h4 class=\"panel-title js-rule-teaser\">We need to add the teaser dynamically...</h4>\n      </div>\n      <div class=\"col-xs-6\">\n        <div class=\"operations clause-group-operations\">\n          <button type=\"button\" class=\"btn btn-default btn-md\" (click)=\"toggleCollapse()\">\n            <span class=\"glyphicon glyphicon-resize-vertical\" aria-hidden=\"true\"></span>\n          </button>\n          <button type=\"button\" class=\"btn btn-default btn-md\" aria-label=\"Add Clause\" (click)=\"addGroup(rule)\">\n            <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\" ></span>\n          </button>\n        </div>\n\n        <!--Remove group will happen when there is no clauses-->\n        <!--<button class=\"btn btn-default\" aria-label=\"Delete Group\" (click)=\"removeGroup(rule, group)\">-->\n          <!--<span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"></span>-->\n        <!--</button>-->\n      </div>\n    </div>\n  </div>\n  <div class=\"panel-body collapse\" [class.in]=\"!isCollapse\">\n    <clause *for=\"var clause of clauses; var i=index\"\n            [rule]=\"rule\"\n            [group]=\"group\"\n            [clause]=\"clause\"\n            [index]=\"i + 1\">\n    </clause>\n  </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register("src/rules-engine-ng2/app/clause.tpl.html!github:systemjs/plugin-text@0.0.2", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"panel panel-default clause\">\n  <div class=\"panel-body\">\n    <div class=\"row\">\n      <div class=\"col-sm-1\">\n        <button type=\"button\"class=\"btn btn-default\" (click)=\"toggleOperator(clause)\">\n          {{clause.operator}}\n        </button>\n      </div>\n      <div class=\"col-sm-11\">\n        <div class=\"row\">\n          <div class=\"col-sm-5\">\n            <select class=\"form-control clause-selector\" [value]=\"clause.type\">\n              <option value=\"clauseType.id\" *for=\"var clauseType of clauseTypes; var i=index\">{{clauseType.id}}</option>\n            </select>\n          </div>\n          <div class=\"col-sm-1\">\n            <h4 class=\"separator\">is</h4>\n          </div>\n          <div class=\"col-sm-4\">\n            <select class=\"form-control clause-selector\" [value]=\"clause.comparison\">\n              <option value=\"comparison.id\" *for=\"var comparison of comparisons\">{{comparison.id}}</option>\n            </select>\n          </div>\n          <div class=\"col-sm-2\">\n            <div class=\"operations clause-operations\">\n              <button type=\"button\" class=\"btn btn-default btn-md\" (click)=\"addClause(rule, group)\">\n                <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span>\n              </button>\n              <button type=\"button\" class=\"btn btn-default btn-md btn-danger\" aria-label=\"Delete Clause\" (click)=\"removeClause(clause)\">\n                <span class=\"glyphicon glyphicon-trash\" aria-hidden=\"true\"></span>\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>";
  global.define = __define;
  return module.exports;
});

System.register("npm:zone.js@0.4.4", ["npm:zone.js@0.4.4/zone"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:zone.js@0.4.4/zone");
  global.define = __define;
  return module.exports;
});

System.register("npm:ms@0.7.1", ["npm:ms@0.7.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ms@0.7.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:base64-js@0.0.8/lib/b64");
  global.define = __define;
  return module.exports;
});

System.register("npm:ieee754@1.1.5", ["npm:ieee754@1.1.5/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ieee754@1.1.5/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:is-array@1.0.1", ["npm:is-array@1.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-array@1.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:inherits@2.0.1", ["npm:inherits@2.0.1/inherits_browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:inherits@2.0.1/inherits_browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hash@1.1.1/md5", ["npm:create-hash@1.1.1/helpers"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var helpers = require("npm:create-hash@1.1.1/helpers");
  function core_md5(x, len) {
    x[len >> 5] |= 0x80 << ((len) % 32);
    x[(((len + 64) >>> 9) << 4) + 14] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safe_add(a, olda);
      b = safe_add(b, oldb);
      c = safe_add(c, oldc);
      d = safe_add(d, oldd);
    }
    return Array(a, b, c, d);
  }
  function md5_cmn(q, a, b, x, s, t) {
    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
  }
  function md5_ff(a, b, c, d, x, s, t) {
    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
  }
  function md5_gg(a, b, c, d, x, s, t) {
    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
  }
  function md5_hh(a, b, c, d, x, s, t) {
    return md5_cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5_ii(a, b, c, d, x, s, t) {
    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
  }
  function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xFFFF);
  }
  function bit_rol(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt));
  }
  module.exports = function md5(buf) {
    return helpers.hash(buf, core_md5, 16);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:ripemd160@1.0.1", ["npm:ripemd160@1.0.1/lib/ripemd160"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ripemd160@1.0.1/lib/ripemd160");
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 0x67452301 | 0;
      this._b = 0xefcdab89 | 0;
      this._c = 0x98badcfe | 0;
      this._d = 0x10325476 | 0;
      this._e = 0xc3d2e1f0 | 0;
      return this;
    };
    function rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt));
    }
    Sha.prototype._update = function(M) {
      var W = this._w;
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      var e = this._e;
      var j = 0,
          k;
      function calcW() {
        return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16];
      }
      function loop(w, f) {
        W[j] = w;
        var t = rol(a, 5) + f + e + w + k;
        e = d;
        d = c;
        c = rol(b, 30);
        b = a;
        a = t;
        j++;
      }
      k = 1518500249;
      while (j < 16)
        loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d));
      while (j < 20)
        loop(calcW(), (b & c) | ((~b) & d));
      k = 1859775393;
      while (j < 40)
        loop(calcW(), b ^ c ^ d);
      k = -1894007588;
      while (j < 60)
        loop(calcW(), (b & c) | (b & d) | (c & d));
      k = -899497514;
      while (j < 80)
        loop(calcW(), b ^ c ^ d);
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };
    Sha.prototype._hash = function() {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha224", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/sha256", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var Sha256 = require("npm:sha.js@2.4.2/sha256");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 0xc1059ed8 | 0;
      this._b = 0x367cd507 | 0;
      this._c = 0x3070dd17 | 0;
      this._d = 0xf70e5939 | 0;
      this._e = 0xffc00b31 | 0;
      this._f = 0x68581511 | 0;
      this._g = 0x64f98fa7 | 0;
      this._h = 0xbefa4fa4 | 0;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = new Buffer(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/sha384", ["npm:inherits@2.0.1", "npm:sha.js@2.4.2/sha512", "npm:sha.js@2.4.2/hash", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = require("npm:inherits@2.0.1");
    var SHA512 = require("npm:sha.js@2.4.2/sha512");
    var Hash = require("npm:sha.js@2.4.2/hash");
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._a = 0xcbbb9d5d | 0;
      this._b = 0x629a292a | 0;
      this._c = 0x9159015a | 0;
      this._d = 0x152fecd8 | 0;
      this._e = 0x67332667 | 0;
      this._f = 0x8eb44a87 | 0;
      this._g = 0xdb0c2e0d | 0;
      this._h = 0x47b5481d | 0;
      this._al = 0xc1059ed8 | 0;
      this._bl = 0x367cd507 | 0;
      this._cl = 0x3070dd17 | 0;
      this._dl = 0xf70e5939 | 0;
      this._el = 0xffc00b31 | 0;
      this._fl = 0x68581511 | 0;
      this._gl = 0x64f98fa7 | 0;
      this._hl = 0xbefa4fa4 | 0;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = new Buffer(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._a, this._al, 0);
      writeInt64BE(this._b, this._bl, 8);
      writeInt64BE(this._c, this._cl, 16);
      writeInt64BE(this._d, this._dl, 24);
      writeInt64BE(this._e, this._el, 32);
      writeInt64BE(this._f, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:events@1.0.2", ["npm:events@1.0.2/events"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:events@1.0.2/events");
  global.define = __define;
  return module.exports;
});

System.register("npm:isarray@0.0.1", ["npm:isarray@0.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:isarray@0.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-util-is@1.0.1", ["npm:core-util-is@1.0.1/lib/util"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-util-is@1.0.1/lib/util");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/lib/_stream_duplex", ["npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "npm:readable-stream@1.1.13/lib/_stream_readable", "npm:readable-stream@1.1.13/lib/_stream_writable", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require("npm:core-util-is@1.0.1");
    util.inherits = require("npm:inherits@2.0.1");
    var Readable = require("npm:readable-stream@1.1.13/lib/_stream_readable");
    var Writable = require("npm:readable-stream@1.1.13/lib/_stream_writable");
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return ;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:string_decoder@0.10.31", ["npm:string_decoder@0.10.31/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:string_decoder@0.10.31/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hmac@1.1.3", ["npm:create-hmac@1.1.3/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:create-hmac@1.1.3/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:pbkdf2@3.0.4", ["npm:pbkdf2@3.0.4/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:pbkdf2@3.0.4/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/authCipher", ["npm:browserify-aes@1.0.1/aes", "npm:browserify-aes@1.0.1/cipherBase", "npm:inherits@2.0.1", "npm:browserify-aes@1.0.1/ghash", "npm:browserify-aes@1.0.1/xor", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = require("npm:browserify-aes@1.0.1/aes");
    var Transform = require("npm:browserify-aes@1.0.1/cipherBase");
    var inherits = require("npm:inherits@2.0.1");
    var GHASH = require("npm:browserify-aes@1.0.1/ghash");
    var xor = require("npm:browserify-aes@1.0.1/xor");
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])]);
      iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])]);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      this._alen = 0;
      this._len = 0;
      iv.copy(this._prev);
      this._mode = mode;
      var h = new Buffer(4);
      h.fill(0);
      this._ghash = new GHASH(this._cipher.encryptBlock(h));
      this._authTag = null;
      this._called = false;
    }
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - (this._alen % 16);
        if (rump < 16) {
          rump = new Buffer(rump);
          rump.fill(0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag) {
        throw new Error('Unsupported state or unable to authenticate data');
      }
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt) {
        if (xorTest(tag, this._authTag)) {
          throw new Error('Unsupported state or unable to authenticate data');
        }
      } else {
        this._authTag = tag;
      }
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
        return this._authTag;
      } else {
        throw new Error('Attempting to get auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (this._decrypt) {
        this._authTag = tag;
      } else {
        throw new Error('Attempting to set auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (!this._called) {
        this._ghash.update(buf);
        this._alen += buf.length;
      } else {
        throw new Error('Attempting to set AAD in unsupported state');
      }
    };
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length) {
        out++;
      }
      var len = Math.min(a.length, b.length);
      var i = -1;
      while (++i < len) {
        out += (a[i] ^ b[i]);
      }
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:bn.js@2.0.5", ["npm:bn.js@2.0.5/lib/bn"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:bn.js@2.0.5/lib/bn");
  global.define = __define;
  return module.exports;
});

System.register("npm:brorand@1.0.5", ["npm:brorand@1.0.5/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:brorand@1.0.5/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:indexof@0.0.1", ["npm:indexof@0.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:indexof@0.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:minimalistic-assert@1.0.0", ["npm:minimalistic-assert@1.0.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:minimalistic-assert@1.0.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/constants/index", ["npm:asn1.js@2.0.3/lib/asn1/constants/der"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var constants = exports;
  constants._reverse = function reverse(map) {
    var res = {};
    Object.keys(map).forEach(function(key) {
      if ((key | 0) == key)
        key = key | 0;
      var value = map[key];
      res[value] = key;
    });
    return res;
  };
  constants.der = require("npm:asn1.js@2.0.3/lib/asn1/constants/der");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/decoders/index", ["npm:asn1.js@2.0.3/lib/asn1/decoders/der"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var decoders = exports;
  decoders.der = require("npm:asn1.js@2.0.3/lib/asn1/decoders/der");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/encoders/index", ["npm:asn1.js@2.0.3/lib/asn1/encoders/der"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var encoders = exports;
  encoders.der = require("npm:asn1.js@2.0.3/lib/asn1/encoders/der");
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1/fixProc", ["npm:parse-asn1@3.0.1/EVP_BytesToKey", "npm:browserify-aes@1.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
    var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m;
    var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
    var evp = require("npm:parse-asn1@3.0.1/EVP_BytesToKey");
    var ciphers = require("npm:browserify-aes@1.0.1");
    module.exports = function(okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
      } else {
        var suite = 'aes' + match[1];
        var iv = new Buffer(match[2], 'hex');
        var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1]));
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
      }
      var tag = key.match(startRegex)[1] + ' KEY';
      return {
        tag: tag,
        data: decrypted
      };
    };
    function wrap(str) {
      var chunks = [];
      for (var i = 0; i < str.length; i += 64) {
        chunks.push(str.slice(i, i + 64));
      }
      return chunks.join("\n");
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3/lib/hash", ["npm:hash.js@1.0.3/lib/hash/utils", "npm:hash.js@1.0.3/lib/hash/common", "npm:hash.js@1.0.3/lib/hash/sha", "npm:hash.js@1.0.3/lib/hash/ripemd", "npm:hash.js@1.0.3/lib/hash/hmac"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var hash = exports;
  hash.utils = require("npm:hash.js@1.0.3/lib/hash/utils");
  hash.common = require("npm:hash.js@1.0.3/lib/hash/common");
  hash.sha = require("npm:hash.js@1.0.3/lib/hash/sha");
  hash.ripemd = require("npm:hash.js@1.0.3/lib/hash/ripemd");
  hash.hmac = require("npm:hash.js@1.0.3/lib/hash/hmac");
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curve/index", ["npm:elliptic@3.0.4/lib/elliptic/curve/base", "npm:elliptic@3.0.4/lib/elliptic/curve/short", "npm:elliptic@3.0.4/lib/elliptic/curve/mont", "npm:elliptic@3.0.4/lib/elliptic/curve/edwards"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var curve = exports;
  curve.base = require("npm:elliptic@3.0.4/lib/elliptic/curve/base");
  curve.short = require("npm:elliptic@3.0.4/lib/elliptic/curve/short");
  curve.mont = require("npm:elliptic@3.0.4/lib/elliptic/curve/mont");
  curve.edwards = require("npm:elliptic@3.0.4/lib/elliptic/curve/edwards");
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/curves", ["npm:hash.js@1.0.3", "npm:elliptic@3.0.4/lib/elliptic", "npm:elliptic@3.0.4/lib/elliptic/precomputed/secp256k1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var curves = exports;
  var hash = require("npm:hash.js@1.0.3");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var assert = elliptic.utils.assert;
  function PresetCurve(options) {
    if (options.type === 'short')
      this.curve = new elliptic.curve.short(options);
    else if (options.type === 'edwards')
      this.curve = new elliptic.curve.edwards(options);
    else
      this.curve = new elliptic.curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '0',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['9']
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', '6666666666666666666666666666666666666666666666666666666666666658']
  });
  var pre;
  try {
    pre = require("npm:elliptic@3.0.4/lib/elliptic/precomputed/secp256k1");
  } catch (e) {
    pre = undefined;
  }
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [{
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    }, {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }],
    gRed: false,
    g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/ec/index", ["npm:bn.js@2.0.5", "npm:elliptic@3.0.4/lib/elliptic", "npm:elliptic@3.0.4/lib/elliptic/ec/key", "npm:elliptic@3.0.4/lib/elliptic/ec/signature"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var bn = require("npm:bn.js@2.0.5");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var utils = elliptic.utils;
  var assert = utils.assert;
  var KeyPair = require("npm:elliptic@3.0.4/lib/elliptic/ec/key");
  var Signature = require("npm:elliptic@3.0.4/lib/elliptic/ec/signature");
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === 'string') {
      assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);
      options = elliptic.curves[options];
    }
    if (options instanceof elliptic.curves.PresetCurve)
      options = {curve: options};
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.shrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  module.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      pers: options.pers,
      entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new bn(2));
    do {
      var priv = new bn(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    } while (true);
  };
  EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.shrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new bn(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray();
    for (var i = bkey.length; i < 21; i++)
      bkey.unshift(0);
    var nonce = msg.toArray();
    for (var i = nonce.length; i < bytes; i++)
      nonce.unshift(0);
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce
    });
    var ns1 = this.n.sub(new bn(1));
    do {
      var k = new bn(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var r = kp.getX().mod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      if (options.canonical && s.cmp(this.nh) > 0)
        s = this.n.sub(s);
      return new Signature({
        r: r,
        s: s
      });
    } while (true);
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new bn(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, 'hex');
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).mod(this.n);
    var u2 = sinv.mul(r).mod(this.n);
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().mod(this.n).cmp(r) === 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-rsa@2.0.1", ["npm:browserify-rsa@2.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:browserify-rsa@2.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-ecdh@2.0.1/index", ["github:jspm/nodelibs-crypto@0.1.0", "npm:create-ecdh@2.0.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var createECDH = require("github:jspm/nodelibs-crypto@0.1.0").createECDH;
  module.exports = createECDH || require("npm:create-ecdh@2.0.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/publicEncrypt", ["npm:parse-asn1@3.0.1", "npm:randombytes@2.0.1", "npm:create-hash@1.1.1", "npm:public-encrypt@2.0.1/mgf", "npm:public-encrypt@2.0.1/xor", "npm:bn.js@2.0.5", "npm:public-encrypt@2.0.1/withPublic", "npm:browserify-rsa@2.0.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var parseKeys = require("npm:parse-asn1@3.0.1");
    var randomBytes = require("npm:randombytes@2.0.1");
    var createHash = require("npm:create-hash@1.1.1");
    var mgf = require("npm:public-encrypt@2.0.1/mgf");
    var xor = require("npm:public-encrypt@2.0.1/xor");
    var bn = require("npm:bn.js@2.0.5");
    var withPublic = require("npm:public-encrypt@2.0.1/withPublic");
    var crt = require("npm:browserify-rsa@2.0.1");
    var constants = {
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_PKCS1_PADDIN: 1,
      RSA_NO_PADDING: 3
    };
    module.exports = function publicEncrypt(public_key, msg, reverse) {
      var padding;
      if (public_key.padding) {
        padding = public_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(public_key);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new bn(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error('data too long for modulus');
        }
      } else {
        throw new Error('unknown padding');
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error('message too long');
      }
      var ps = new Buffer(k - mLen - hLen2 - 2);
      ps.fill(0);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error('message too long');
      }
      var ps;
      if (reverse) {
        ps = new Buffer(k - mLen - 3);
        ps.fill(0xff);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new bn(Buffer.concat([new Buffer([0, reverse ? 1 : 2]), ps, new Buffer([0]), msg], k));
    }
    function nonZero(len, crypto) {
      var out = new Buffer(len);
      var i = 0;
      var cache = randomBytes(len * 2);
      var cur = 0;
      var num;
      while (i < len) {
        if (cur === cache.length) {
          cache = randomBytes(len * 2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/index", ["npm:rx@2.5.3/dist/rx", "npm:rx@2.5.3/dist/rx.aggregates", "npm:rx@2.5.3/dist/rx.async", "npm:rx@2.5.3/dist/rx.backpressure", "npm:rx@2.5.3/dist/rx.binding", "npm:rx@2.5.3/dist/rx.coincidence", "npm:rx@2.5.3/dist/rx.experimental", "npm:rx@2.5.3/dist/rx.joinpatterns", "npm:rx@2.5.3/dist/rx.sorting", "npm:rx@2.5.3/dist/rx.virtualtime", "npm:rx@2.5.3/dist/rx.testing", "npm:rx@2.5.3/dist/rx.time"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  require("npm:rx@2.5.3/dist/rx.aggregates");
  require("npm:rx@2.5.3/dist/rx.async");
  require("npm:rx@2.5.3/dist/rx.backpressure");
  require("npm:rx@2.5.3/dist/rx.binding");
  require("npm:rx@2.5.3/dist/rx.coincidence");
  require("npm:rx@2.5.3/dist/rx.experimental");
  require("npm:rx@2.5.3/dist/rx.joinpatterns");
  require("npm:rx@2.5.3/dist/rx.sorting");
  require("npm:rx@2.5.3/dist/rx.virtualtime");
  require("npm:rx@2.5.3/dist/rx.testing");
  require("npm:rx@2.5.3/dist/rx.time");
  module.exports = Rx;
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/lib/Dispatcher", ["npm:flux@2.0.3/lib/invariant"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var invariant = require("npm:flux@2.0.3/lib/invariant");
  var _lastID = 1;
  var _prefix = 'ID_';
  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }
  Dispatcher.prototype.register = function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };
  Dispatcher.prototype.unregister = function(id) {
    invariant(this.$Dispatcher_callbacks[id], 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id);
    delete this.$Dispatcher_callbacks[id];
  };
  Dispatcher.prototype.waitFor = function(ids) {
    invariant(this.$Dispatcher_isDispatching, 'Dispatcher.waitFor(...): Must be invoked while dispatching.');
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(this.$Dispatcher_isHandled[id], 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id);
        continue;
      }
      invariant(this.$Dispatcher_callbacks[id], 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id);
      this.$Dispatcher_invokeCallback(id);
    }
  };
  Dispatcher.prototype.dispatch = function(payload) {
    invariant(!this.$Dispatcher_isDispatching, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.');
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };
  Dispatcher.prototype.isDispatching = function() {
    return this.$Dispatcher_isDispatching;
  };
  Dispatcher.prototype.$Dispatcher_invokeCallback = function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };
  Dispatcher.prototype.$Dispatcher_startDispatching = function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };
  Dispatcher.prototype.$Dispatcher_stopDispatching = function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };
  module.exports = Dispatcher;
  global.define = __define;
  return module.exports;
});

System.register("npm:debug@2.2.0/debug", ["npm:ms@0.7.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require("npm:ms@0.7.1");
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevColor = 0;
  var prevTime;
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  function debug(namespace) {
    function disabled() {}
    disabled.enabled = false;
    function enabled() {
      var self = enabled;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      if (null == self.useColors)
        self.useColors = exports.useColors();
      if (null == self.color && self.useColors)
        self.color = selectColor();
      var args = Array.prototype.slice.call(arguments);
      args[0] = exports.coerce(args[0]);
      if ('string' !== typeof args[0]) {
        args = ['%o'].concat(args);
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        if (match === '%%')
          return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
    var fn = exports.enabled(namespace) ? enabled : disabled;
    fn.namespace = namespace;
    return fn;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  function disable() {
    exports.enable('');
  }
  function enabled(name) {
    var i,
        len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:buffer@3.2.2/index", ["npm:base64-js@0.0.8", "npm:ieee754@1.1.5", "npm:is-array@1.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var base64 = require("npm:base64-js@0.0.8");
  var ieee754 = require("npm:ieee754@1.1.5");
  var isArray = require("npm:is-array@1.0.1");
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var kMaxLength = 0x3fffffff;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = (function() {
    try {
      var buf = new ArrayBuffer(0);
      var arr = new Uint8Array(buf);
      arr.foo = function() {
        return 42;
      };
      return arr.foo() === 42 && typeof arr.subarray === 'function' && new Uint8Array(1).subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  })();
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    this.length = 0;
    this.parent = undefined;
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object);
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength.toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    } else if (list.length === 1) {
      return list[0];
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = String(string);
    if (string.length === 0)
      return 0;
    switch (encoding || 'utf8') {
      case 'ascii':
      case 'binary':
      case 'raw':
        return string.length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return string.length * 2;
      case 'hex':
        return string.length >>> 1;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        return string.length;
    }
  }
  Buffer.byteLength = byteLength;
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  Buffer.prototype.toString = function toString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    var res = '';
    var tmp = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }
    return res + decodeUtf8Char(tmp);
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = value;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = value;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return ;
    if (this.length === 0)
      return ;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    var i = 0;
    for (; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (leadSurrogate) {
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } else {
            codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
            leadSurrogate = null;
          }
        } else {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else {
            leadSurrogate = codePoint;
            continue;
          }
        }
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = null;
      }
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x200000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function decodeUtf8Char(str) {
    try {
      return decodeURIComponent(str);
    } catch (err) {
      return String.fromCharCode(0xFFFD);
    }
  }
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2/index", ["npm:sha.js@2.4.2/sha", "npm:sha.js@2.4.2/sha1", "npm:sha.js@2.4.2/sha224", "npm:sha.js@2.4.2/sha256", "npm:sha.js@2.4.2/sha384", "npm:sha.js@2.4.2/sha512"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm)
      throw new Error(algorithm + ' is not supported (we accept pull requests)');
    return new Algorithm();
  };
  exports.sha = require("npm:sha.js@2.4.2/sha");
  exports.sha1 = require("npm:sha.js@2.4.2/sha1");
  exports.sha224 = require("npm:sha.js@2.4.2/sha224");
  exports.sha256 = require("npm:sha.js@2.4.2/sha256");
  exports.sha384 = require("npm:sha.js@2.4.2/sha384");
  exports.sha512 = require("npm:sha.js@2.4.2/sha512");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-events@0.1.1/index", ["npm:events@1.0.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('events') : require("npm:events@1.0.2");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/lib/_stream_readable", ["npm:isarray@0.0.1", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-events@0.1.1", "npm:stream-browserify@1.0.0/index", "npm:core-util-is@1.0.1", "npm:inherits@2.0.1", "@empty", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:string_decoder@0.10.31", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:string_decoder@0.10.31", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Readable;
    var isArray = require("npm:isarray@0.0.1");
    var Buffer = require("github:jspm/nodelibs-buffer@0.1.0").Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require("github:jspm/nodelibs-events@0.1.1").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require("npm:stream-browserify@1.0.0/index");
    var util = require("npm:core-util-is@1.0.1");
    util.inherits = require("npm:inherits@2.0.1");
    var StringDecoder;
    var debug = require("@empty");
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function() {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("npm:string_decoder@0.10.31").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("npm:string_decoder@0.10.31").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret))
        this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function() {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return ;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/encrypter", ["npm:browserify-aes@1.0.1/aes", "npm:browserify-aes@1.0.1/cipherBase", "npm:inherits@2.0.1", "npm:browserify-aes@1.0.1/modes", "npm:browserify-aes@1.0.1/EVP_BytesToKey", "npm:browserify-aes@1.0.1/streamCipher", "npm:browserify-aes@1.0.1/authCipher", "npm:browserify-aes@1.0.1/modes/ecb", "npm:browserify-aes@1.0.1/modes/cbc", "npm:browserify-aes@1.0.1/modes/cfb", "npm:browserify-aes@1.0.1/modes/cfb8", "npm:browserify-aes@1.0.1/modes/cfb1", "npm:browserify-aes@1.0.1/modes/ofb", "npm:browserify-aes@1.0.1/modes/ctr", "npm:browserify-aes@1.0.1/modes/ctr", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = require("npm:browserify-aes@1.0.1/aes");
    var Transform = require("npm:browserify-aes@1.0.1/cipherBase");
    var inherits = require("npm:inherits@2.0.1");
    var modes = require("npm:browserify-aes@1.0.1/modes");
    var ebtk = require("npm:browserify-aes@1.0.1/EVP_BytesToKey");
    var StreamCipher = require("npm:browserify-aes@1.0.1/streamCipher");
    var AuthCipher = require("npm:browserify-aes@1.0.1/authCipher");
    inherits(Cipher, Transform);
    function Cipher(mode, key, iv) {
      if (!(this instanceof Cipher)) {
        return new Cipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while ((chunk = this._cache.get())) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
        this._cipher.scrub();
        throw new Error('data not multiple of block length');
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len = 16 - this.cache.length;
      var padBuff = new Buffer(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      var out = Buffer.concat([this.cache, padBuff]);
      return out;
    };
    var modelist = {
      ECB: require("npm:browserify-aes@1.0.1/modes/ecb"),
      CBC: require("npm:browserify-aes@1.0.1/modes/cbc"),
      CFB: require("npm:browserify-aes@1.0.1/modes/cfb"),
      CFB8: require("npm:browserify-aes@1.0.1/modes/cfb8"),
      CFB1: require("npm:browserify-aes@1.0.1/modes/cfb1"),
      OFB: require("npm:browserify-aes@1.0.1/modes/ofb"),
      CTR: require("npm:browserify-aes@1.0.1/modes/ctr"),
      GCM: require("npm:browserify-aes@1.0.1/modes/ctr")
    };
    function createCipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv);
      }
      return new Cipher(modelist[config.mode], password, iv);
    }
    function createCipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, config.key, config.iv);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    exports.createCipheriv = createCipheriv;
    exports.createCipher = createCipher;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:miller-rabin@2.0.1/lib/mr", ["npm:bn.js@2.0.5", "npm:brorand@1.0.5"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var bn = require("npm:bn.js@2.0.5");
  var brorand = require("npm:brorand@1.0.5");
  function MillerRabin(rand) {
    this.rand = rand || new brorand.Rand();
  }
  module.exports = MillerRabin;
  MillerRabin.create = function create(rand) {
    return new MillerRabin(rand);
  };
  MillerRabin.prototype._rand = function _rand(n) {
    var len = n.bitLength();
    var buf = this.rand.generate(Math.ceil(len / 8));
    buf[0] |= 3;
    var mask = len & 0x7;
    if (mask !== 0)
      buf[buf.length - 1] >>= 7 - mask;
    return new bn(buf);
  };
  MillerRabin.prototype.test = function test(n, k, cb) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k)
      k = Math.max(1, (len / 48) | 0);
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    var prime = true;
    for (; k > 0; k--) {
      var a = this._rand(n2);
      if (cb)
        cb(a);
      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return false;
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s)
        return false;
    }
    return prime;
  };
  MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k)
      k = Math.max(1, (len / 48) | 0);
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    for (; k > 0; k--) {
      var a = this._rand(n2);
      var g = n.gcd(a);
      if (g.cmpn(1) !== 0)
        return g;
      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return x.fromRed().subn(1).gcd(n);
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s) {
        x = x.redSqr();
        return x.fromRed().subn(1).gcd(n);
      }
    }
    return false;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:vm-browserify@0.0.4/index", ["npm:indexof@0.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var indexOf = require("npm:indexof@0.0.1");
  var Object_keys = function(obj) {
    if (Object.keys)
      return Object.keys(obj);
    else {
      var res = [];
      for (var key in obj)
        res.push(key);
      return res;
    }
  };
  var forEach = function(xs, fn) {
    if (xs.forEach)
      return xs.forEach(fn);
    else
      for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
      }
  };
  var defineProp = (function() {
    try {
      Object.defineProperty({}, '_', {});
      return function(obj, name, value) {
        Object.defineProperty(obj, name, {
          writable: true,
          enumerable: false,
          configurable: true,
          value: value
        });
      };
    } catch (e) {
      return function(obj, name, value) {
        obj[name] = value;
      };
    }
  }());
  var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
  function Context() {}
  Context.prototype = {};
  var Script = exports.Script = function NodeScript(code) {
    if (!(this instanceof Script))
      return new Script(code);
    this.code = code;
  };
  Script.prototype.runInContext = function(context) {
    if (!(context instanceof Context)) {
      throw new TypeError("needs a 'context' argument.");
    }
    var iframe = document.createElement('iframe');
    if (!iframe.style)
      iframe.style = {};
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    var win = iframe.contentWindow;
    var wEval = win.eval,
        wExecScript = win.execScript;
    if (!wEval && wExecScript) {
      wExecScript.call(win, 'null');
      wEval = win.eval;
    }
    forEach(Object_keys(context), function(key) {
      win[key] = context[key];
    });
    forEach(globals, function(key) {
      if (context[key]) {
        win[key] = context[key];
      }
    });
    var winKeys = Object_keys(win);
    var res = wEval.call(win, this.code);
    forEach(Object_keys(win), function(key) {
      if (key in context || indexOf(winKeys, key) === -1) {
        context[key] = win[key];
      }
    });
    forEach(globals, function(key) {
      if (!(key in context)) {
        defineProp(context, key, win[key]);
      }
    });
    document.body.removeChild(iframe);
    return res;
  };
  Script.prototype.runInThisContext = function() {
    return eval(this.code);
  };
  Script.prototype.runInNewContext = function(context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);
    forEach(Object_keys(ctx), function(key) {
      context[key] = ctx[key];
    });
    return res;
  };
  forEach(Object_keys(Script.prototype), function(name) {
    exports[name] = Script[name] = function(code) {
      var s = Script(code);
      return s[name].apply(s, [].slice.call(arguments, 1));
    };
  });
  exports.createScript = function(code) {
    return exports.Script(code);
  };
  exports.createContext = Script.createContext = function(context) {
    var copy = new Context();
    if (typeof context === 'object') {
      forEach(Object_keys(context), function(key) {
        copy[key] = context[key];
      });
    }
    return copy;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/base/node", ["npm:asn1.js@2.0.3/lib/asn1/base/index", "npm:asn1.js@2.0.3/lib/asn1/base/index", "npm:minimalistic-assert@1.0.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Reporter = require("npm:asn1.js@2.0.3/lib/asn1/base/index").Reporter;
  var EncoderBuffer = require("npm:asn1.js@2.0.3/lib/asn1/base/index").EncoderBuffer;
  var assert = require("npm:minimalistic-assert@1.0.0");
  var tags = ['seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str'];
  var methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any'].concat(tags);
  var overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];
  function Node(enc, parent) {
    var state = {};
    this._baseState = state;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state['default'] = null;
    state.explicit = null;
    state.implicit = null;
    if (!state.parent) {
      state.children = [];
      this._wrap();
    }
  }
  module.exports = Node;
  var stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit'];
  Node.prototype.clone = function clone() {
    var state = this._baseState;
    var cstate = {};
    stateProps.forEach(function(prop) {
      cstate[prop] = state[prop];
    });
    var res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
  };
  Node.prototype._wrap = function wrap() {
    var state = this._baseState;
    methods.forEach(function(method) {
      this[method] = function _wrappedMethod() {
        var clone = new this.constructor(this);
        state.children.push(clone);
        return clone[method].apply(clone, arguments);
      };
    }, this);
  };
  Node.prototype._init = function init(body) {
    var state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
      return child._baseState.parent === this;
    }, this);
    assert.equal(state.children.length, 1, 'Root node can have only one child');
  };
  Node.prototype._useArgs = function useArgs(args) {
    var state = this._baseState;
    var children = args.filter(function(arg) {
      return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
      return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
      assert(state.children === null);
      state.children = children;
      children.forEach(function(child) {
        child._baseState.parent = this;
      }, this);
    }
    if (args.length !== 0) {
      assert(state.args === null);
      state.args = args;
      state.reverseArgs = args.map(function(arg) {
        if (typeof arg !== 'object' || arg.constructor !== Object)
          return arg;
        var res = {};
        Object.keys(arg).forEach(function(key) {
          if (key == (key | 0))
            key |= 0;
          var value = arg[key];
          res[value] = key;
        });
        return res;
      });
    }
  };
  overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
      var state = this._baseState;
      throw new Error(method + ' not implemented for encoding: ' + state.enc);
    };
  });
  tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      assert(state.tag === null);
      state.tag = tag;
      this._useArgs(args);
      return this;
    };
  });
  Node.prototype.use = function use(item) {
    var state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
  };
  Node.prototype.optional = function optional() {
    var state = this._baseState;
    state.optional = true;
    return this;
  };
  Node.prototype.def = function def(val) {
    var state = this._baseState;
    assert(state['default'] === null);
    state['default'] = val;
    state.optional = true;
    return this;
  };
  Node.prototype.explicit = function explicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
  };
  Node.prototype.implicit = function implicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
  };
  Node.prototype.obj = function obj() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0)
      this._useArgs(args);
    return this;
  };
  Node.prototype.key = function key(newKey) {
    var state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
  };
  Node.prototype.any = function any() {
    var state = this._baseState;
    state.any = true;
    return this;
  };
  Node.prototype.choice = function choice(obj) {
    var state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
      return obj[key];
    }));
    return this;
  };
  Node.prototype._decode = function decode(input) {
    var state = this._baseState;
    if (state.parent === null)
      return input.wrapResult(state.children[0]._decode(input));
    var result = state['default'];
    var present = true;
    var prevKey;
    if (state.key !== null)
      prevKey = input.enterKey(state.key);
    if (state.optional) {
      present = this._peekTag(input, state.explicit !== null ? state.explicit : state.implicit !== null ? state.implicit : state.tag || 0, state.any);
      if (input.isError(present))
        return present;
    }
    var prevObj;
    if (state.obj && present)
      prevObj = input.enterObject();
    if (present) {
      if (state.explicit !== null) {
        var explicit = this._decodeTag(input, state.explicit);
        if (input.isError(explicit))
          return explicit;
        input = explicit;
      }
      if (state.use === null && state.choice === null) {
        if (state.any)
          var save = input.save();
        var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
        if (input.isError(body))
          return body;
        if (state.any)
          result = input.raw(save);
        else
          input = body;
      }
      if (state.any)
        result = result;
      else if (state.choice === null)
        result = this._decodeGeneric(state.tag, input);
      else
        result = this._decodeChoice(input);
      if (input.isError(result))
        return result;
      if (!state.any && state.choice === null && state.children !== null) {
        var fail = state.children.some(function decodeChildren(child) {
          child._decode(input);
        });
        if (fail)
          return err;
      }
    }
    if (state.obj && present)
      result = input.leaveObject(prevObj);
    if (state.key !== null && (result !== null || present === true))
      input.leaveKey(prevKey, state.key, result);
    return result;
  };
  Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
    var state = this._baseState;
    if (tag === 'seq' || tag === 'set')
      return null;
    if (tag === 'seqof' || tag === 'setof')
      return this._decodeList(input, tag, state.args[0]);
    else if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
      return this._decodeStr(input, tag);
    else if (tag === 'objid' && state.args)
      return this._decodeObjid(input, state.args[0], state.args[1]);
    else if (tag === 'objid')
      return this._decodeObjid(input, null, null);
    else if (tag === 'gentime' || tag === 'utctime')
      return this._decodeTime(input, tag);
    else if (tag === 'null_')
      return this._decodeNull(input);
    else if (tag === 'bool')
      return this._decodeBool(input);
    else if (tag === 'int' || tag === 'enum')
      return this._decodeInt(input, state.args && state.args[0]);
    else if (state.use !== null)
      return this._getUse(state.use, input._reporterState.obj)._decode(input);
    else
      return input.error('unknown tag: ' + tag);
    return null;
  };
  Node.prototype._getUse = function _getUse(entity, obj) {
    var state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
      state.useDecoder = state.useDecoder.clone();
      state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
  };
  Node.prototype._decodeChoice = function decodeChoice(input) {
    var state = this._baseState;
    var result = null;
    var match = false;
    Object.keys(state.choice).some(function(key) {
      var save = input.save();
      var node = state.choice[key];
      try {
        var value = node._decode(input);
        if (input.isError(value))
          return false;
        result = {
          type: key,
          value: value
        };
        match = true;
      } catch (e) {
        input.restore(save);
        return false;
      }
      return true;
    }, this);
    if (!match)
      return input.error('Choice not matched');
    return result;
  };
  Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
  };
  Node.prototype._encode = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state['default'] !== null && state['default'] === data)
      return ;
    var result = this._encodeValue(data, reporter, parent);
    if (result === undefined)
      return ;
    if (this._skipDefault(result, reporter, parent))
      return ;
    return result;
  };
  Node.prototype._encodeValue = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state.parent === null)
      return state.children[0]._encode(data, reporter || new Reporter());
    var result = null;
    var present = true;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
      if (state['default'] !== null)
        data = state['default'];
      else
        return ;
    }
    var prevKey;
    var content = null;
    var primitive = false;
    if (state.any) {
      result = this._createEncoderBuffer(data);
    } else if (state.choice) {
      result = this._encodeChoice(data, reporter);
    } else if (state.children) {
      content = state.children.map(function(child) {
        if (child._baseState.tag === 'null_')
          return child._encode(null, reporter, data);
        if (child._baseState.key === null)
          return reporter.error('Child should have a key');
        var prevKey = reporter.enterKey(child._baseState.key);
        if (typeof data !== 'object')
          return reporter.error('Child expected, but input is not object');
        var res = child._encode(data[child._baseState.key], reporter, data);
        reporter.leaveKey(prevKey);
        return res;
      }, this).filter(function(child) {
        return child;
      });
      content = this._createEncoderBuffer(content);
    } else {
      if (state.tag === 'seqof' || state.tag === 'setof') {
        if (!(state.args && state.args.length === 1))
          return reporter.error('Too many args for : ' + state.tag);
        if (!Array.isArray(data))
          return reporter.error('seqof/setof, but data is not Array');
        var child = this.clone();
        child._baseState.implicit = null;
        content = this._createEncoderBuffer(data.map(function(item) {
          var state = this._baseState;
          return this._getUse(state.args[0], data)._encode(item, reporter);
        }, child));
      } else if (state.use !== null) {
        result = this._getUse(state.use, parent)._encode(data, reporter);
      } else {
        content = this._encodePrimitive(state.tag, data);
        primitive = true;
      }
    }
    var result;
    if (!state.any && state.choice === null) {
      var tag = state.implicit !== null ? state.implicit : state.tag;
      var cls = state.implicit === null ? 'universal' : 'context';
      if (tag === null) {
        if (state.use === null)
          reporter.error('Tag could be ommited only for .use()');
      } else {
        if (state.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
    }
    if (state.explicit !== null)
      result = this._encodeComposite(state.explicit, false, 'context', result);
    return result;
  };
  Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    var state = this._baseState;
    var node = state.choice[data.type];
    if (!node) {
      assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
  };
  Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    var state = this._baseState;
    if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
      return this._encodeStr(data, tag);
    else if (tag === 'objid' && state.args)
      return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    else if (tag === 'objid')
      return this._encodeObjid(data, null, null);
    else if (tag === 'gentime' || tag === 'utctime')
      return this._encodeTime(data, tag);
    else if (tag === 'null_')
      return this._encodeNull();
    else if (tag === 'int' || tag === 'enum')
      return this._encodeInt(data, state.args && state.reverseArgs[0]);
    else if (tag === 'bool')
      return this._encodeBool(data);
    else
      throw new Error('Unsupported tag: ' + tag);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:hash.js@1.0.3", ["npm:hash.js@1.0.3/lib/hash"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:hash.js@1.0.3/lib/hash");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-ecdh@2.0.1", ["npm:create-ecdh@2.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:create-ecdh@2.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1/browser", ["npm:public-encrypt@2.0.1/publicEncrypt", "npm:public-encrypt@2.0.1/privateDecrypt"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.publicEncrypt = require("npm:public-encrypt@2.0.1/publicEncrypt");
  exports.privateDecrypt = require("npm:public-encrypt@2.0.1/privateDecrypt");
  exports.privateEncrypt = function privateEncrypt(key, buf) {
    return exports.publicEncrypt(key, buf, true);
  };
  exports.publicDecrypt = function publicDecrypt(key, buf) {
    return exports.privateDecrypt(key, buf, true);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3", ["npm:rx@2.5.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:rx@2.5.3/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/index", ["npm:flux@2.0.3/lib/Dispatcher"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports.Dispatcher = require("npm:flux@2.0.3/lib/Dispatcher");
  global.define = __define;
  return module.exports;
});

System.register("npm:debug@2.2.0/browser", ["npm:debug@2.2.0/debug"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = require("npm:debug@2.2.0/debug");
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
  function useColors() {
    return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors)
      return args;
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match)
        return ;
      index++;
      if ('%c' === match) {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
    return args;
  }
  function log() {
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:buffer@3.2.2", ["npm:buffer@3.2.2/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:buffer@3.2.2/index");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:sha.js@2.4.2", ["npm:sha.js@2.4.2/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:sha.js@2.4.2/index");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-events@0.1.1", ["github:jspm/nodelibs-events@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-events@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:readable-stream@1.1.13/readable", ["npm:readable-stream@1.1.13/lib/_stream_readable", "npm:stream-browserify@1.0.0/index", "npm:readable-stream@1.1.13/lib/_stream_writable", "npm:readable-stream@1.1.13/lib/_stream_duplex", "npm:readable-stream@1.1.13/lib/_stream_transform", "npm:readable-stream@1.1.13/lib/_stream_passthrough"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = require("npm:readable-stream@1.1.13/lib/_stream_readable");
  exports.Stream = require("npm:stream-browserify@1.0.0/index");
  exports.Readable = exports;
  exports.Writable = require("npm:readable-stream@1.1.13/lib/_stream_writable");
  exports.Duplex = require("npm:readable-stream@1.1.13/lib/_stream_duplex");
  exports.Transform = require("npm:readable-stream@1.1.13/lib/_stream_transform");
  exports.PassThrough = require("npm:readable-stream@1.1.13/lib/_stream_passthrough");
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1/browser", ["npm:browserify-aes@1.0.1/encrypter", "npm:browserify-aes@1.0.1/decrypter", "npm:browserify-aes@1.0.1/modes"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var ciphers = require("npm:browserify-aes@1.0.1/encrypter");
  exports.createCipher = exports.Cipher = ciphers.createCipher;
  exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
  var deciphers = require("npm:browserify-aes@1.0.1/decrypter");
  exports.createDecipher = exports.Decipher = deciphers.createDecipher;
  exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
  var modes = require("npm:browserify-aes@1.0.1/modes");
  function getCiphers() {
    return Object.keys(modes);
  }
  exports.listCiphers = exports.getCiphers = getCiphers;
  global.define = __define;
  return module.exports;
});

System.register("npm:miller-rabin@2.0.1", ["npm:miller-rabin@2.0.1/lib/mr"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:miller-rabin@2.0.1/lib/mr");
  global.define = __define;
  return module.exports;
});

System.register("npm:vm-browserify@0.0.4", ["npm:vm-browserify@0.0.4/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:vm-browserify@0.0.4/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/base/index", ["npm:asn1.js@2.0.3/lib/asn1/base/reporter", "npm:asn1.js@2.0.3/lib/asn1/base/buffer", "npm:asn1.js@2.0.3/lib/asn1/base/buffer", "npm:asn1.js@2.0.3/lib/asn1/base/node"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var base = exports;
  base.Reporter = require("npm:asn1.js@2.0.3/lib/asn1/base/reporter").Reporter;
  base.DecoderBuffer = require("npm:asn1.js@2.0.3/lib/asn1/base/buffer").DecoderBuffer;
  base.EncoderBuffer = require("npm:asn1.js@2.0.3/lib/asn1/base/buffer").EncoderBuffer;
  base.Node = require("npm:asn1.js@2.0.3/lib/asn1/base/node");
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic/hmac-drbg", ["npm:hash.js@1.0.3", "npm:elliptic@3.0.4/lib/elliptic"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hash = require("npm:hash.js@1.0.3");
  var elliptic = require("npm:elliptic@3.0.4/lib/elliptic");
  var utils = elliptic.utils;
  var assert = utils.assert;
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this.reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc);
    var nonce = utils.toArray(options.nonce, options.nonceEnc);
    var pers = utils.toArray(options.pers, options.persEnc);
    assert(entropy.length >= (this.minEntropy / 8), 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  module.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }
    this._update(seed);
    this.reseed = 1;
    this.reseedInterval = 0x1000000000000;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0x00]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return ;
    this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils.toBuffer(entropy, entropyEnc);
    add = utils.toBuffer(add, addEnc);
    assert(entropy.length >= (this.minEntropy / 8), 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._update(entropy.concat(add || []));
    this.reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this.reseed > this.reseedInterval)
      throw new Error('Reseed is required');
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils.toArray(add, addEnc);
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this.reseed++;
    return utils.encode(res, enc);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:public-encrypt@2.0.1", ["npm:public-encrypt@2.0.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:public-encrypt@2.0.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3", ["npm:flux@2.0.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:flux@2.0.3/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:debug@2.2.0", ["npm:debug@2.2.0/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:debug@2.2.0/browser");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-buffer@0.1.0/index", ["npm:buffer@3.2.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : require("npm:buffer@3.2.2");
  global.define = __define;
  return module.exports;
});

System.register("npm:stream-browserify@1.0.0/index", ["github:jspm/nodelibs-events@0.1.1", "npm:inherits@2.0.1", "npm:readable-stream@1.1.13/readable", "npm:readable-stream@1.1.13/writable", "npm:readable-stream@1.1.13/duplex", "npm:readable-stream@1.1.13/transform", "npm:readable-stream@1.1.13/passthrough"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = Stream;
  var EE = require("github:jspm/nodelibs-events@0.1.1").EventEmitter;
  var inherits = require("npm:inherits@2.0.1");
  inherits(Stream, EE);
  Stream.Readable = require("npm:readable-stream@1.1.13/readable");
  Stream.Writable = require("npm:readable-stream@1.1.13/writable");
  Stream.Duplex = require("npm:readable-stream@1.1.13/duplex");
  Stream.Transform = require("npm:readable-stream@1.1.13/transform");
  Stream.PassThrough = require("npm:readable-stream@1.1.13/passthrough");
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return ;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return ;
      didOnEnd = true;
      if (typeof dest.destroy === 'function')
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-aes@1.0.1", ["npm:browserify-aes@1.0.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:browserify-aes@1.0.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:diffie-hellman@3.0.2/lib/generatePrime", ["npm:randombytes@2.0.1", "npm:bn.js@2.0.5", "npm:miller-rabin@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var randomBytes = require("npm:randombytes@2.0.1");
  module.exports = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN = require("npm:bn.js@2.0.5");
  var TWENTYFOUR = new BN(24);
  var MillerRabin = require("npm:miller-rabin@2.0.1");
  var millerRabin = new MillerRabin();
  var ONE = new BN(1);
  var TWO = new BN(2);
  var FIVE = new BN(5);
  var SIXTEEN = new BN(16);
  var EIGHT = new BN(8);
  var TEN = new BN(10);
  var THREE = new BN(3);
  var SEVEN = new BN(7);
  var ELEVEN = new BN(11);
  var FOUR = new BN(4);
  var TWELVE = new BN(12);
  var primes = null;
  function _getPrimes() {
    if (primes !== null)
      return primes;
    var limit = 0x100000;
    var res = [];
    res[0] = 2;
    for (var i = 1,
        k = 3; k < limit; k += 2) {
      var sqrt = Math.ceil(Math.sqrt(k));
      for (var j = 0; j < i && res[j] <= sqrt; j++)
        if (k % res[j] === 0)
          break;
      if (i !== j && res[j] <= sqrt)
        continue;
      res[i++] = k;
    }
    primes = res;
    return res;
  }
  function simpleSieve(p) {
    var primes = _getPrimes();
    for (var i = 0; i < primes.length; i++)
      if (p.modn(primes[i]) === 0) {
        if (p.cmpn(primes[i]) === 0) {
          return true;
        } else {
          return false;
        }
      }
    return true;
  }
  function fermatTest(p) {
    var red = BN.mont(p);
    return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
  }
  function findPrime(bits, gen) {
    if (bits < 16) {
      if (gen === 2 || gen === 5) {
        return new BN([0x8c, 0x7b]);
      } else {
        return new BN([0x8c, 0x27]);
      }
    }
    gen = new BN(gen);
    var runs,
        comp;
    function generateRandom(bits) {
      runs = -1;
      var out = new BN(randomBytes(Math.ceil(bits / 8)));
      while (out.bitLength() > bits) {
        out.ishrn(1);
      }
      if (out.isEven()) {
        out.iadd(ONE);
      }
      if (!out.testn(1)) {
        out.iadd(TWO);
      }
      if (!gen.cmp(TWO)) {
        while (out.mod(TWENTYFOUR).cmp(ELEVEN)) {
          out.iadd(FOUR);
        }
        comp = {
          major: [TWENTYFOUR],
          minor: [TWELVE]
        };
      } else if (!gen.cmp(FIVE)) {
        rem = out.mod(TEN);
        while (rem.cmp(THREE)) {
          out.iadd(FOUR);
          rem = out.mod(TEN);
        }
        comp = {
          major: [FOUR, SIXTEEN],
          minor: [TWO, EIGHT]
        };
      } else {
        comp = {
          major: [FOUR],
          minor: [TWO]
        };
      }
      return out;
    }
    var num = generateRandom(bits);
    var n2 = num.shrn(1);
    while (true) {
      while (num.bitLength() > bits) {
        num = generateRandom(bits);
        n2 = num.shrn(1);
      }
      runs++;
      if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
        return num;
      }
      num.iadd(comp.major[runs % comp.major.length]);
      n2.iadd(comp.minor[runs % comp.minor.length]);
    }
  }
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-vm@0.1.0/index", ["npm:vm-browserify@0.0.4"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('vm') : require("npm:vm-browserify@0.0.4");
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4/lib/elliptic", ["npm:elliptic@3.0.4/package.json!github:systemjs/plugin-json@0.1.0", "npm:elliptic@3.0.4/lib/elliptic/utils", "npm:brorand@1.0.5", "npm:elliptic@3.0.4/lib/elliptic/hmac-drbg", "npm:elliptic@3.0.4/lib/elliptic/curve/index", "npm:elliptic@3.0.4/lib/elliptic/curves", "npm:elliptic@3.0.4/lib/elliptic/ec/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var elliptic = exports;
  elliptic.version = require("npm:elliptic@3.0.4/package.json!github:systemjs/plugin-json@0.1.0").version;
  elliptic.utils = require("npm:elliptic@3.0.4/lib/elliptic/utils");
  elliptic.rand = require("npm:brorand@1.0.5");
  elliptic.hmacDRBG = require("npm:elliptic@3.0.4/lib/elliptic/hmac-drbg");
  elliptic.curve = require("npm:elliptic@3.0.4/lib/elliptic/curve/index");
  elliptic.curves = require("npm:elliptic@3.0.4/lib/elliptic/curves");
  elliptic.ec = require("npm:elliptic@3.0.4/lib/elliptic/ec/index");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-buffer@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:stream-browserify@1.0.0", ["npm:stream-browserify@1.0.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:stream-browserify@1.0.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:diffie-hellman@3.0.2/browser", ["npm:diffie-hellman@3.0.2/lib/generatePrime", "npm:diffie-hellman@3.0.2/lib/primes.json!github:systemjs/plugin-json@0.1.0", "npm:diffie-hellman@3.0.2/lib/dh", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var generatePrime = require("npm:diffie-hellman@3.0.2/lib/generatePrime");
    var primes = require("npm:diffie-hellman@3.0.2/lib/primes.json!github:systemjs/plugin-json@0.1.0");
    var DH = require("npm:diffie-hellman@3.0.2/lib/dh");
    function getDiffieHellman(mod) {
      var prime = new Buffer(primes[mod].prime, 'hex');
      var gen = new Buffer(primes[mod].gen, 'hex');
      return new DH(prime, gen);
    }
    function createDiffieHellman(prime, enc, generator, genc) {
      if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
        genc = generator;
        generator = enc;
        enc = undefined;
      }
      enc = enc || 'binary';
      genc = genc || 'binary';
      generator = generator || new Buffer([2]);
      if (!Buffer.isBuffer(generator)) {
        generator = new Buffer(generator, genc);
      }
      if (typeof prime === 'number') {
        return new DH(generatePrime(prime, generator), generator, true);
      }
      if (!Buffer.isBuffer(prime)) {
        prime = new Buffer(prime, enc);
      }
      return new DH(prime, generator, true);
    }
    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
    exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-vm@0.1.0", ["github:jspm/nodelibs-vm@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-vm@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:elliptic@3.0.4", ["npm:elliptic@3.0.4/lib/elliptic"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:elliptic@3.0.4/lib/elliptic");
  global.define = __define;
  return module.exports;
});

System.register("npm:randombytes@2.0.1/browser", ["github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var crypto = global.crypto || global.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      var bytes = new Buffer(size);
      crypto.getRandomValues(bytes);
      if (typeof cb === 'function') {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
    function oldBrowser() {
      throw new Error('secure random number generation not supported by this browser\n' + 'use chrome, FireFox or Internet Explorer 11');
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-stream@0.1.0/index", ["npm:stream-browserify@1.0.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('stream') : require("npm:stream-browserify@1.0.0");
  global.define = __define;
  return module.exports;
});

System.register("npm:diffie-hellman@3.0.2", ["npm:diffie-hellman@3.0.2/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:diffie-hellman@3.0.2/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1/api", ["npm:asn1.js@2.0.3/lib/asn1", "npm:inherits@2.0.1", "github:jspm/nodelibs-vm@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var asn1 = require("npm:asn1.js@2.0.3/lib/asn1");
  var inherits = require("npm:inherits@2.0.1");
  var api = exports;
  api.define = function define(name, body) {
    return new Entity(name, body);
  };
  function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
  }
  ;
  Entity.prototype._createNamed = function createNamed(base) {
    var named;
    try {
      named = require("github:jspm/nodelibs-vm@0.1.0").runInThisContext('(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})');
    } catch (e) {
      named = function(entity) {
        this._initNamed(entity);
      };
    }
    inherits(named, base);
    named.prototype._initNamed = function initnamed(entity) {
      base.call(this, entity);
    };
    return new named(this);
  };
  Entity.prototype._getDecoder = function _getDecoder(enc) {
    if (!this.decoders.hasOwnProperty(enc))
      this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
    return this.decoders[enc];
  };
  Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
  };
  Entity.prototype._getEncoder = function _getEncoder(enc) {
    if (!this.encoders.hasOwnProperty(enc))
      this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
    return this.encoders[enc];
  };
  Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:randombytes@2.0.1", ["npm:randombytes@2.0.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:randombytes@2.0.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-stream@0.1.0", ["github:jspm/nodelibs-stream@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-stream@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3/lib/asn1", ["npm:bn.js@2.0.5", "npm:asn1.js@2.0.3/lib/asn1/api", "npm:asn1.js@2.0.3/lib/asn1/base/index", "npm:asn1.js@2.0.3/lib/asn1/constants/index", "npm:asn1.js@2.0.3/lib/asn1/decoders/index", "npm:asn1.js@2.0.3/lib/asn1/encoders/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var asn1 = exports;
  asn1.bignum = require("npm:bn.js@2.0.5");
  asn1.define = require("npm:asn1.js@2.0.3/lib/asn1/api").define;
  asn1.base = require("npm:asn1.js@2.0.3/lib/asn1/base/index");
  asn1.constants = require("npm:asn1.js@2.0.3/lib/asn1/constants/index");
  asn1.decoders = require("npm:asn1.js@2.0.3/lib/asn1/decoders/index");
  asn1.encoders = require("npm:asn1.js@2.0.3/lib/asn1/encoders/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hash@1.1.1/browser", ["npm:inherits@2.0.1", "npm:create-hash@1.1.1/md5", "npm:ripemd160@1.0.1", "npm:sha.js@2.4.2", "github:jspm/nodelibs-stream@0.1.0", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var inherits = require("npm:inherits@2.0.1");
    var md5 = require("npm:create-hash@1.1.1/md5");
    var rmd160 = require("npm:ripemd160@1.0.1");
    var sha = require("npm:sha.js@2.4.2");
    var Transform = require("github:jspm/nodelibs-stream@0.1.0").Transform;
    function HashNoConstructor(hash) {
      Transform.call(this);
      this._hash = hash;
      this.buffers = [];
    }
    inherits(HashNoConstructor, Transform);
    HashNoConstructor.prototype._transform = function(data, _, next) {
      this.buffers.push(data);
      next();
    };
    HashNoConstructor.prototype._flush = function(next) {
      this.push(this.digest());
      next();
    };
    HashNoConstructor.prototype.update = function(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this.buffers.push(data);
      return this;
    };
    HashNoConstructor.prototype.digest = function(enc) {
      var buf = Buffer.concat(this.buffers);
      var r = this._hash(buf);
      this.buffers = null;
      return enc ? r.toString(enc) : r;
    };
    function Hash(hash) {
      Transform.call(this);
      this._hash = hash;
    }
    inherits(Hash, Transform);
    Hash.prototype._transform = function(data, enc, next) {
      if (enc)
        data = new Buffer(data, enc);
      this._hash.update(data);
      next();
    };
    Hash.prototype._flush = function(next) {
      this.push(this._hash.digest());
      this._hash = null;
      next();
    };
    Hash.prototype.update = function(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this._hash.update(data);
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var outData = this._hash.digest();
      return enc ? outData.toString(enc) : outData;
    };
    module.exports = function createHash(alg) {
      if ('md5' === alg)
        return new HashNoConstructor(md5);
      if ('rmd160' === alg)
        return new HashNoConstructor(rmd160);
      return new Hash(sha(alg));
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:asn1.js@2.0.3", ["npm:asn1.js@2.0.3/lib/asn1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:asn1.js@2.0.3/lib/asn1");
  global.define = __define;
  return module.exports;
});

System.register("npm:create-hash@1.1.1", ["npm:create-hash@1.1.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:create-hash@1.1.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1/asn1", ["npm:asn1.js@2.0.3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var asn1 = require("npm:asn1.js@2.0.3");
  var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('modulus').int(), this.key('publicExponent').int(), this.key('privateExponent').int(), this.key('prime1').int(), this.key('prime2').int(), this.key('exponent1').int(), this.key('exponent2').int(), this.key('coefficient').int());
  });
  exports.RSAPrivateKey = RSAPrivateKey;
  var RSAPublicKey = asn1.define('RSAPublicKey', function() {
    this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
  });
  exports.RSAPublicKey = RSAPublicKey;
  var PublicKey = asn1.define('SubjectPublicKeyInfo', function() {
    this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
  });
  exports.PublicKey = PublicKey;
  var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
    this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p').int(), this.key('q').int(), this.key('g').int()).optional());
  });
  var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
    this.seq().obj(this.key('version').int(), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
  });
  exports.PrivateKey = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
    this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters').int())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
  });
  exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
  var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('p').int(), this.key('q').int(), this.key('g').int(), this.key('pub_key').int(), this.key('priv_key').int());
  });
  exports.DSAPrivateKey = DSAPrivateKey;
  exports.DSAparam = asn1.define('DSAparam', function() {
    this.int();
  });
  var ECPrivateKey = asn1.define('ECPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
  });
  exports.ECPrivateKey = ECPrivateKey;
  var ECParameters = asn1.define('ECParameters', function() {
    this.choice({namedCurve: this.objid()});
  });
  exports.signature = asn1.define('signature', function() {
    this.seq().obj(this.key('r').int(), this.key('s').int());
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1/index", ["npm:parse-asn1@3.0.1/asn1", "npm:parse-asn1@3.0.1/aesid.json!github:systemjs/plugin-json@0.1.0", "npm:parse-asn1@3.0.1/fixProc", "npm:browserify-aes@1.0.1", "npm:pbkdf2@3.0.4", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var asn1 = require("npm:parse-asn1@3.0.1/asn1");
    var aesid = require("npm:parse-asn1@3.0.1/aesid.json!github:systemjs/plugin-json@0.1.0");
    var fixProc = require("npm:parse-asn1@3.0.1/fixProc");
    var ciphers = require("npm:browserify-aes@1.0.1");
    var compat = require("npm:pbkdf2@3.0.4");
    module.exports = parseKeys;
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
      }
      if (typeof buffer === 'string') {
        buffer = new Buffer(buffer);
      }
      var stripped = fixProc(buffer, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype,
          ndata;
      switch (type) {
        case 'PUBLIC KEY':
          ndata = asn1.PublicKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
            case '1.2.840.10045.2.1':
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: 'ec',
                data: ndata
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
              return {
                type: 'dsa',
                data: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'ENCRYPTED PRIVATE KEY':
          data = asn1.EncryptedPrivateKey.decode(data, 'der');
          data = decrypt(data, password);
        case 'PRIVATE KEY':
          ndata = asn1.PrivateKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
            case '1.2.840.10045.2.1':
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
              return {
                type: 'dsa',
                params: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'RSA PUBLIC KEY':
          return asn1.RSAPublicKey.decode(data, 'der');
        case 'RSA PRIVATE KEY':
          return asn1.RSAPrivateKey.decode(data, 'der');
        case 'DSA PRIVATE KEY':
          return {
            type: 'dsa',
            params: asn1.DSAPrivateKey.decode(data, 'der')
          };
        case 'EC PRIVATE KEY':
          data = asn1.ECPrivateKey.decode(data, 'der');
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error('unknown key type ' + type);
      }
    }
    parseKeys.signature = asn1.signature;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split('-')[1], 10) / 8;
      var key = compat.pbkdf2Sync(password, salt, iters, keylen);
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher.final());
      return Buffer.concat(out);
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:parse-asn1@3.0.1", ["npm:parse-asn1@3.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:parse-asn1@3.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2/sign", ["npm:parse-asn1@3.0.1", "npm:bn.js@2.0.5", "npm:elliptic@3.0.4", "npm:browserify-rsa@2.0.1", "npm:create-hmac@1.1.3", "npm:browserify-sign@3.0.2/curves", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var parseKeys = require("npm:parse-asn1@3.0.1");
    var BN = require("npm:bn.js@2.0.5");
    var elliptic = require("npm:elliptic@3.0.4");
    var crt = require("npm:browserify-rsa@2.0.1");
    var createHmac = require("npm:create-hmac@1.1.3");
    var curves = require("npm:browserify-sign@3.0.2/curves");
    module.exports = sign;
    function sign(hash, key, hashType, signType) {
      var priv = parseKeys(key);
      if (priv.curve) {
        if (signType !== 'ecdsa') {
          throw new Error('wrong private key type');
        }
        return ecSign(hash, priv);
      } else if (priv.type === 'dsa') {
        return dsaSign(hash, priv, hashType);
        if (signType !== 'dsa') {
          throw new Error('wrong private key type');
        }
      } else {
        if (signType !== 'rsa') {
          throw new Error('wrong private key type');
        }
      }
      var len = priv.modulus.byteLength();
      var pad = [0, 1];
      while (hash.length + pad.length + 1 < len) {
        pad.push(0xff);
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      var out = crt(pad, priv);
      return out;
    }
    function ecSign(hash, priv) {
      var curveId = curves[priv.curve.join('.')];
      if (!curveId)
        throw new Error('unknown curve ' + priv.curve.join('.'));
      var curve = new elliptic.ec(curveId);
      var key = curve.genKeyPair();
      key._importPrivate(priv.privateKey);
      var out = key.sign(hash);
      return new Buffer(out.toDER());
    }
    function dsaSign(hash, priv, algo) {
      var x = priv.params.priv_key;
      var p = priv.params.p;
      var q = priv.params.q;
      var montq = BN.mont(q);
      var g = priv.params.g;
      var r = new BN(0);
      var k;
      var H = bits2int(hash, q).mod(q);
      var s = false;
      var kv = getKey(x, q, hash, algo);
      while (s === false) {
        k = makeKey(q, kv, algo);
        r = makeR(g, k, p, q);
        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
        if (!s.cmpn(0)) {
          s = false;
          r = new BN(0);
        }
      }
      return toDER(r, s);
    }
    function toDER(r, s) {
      r = r.toArray();
      s = s.toArray();
      if (r[0] & 0x80)
        r = [0].concat(r);
      if (s[0] & 0x80)
        s = [0].concat(s);
      var total = r.length + s.length + 4;
      var res = [0x30, total, 0x02, r.length];
      res = res.concat(r, [0x02, s.length], s);
      return new Buffer(res);
    }
    module.exports.getKey = getKey;
    function getKey(x, q, hash, algo) {
      x = new Buffer(x.toArray());
      if (x.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - x.length);
        zeros.fill(0);
        x = Buffer.concat([zeros, x]);
      }
      var hlen = hash.length;
      var hbits = bits2octets(hash, q);
      var v = new Buffer(hlen);
      v.fill(1);
      var k = new Buffer(hlen);
      k.fill(0);
      k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      return {
        k: k,
        v: v
      };
    }
    function bits2int(obits, q) {
      var bits = new BN(obits);
      var shift = (obits.length << 3) - q.bitLength();
      if (shift > 0) {
        bits.ishrn(shift);
      }
      return bits;
    }
    function bits2octets(bits, q) {
      bits = bits2int(bits, q);
      bits = bits.mod(q);
      var out = new Buffer(bits.toArray());
      if (out.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - out.length);
        zeros.fill(0);
        out = Buffer.concat([zeros, out]);
      }
      return out;
    }
    module.exports.makeKey = makeKey;
    function makeKey(q, kv, algo) {
      var t;
      var k;
      while (true) {
        t = new Buffer('');
        while (t.length * 8 < q.bitLength()) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t = Buffer.concat([t, kv.v]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        if (k.cmp(q) === -1) {
          return k;
        }
      }
    }
    function makeR(g, k, p, q) {
      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2/browser", ["npm:browserify-sign@3.0.2/sign", "npm:browserify-sign@3.0.2/verify", "github:jspm/nodelibs-stream@0.1.0", "npm:inherits@2.0.1", "npm:browserify-sign@3.0.2/algos", "npm:create-hash@1.1.1", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var sign = require("npm:browserify-sign@3.0.2/sign");
    var verify = require("npm:browserify-sign@3.0.2/verify");
    var stream = require("github:jspm/nodelibs-stream@0.1.0");
    var inherits = require("npm:inherits@2.0.1");
    var _algos = require("npm:browserify-sign@3.0.2/algos");
    var createHash = require("npm:create-hash@1.1.1");
    var algos = {};
    Object.keys(_algos).forEach(function(key) {
      algos[key] = algos[key.toLowerCase()] = _algos[key];
    });
    exports.createSign = exports.Sign = createSign;
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    exports.createVerify = exports.Verify = createVerify;
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    inherits(Sign, stream.Writable);
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data)
        throw new Error('Unknown message digest');
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    Sign.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Sign.prototype.update = function update(data, enc) {
      if (typeof data === 'string')
        data = new Buffer(data, enc);
      this._hash.update(data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key, enc) {
      this.end();
      var hash = this._hash.digest();
      var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType);
      if (enc) {
        sig = sig.toString(enc);
      }
      return sig;
    };
    inherits(Verify, stream.Writable);
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data)
        throw new Error('Unknown message digest');
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    Verify.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Verify.prototype.update = function update(data, enc) {
      if (typeof data === 'string')
        data = new Buffer(data, enc);
      this._hash.update(data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key, sig, enc) {
      this.end();
      var hash = this._hash.digest();
      if (typeof sig === 'string')
        sig = new Buffer(sig, enc);
      return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType);
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:browserify-sign@3.0.2", ["npm:browserify-sign@3.0.2/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:browserify-sign@3.0.2/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:crypto-browserify@3.9.14/index", ["npm:randombytes@2.0.1", "npm:create-hash@1.1.1", "npm:create-hmac@1.1.3", "npm:browserify-sign@3.0.2/algos", "npm:pbkdf2@3.0.4", "npm:browserify-aes@1.0.1", "npm:diffie-hellman@3.0.2", "npm:browserify-sign@3.0.2", "npm:create-ecdh@2.0.1", "npm:public-encrypt@2.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require("npm:randombytes@2.0.1");
  exports.createHash = exports.Hash = require("npm:create-hash@1.1.1");
  exports.createHmac = exports.Hmac = require("npm:create-hmac@1.1.3");
  var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require("npm:browserify-sign@3.0.2/algos")));
  exports.getHashes = function() {
    return hashes;
  };
  var p = require("npm:pbkdf2@3.0.4");
  exports.pbkdf2 = p.pbkdf2;
  exports.pbkdf2Sync = p.pbkdf2Sync;
  var aes = require("npm:browserify-aes@1.0.1");
  ['Cipher', 'createCipher', 'Cipheriv', 'createCipheriv', 'Decipher', 'createDecipher', 'Decipheriv', 'createDecipheriv', 'getCiphers', 'listCiphers'].forEach(function(key) {
    exports[key] = aes[key];
  });
  var dh = require("npm:diffie-hellman@3.0.2");
  ['DiffieHellmanGroup', 'createDiffieHellmanGroup', 'getDiffieHellman', 'createDiffieHellman', 'DiffieHellman'].forEach(function(key) {
    exports[key] = dh[key];
  });
  var sign = require("npm:browserify-sign@3.0.2");
  ['createSign', 'Sign', 'createVerify', 'Verify'].forEach(function(key) {
    exports[key] = sign[key];
  });
  exports.createECDH = require("npm:create-ecdh@2.0.1");
  var publicEncrypt = require("npm:public-encrypt@2.0.1");
  ['publicEncrypt', 'privateEncrypt', 'publicDecrypt', 'privateDecrypt'].forEach(function(key) {
    exports[key] = publicEncrypt[key];
  });
  ;
  ['createCredentials'].forEach(function(name) {
    exports[name] = function() {
      throw new Error(['sorry, ' + name + ' is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
    };
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:crypto-browserify@3.9.14", ["npm:crypto-browserify@3.9.14/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:crypto-browserify@3.9.14/index");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-crypto@0.1.0/index", ["npm:crypto-browserify@3.9.14"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('crypto') : require("npm:crypto-browserify@3.9.14");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-crypto@0.1.0", ["github:jspm/nodelibs-crypto@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-crypto@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:reflect-metadata@0.1.0/Reflect", ["github:jspm/nodelibs-crypto@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var Reflect;
  (function(Reflect) {
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var __Metadata__ = new _WeakMap();
    function decorate(decorators, target, targetKey, targetDescriptor) {
      if (!IsUndefined(targetDescriptor)) {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsObject(target)) {
          throw new TypeError();
        } else if (IsUndefined(targetKey)) {
          throw new TypeError();
        } else if (!IsObject(targetDescriptor)) {
          throw new TypeError();
        }
        targetKey = ToPropertyKey(targetKey);
        return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
      } else if (!IsUndefined(targetKey)) {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsObject(target)) {
          throw new TypeError();
        }
        targetKey = ToPropertyKey(targetKey);
        return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
      } else {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsConstructor(target)) {
          throw new TypeError();
        }
        return DecorateConstructor(decorators, target);
      }
    }
    Reflect.decorate = decorate;
    function metadata(metadataKey, metadataValue) {
      function decorator(target, targetKey) {
        if (!IsUndefined(targetKey)) {
          if (!IsObject(target)) {
            throw new TypeError();
          }
          targetKey = ToPropertyKey(targetKey);
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
        } else {
          if (!IsConstructor(target)) {
            throw new TypeError();
          }
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);
        }
      }
      return decorator;
    }
    Reflect.metadata = metadata;
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    function hasMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    function hasOwnMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    function getMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    function getOwnMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    function getMetadataKeys(target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    function getOwnMetadataKeys(target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    function deleteMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
      if (IsUndefined(metadataMap)) {
        return false;
      }
      if (!metadataMap.delete(metadataKey)) {
        return false;
      }
      if (metadataMap.size > 0) {
        return true;
      }
      var targetMetadata = __Metadata__.get(target);
      targetMetadata.delete(targetKey);
      if (targetMetadata.size > 0) {
        return true;
      }
      __Metadata__.delete(target);
      return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated)) {
          if (!IsConstructor(decorated)) {
            throw new TypeError();
          }
          target = decorated;
        }
      }
      return target;
    }
    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated)) {
          if (!IsObject(decorated)) {
            throw new TypeError();
          }
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        decorator(target, propertyKey);
      }
    }
    function GetOrCreateMetadataMap(target, targetKey, create) {
      var targetMetadata = __Metadata__.get(target);
      if (!targetMetadata) {
        if (!create) {
          return undefined;
        }
        targetMetadata = new _Map();
        __Metadata__.set(target, targetMetadata);
      }
      var keyMetadata = targetMetadata.get(targetKey);
      if (!keyMetadata) {
        if (!create) {
          return undefined;
        }
        keyMetadata = new _Map();
        targetMetadata.set(targetKey, keyMetadata);
      }
      return keyMetadata;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) {
        return true;
      }
      var parent = GetPrototypeOf(O);
      if (parent !== null) {
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      }
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (metadataMap === undefined) {
        return false;
      }
      return Boolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) {
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      var parent = GetPrototypeOf(O);
      if (parent !== null) {
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      }
      return undefined;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (metadataMap === undefined) {
        return undefined;
      }
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = GetPrototypeOf(O);
      if (parent === null) {
        return ownKeys;
      }
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0) {
        return ownKeys;
      }
      if (ownKeys.length <= 0) {
        return parentKeys;
      }
      var set = new _Set();
      var keys = [];
      for (var _i = 0; _i < ownKeys.length; _i++) {
        var key = ownKeys[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0; _a < parentKeys.length; _a++) {
        var key = parentKeys[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(target, targetKey) {
      var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
      var keys = [];
      if (metadataMap) {
        metadataMap.forEach(function(_, key) {
          return keys.push(key);
        });
      }
      return keys;
    }
    function IsUndefined(x) {
      return x === undefined;
    }
    function IsArray(x) {
      return Array.isArray(x);
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function IsConstructor(x) {
      return typeof x === "function";
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function ToPropertyKey(value) {
      if (IsSymbol(value)) {
        return value;
      }
      return String(value);
    }
    function GetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype) {
        return proto;
      }
      if (proto !== functionPrototype) {
        return proto;
      }
      var prototype = O.prototype;
      var prototypeProto = Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype) {
        return proto;
      }
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function") {
        return proto;
      }
      if (constructor === O) {
        return proto;
      }
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      function Map() {
        this._keys = [];
        this._values = [];
        this._cache = cacheSentinel;
      }
      Map.prototype = {
        get size() {
          return this._keys.length;
        },
        has: function(key) {
          if (key === this._cache) {
            return true;
          }
          if (this._find(key) >= 0) {
            this._cache = key;
            return true;
          }
          return false;
        },
        get: function(key) {
          var index = this._find(key);
          if (index >= 0) {
            this._cache = key;
            return this._values[index];
          }
          return undefined;
        },
        set: function(key, value) {
          this.delete(key);
          this._keys.push(key);
          this._values.push(value);
          this._cache = key;
          return this;
        },
        delete: function(key) {
          var index = this._find(key);
          if (index >= 0) {
            this._keys.splice(index, 1);
            this._values.splice(index, 1);
            this._cache = cacheSentinel;
            return true;
          }
          return false;
        },
        clear: function() {
          this._keys.length = 0;
          this._values.length = 0;
          this._cache = cacheSentinel;
        },
        forEach: function(callback, thisArg) {
          var size = this.size;
          for (var i = 0; i < size; ++i) {
            var key = this._keys[i];
            var value = this._values[i];
            this._cache = key;
            callback.call(this, value, key, this);
          }
        },
        _find: function(key) {
          var keys = this._keys;
          var size = keys.length;
          for (var i = 0; i < size; ++i) {
            if (keys[i] === key) {
              return i;
            }
          }
          return -1;
        }
      };
      return Map;
    }
    function CreateSetPolyfill() {
      var cacheSentinel = {};
      function Set() {
        this._map = new _Map();
      }
      Set.prototype = {
        get size() {
          return this._map.length;
        },
        has: function(value) {
          return this._map.has(value);
        },
        add: function(value) {
          this._map.set(value, value);
          return this;
        },
        delete: function(value) {
          return this._map.delete(value);
        },
        clear: function() {
          this._map.clear();
        },
        forEach: function(callback, thisArg) {
          this._map.forEach(callback, thisArg);
        }
      };
      return Set;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var isNode = typeof global !== "undefined" && typeof module === "object" && typeof module.exports === "object" && typeof require === "function";
      var nodeCrypto = isNode && require("github:jspm/nodelibs-crypto@0.1.0");
      var hasOwn = Object.prototype.hasOwnProperty;
      var keys = {};
      var rootKey = CreateUniqueKey();
      function WeakMap() {
        this._key = CreateUniqueKey();
      }
      WeakMap.prototype = {
        has: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table) {
            return this._key in table;
          }
          return false;
        },
        get: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table) {
            return table[this._key];
          }
          return undefined;
        },
        set: function(target, value) {
          var table = GetOrCreateWeakMapTable(target, true);
          table[this._key] = value;
          return this;
        },
        delete: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table && this._key in table) {
            return delete table[this._key];
          }
          return false;
        },
        clear: function() {
          this._key = CreateUniqueKey();
        }
      };
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) {
          buffer[i] = Math.random() * 255 | 0;
        }
      }
      function GenRandomBytes(size) {
        if (nodeCrypto) {
          var data = nodeCrypto.randomBytes(size);
          return data;
        } else if (typeof Uint8Array === "function") {
          var data = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(data);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(data);
          } else {
            FillRandomBytes(data, size);
          }
          return data;
        } else {
          var data = new Array(size);
          FillRandomBytes(data, size);
          return data;
        }
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 0x4f | 0x40;
        data[8] = data[8] & 0xbf | 0x80;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8) {
            result += "-";
          }
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
      function CreateUniqueKey() {
        var key;
        do {
          key = "@@WeakMap@@" + CreateUUID();
        } while (hasOwn.call(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create) {
            return undefined;
          }
          Object.defineProperty(target, rootKey, {value: Object.create(null)});
        }
        return target[rootKey];
      }
      return WeakMap;
    }
    (function(__global) {
      if (typeof __global.Reflect !== "undefined") {
        if (__global.Reflect !== Reflect) {
          for (var p in Reflect) {
            __global.Reflect[p] = Reflect[p];
          }
        }
      } else {
        __global.Reflect = Reflect;
      }
    })(typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof global !== "undefined" ? global : Function("return this;")());
  })(Reflect || (Reflect = {}));
  global.define = __define;
  return module.exports;
});

System.register("npm:reflect-metadata@0.1.0", ["npm:reflect-metadata@0.1.0/Reflect"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:reflect-metadata@0.1.0/Reflect");
  global.define = __define;
  return module.exports;
});

System.register("rtts_assert/src/rtts_assert", [], function($__export) {
  "use strict";
  var __moduleName = "rtts_assert/src/rtts_assert";
  var _global,
      POSITION_NAME,
      primitives,
      genericType,
      string,
      boolean,
      number,
      currentStack,
      prop;
  function argPositionName(i) {
    var position = (i / 2) + 1;
    return POSITION_NAME[position] || (position + 'th');
  }
  function proxy() {}
  function assertArgumentTypes() {
    for (var params = [],
        $__0 = 0; $__0 < arguments.length; $__0++)
      params[$__0] = arguments[$__0];
    var actual,
        type;
    var currentArgErrors;
    var errors = [];
    var msg;
    for (var i = 0,
        l = params.length; i < l; i = i + 2) {
      actual = params[i];
      type = params[i + 1];
      currentArgErrors = [];
      if (!isType(actual, type, currentArgErrors)) {
        errors.push(argPositionName(i) + ' argument has to be an instance of ' + prettyPrint(type) + ', got ' + prettyPrint(actual));
        if (currentArgErrors.length) {
          errors.push(currentArgErrors);
        }
      }
    }
    if (errors.length) {
      throw new Error('Invalid arguments given!\n' + formatErrors(errors));
    }
  }
  function prettyPrint(value, depth) {
    if (typeof(depth) === 'undefined') {
      depth = 0;
    }
    if (depth++ > 3) {
      return '[...]';
    }
    if (typeof value === 'undefined') {
      return 'undefined';
    }
    if (typeof value === 'string') {
      return '"' + value + '"';
    }
    if (typeof value === 'boolean') {
      return value.toString();
    }
    if (value === null) {
      return 'null';
    }
    if (typeof value === 'object') {
      if (value.__assertName) {
        return value.__assertName;
      }
      if (value.map && typeof value.map === 'function') {
        return '[' + value.map((function(v) {
          return prettyPrint(v, depth);
        })).join(', ') + ']';
      }
      var properties = Object.keys(value);
      var suffix = '}';
      if (properties.length > 20) {
        properties.length = 20;
        suffix = ', ... }';
      }
      return '{' + properties.map((function(p) {
        return p + ': ' + prettyPrint(value[p], depth);
      })).join(', ') + suffix;
    }
    return value.__assertName || value.name || value.toString();
  }
  function isType(value, T, errors) {
    if (T && T.type) {
      T = T.type;
    }
    if (T === primitives.void) {
      return typeof value === 'undefined';
    }
    if (_isProxy(value)) {
      return true;
    }
    if (T === primitives.any || value === null) {
      return true;
    }
    if (T === primitives.string) {
      return typeof value === 'string';
    }
    if (T === primitives.number) {
      return typeof value === 'number';
    }
    if (T === primitives.boolean) {
      return typeof value === 'boolean';
    }
    if (typeof T.assert === 'function') {
      var parentStack = currentStack;
      var isValid;
      currentStack = errors;
      try {
        isValid = T.assert(value);
      } catch (e) {
        fail(e.message);
        isValid = false;
      }
      currentStack = parentStack;
      if (typeof isValid === 'undefined') {
        isValid = errors.length === 0;
      }
      return isValid;
    }
    return value instanceof T;
  }
  function _isProxy(obj) {
    if (!obj || !obj.constructor || !obj.constructor.annotations)
      return false;
    return obj.constructor.annotations.filter((function(a) {
      return a instanceof proxy;
    })).length > 0;
  }
  function formatErrors(errors) {
    var indent = arguments[1] !== (void 0) ? arguments[1] : '  ';
    return errors.map((function(e) {
      if (typeof e === 'string')
        return indent + '- ' + e;
      return formatErrors(e, indent + '  ');
    })).join('\n');
  }
  function type(actual, T) {
    var errors = [];
    if (!isType(actual, T, errors)) {
      var msg = 'Expected an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';
      if (errors.length) {
        msg += '\n' + formatErrors(errors);
      }
      throw new Error(msg);
    }
    return actual;
  }
  function returnType(actual, T) {
    var errors = [];
    if (!isType(actual, T, errors)) {
      var msg = 'Expected to return an instance of ' + prettyPrint(T) + ', got ' + prettyPrint(actual) + '!';
      if (errors.length) {
        msg += '\n' + formatErrors(errors);
      }
      throw new Error(msg);
    }
    return actual;
  }
  function arrayOf() {
    for (var types = [],
        $__1 = 0; $__1 < arguments.length; $__1++)
      types[$__1] = arguments[$__1];
    return assert.define('array of ' + types.map(prettyPrint).join('/'), function(value) {
      var $__3;
      if (assert(value).is(Array)) {
        for (var i = 0; i < value.length; i++) {
          ($__3 = assert(value[i])).is.apply($__3, $traceurRuntime.spread(types));
        }
      }
    });
  }
  function structure(definition) {
    var properties = Object.keys(definition);
    return assert.define('object with properties ' + properties.join(', '), function(value) {
      if (assert(value).is(Object)) {
        for (var i = 0; i < properties.length; i++) {
          var property = properties[i];
          assert(value[property]).is(definition[property]);
        }
      }
    });
  }
  function fail(message) {
    currentStack.push(message);
  }
  function define(classOrName, check) {
    var cls = classOrName;
    if (typeof classOrName === 'string') {
      cls = function() {};
      cls.__assertName = classOrName;
    }
    cls.assert = function(value) {
      return check(value);
    };
    return cls;
  }
  function assert(value) {
    return {is: function is() {
        var $__3;
        for (var types = [],
            $__2 = 0; $__2 < arguments.length; $__2++)
          types[$__2] = arguments[$__2];
        var allErrors = [];
        var errors;
        for (var i = 0; i < types.length; i++) {
          var type = types[i];
          errors = [];
          if (isType(value, type, errors)) {
            return true;
          }
          allErrors.push(prettyPrint(value) + ' is not instance of ' + prettyPrint(type));
          if (errors.length) {
            allErrors.push(errors);
          }
        }
        ($__3 = currentStack).push.apply($__3, $traceurRuntime.spread(allErrors));
        return false;
      }};
  }
  $__export("proxy", proxy);
  return {
    setters: [],
    execute: function() {
      _global = typeof window === 'object' ? window : global;
      POSITION_NAME = ['', '1st', '2nd', '3rd'];
      if (typeof $traceurRuntime === 'object') {
        primitives = $traceurRuntime.type;
        genericType = $traceurRuntime.genericType;
      } else {
        primitives = {
          any: {name: 'any'},
          boolean: {name: 'boolean'},
          number: {name: 'number'},
          string: {name: 'string'},
          symbol: {name: 'symbol'},
          void: {name: 'void'}
        };
        genericType = function(type, args) {
          return {
            type: type,
            args: args
          };
        };
      }
      Object.keys(primitives).forEach(function(name) {
        primitives[name].__assertName = name;
      });
      string = type.string = define('string', function(value) {
        return typeof value === 'string';
      });
      boolean = type.boolean = define('boolean', function(value) {
        return typeof value === 'boolean';
      });
      number = type.number = define('number', function(value) {
        return typeof value === 'number';
      });
      currentStack = [];
      assert.type = type;
      for (prop in primitives) {
        assert.type[prop] = primitives[prop];
      }
      assert.genericType = genericType;
      assert.argumentTypes = assertArgumentTypes;
      assert.returnType = returnType;
      assert.define = define;
      assert.fail = fail;
      assert.string = string;
      assert.number = number;
      assert.boolean = boolean;
      assert.arrayOf = arrayOf;
      assert.structure = structure;
      $__export("assert", assert);
    }
  };
});

System.register("src/dc/log-config.es6", ["npm:debug@2.2.0"], function($__export) {
  "use strict";
  var __moduleName = "src/dc/log-config.es6";
  var XDebug;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }],
    execute: function() {
      XDebug.enable(["DC.*"].join(', '));
      $__export('default', XDebug);
    }
  };
});

System.register("src/entity-forge/Verify.es6", ["npm:debug@2.2.0"], function($__export) {
  "use strict";
  var __moduleName = "src/entity-forge/Verify.es6";
  var XDebug,
      log,
      LazyVerify,
      Verify;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }],
    execute: function() {
      log = XDebug('DC.Verify');
      LazyVerify = (function() {
        function LazyVerify() {}
        return ($traceurRuntime.createClass)(LazyVerify, {}, {
          exists: function(value) {
            return !(value === null || value === undefined);
          },
          empty: function(value) {
            var empty = !LazyVerify.exists(value);
            if (!empty) {
              if (LazyVerify.isString(value)) {
                empty = LazyVerify.maxLength(value, 0);
              } else if (LazyVerify.isObject(value)) {
                empty = LazyVerify.emptyObject(value);
              }
            }
            return empty;
          },
          isObject: function(value) {
            return (typeof value === 'object' || value.constructor === Object);
          },
          isString: function(value) {
            return (typeof value === 'string' || value instanceof String);
          },
          isFunction: function(value) {
            return (typeof value === 'function' || value instanceof Function);
          },
          isArray: function(value) {
            return (typeof value === 'array' || value instanceof Array);
          },
          emptyObject: function(value) {
            return Object.getOwnPropertyNames(value).length === 0;
          },
          hasOnly: function(object) {
            var properties = arguments[1] !== (void 0) ? arguments[1] : [];
            var allowMissing = arguments[2] !== (void 0) ? arguments[2] : false;
            var keys = Object.keys(object);
            var has = {};
            var count = 0;
            keys.forEach((function(key) {
              has[key] = true;
              count++;
            }));
            var hasAllOfDems = properties.every((function(propKey) {
              count--;
              var x = has[propKey];
              return x === undefined || x === true;
            }));
            return (hasAllOfDems && (allowMissing ? count <= 0 : count === 0));
          },
          hasAll: function(object) {
            var properties = arguments[1] !== (void 0) ? arguments[1] : [];
            var keys = Object.keys(object);
            var has = {};
            keys.forEach((function(key) {
              has[key] = true;
            }));
            var hasAllOfDems = properties.every((function(propKey) {
              return has[propKey];
            }));
            return hasAllOfDems;
          },
          maxLength: function(value, max) {
            return value.length <= max;
          },
          minLength: function(value, min) {
            return value.length >= min;
          },
          isNumber: function(value) {
            return (typeof value === 'number' || value instanceof Number);
          },
          isInteger: function(value) {
            return (value % 1 === 0);
          },
          min: function(value, min) {
            return value >= min;
          },
          max: function(value, max) {
            return value <= max;
          },
          isBoolean: function(value) {
            return value === true || value === false;
          }
        });
      }());
      Verify = (function($__super) {
        function Verify() {
          $traceurRuntime.superConstructor(Verify).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(Verify, {}, {
          isString: function(value) {
            var allowEmpty = arguments[1] !== (void 0) ? arguments[1] : false;
            return LazyVerify.empty(value) ? allowEmpty === true : LazyVerify.isString(value);
          },
          maxLength: function(value, max) {
            return Verify.isString(value) && LazyVerify.maxLength(value, max);
          },
          minLength: function(value, min) {
            return Verify.isString(value) && LazyVerify.minLength(value, min);
          },
          isNumber: function(value) {
            return LazyVerify.exists(value) && LazyVerify.isNumber(value);
          },
          isInteger: function(value) {
            return Verify.isNumber(value) && LazyVerify.isInteger(value);
          },
          min: function(value, min) {
            return Verify.isNumber(value) && LazyVerify.min(value, min);
          },
          max: function(value, max) {
            return Verify.isNumber(value) && LazyVerify.max(value, max);
          },
          isFunction: function(value) {
            return LazyVerify.exists(value) && LazyVerify.isFunction(value);
          },
          isArray: function(value) {
            return LazyVerify.exists(value) && LazyVerify.isArray(value);
          }
        }, $__super);
      }(LazyVerify));
      $__export("LazyVerify", LazyVerify), $__export("Verify", Verify);
    }
  };
});

System.register("angular2/src/facade/lang", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/lang";
  var _global,
      __esModule,
      Type,
      Math,
      Date,
      assertionsEnabled_,
      int,
      CONST,
      ABSTRACT,
      IMPLEMENTS,
      StringWrapper,
      StringJoiner,
      NumberParseError,
      NumberWrapper,
      RegExp,
      RegExpWrapper,
      RegExpMatcherWrapper,
      FunctionWrapper,
      BaseException,
      Json,
      DateWrapper;
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isType(obj) {
    return isFunction(obj);
  }
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    return token.toString();
  }
  function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
  }
  function getMapKey(value) {
    return value;
  }
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function assertionsEnabled() {
    return assertionsEnabled_;
  }
  function print(obj) {
    if (obj instanceof Error) {
      console.log(obj.stack);
    } else {
      console.log(obj);
    }
  }
  $__export("isPresent", isPresent);
  $__export("isBlank", isBlank);
  $__export("isString", isString);
  $__export("isFunction", isFunction);
  $__export("isType", isType);
  $__export("stringify", stringify);
  $__export("looseIdentical", looseIdentical);
  $__export("getMapKey", getMapKey);
  $__export("normalizeBlank", normalizeBlank);
  $__export("isJsObject", isJsObject);
  $__export("assertionsEnabled", assertionsEnabled);
  $__export("print", print);
  return {
    setters: [],
    execute: function() {
      _global = typeof window === 'undefined' ? global : window;
      $__export("global", _global);
      __esModule = true;
      $__export("__esModule", __esModule);
      Type = Function;
      $__export("Type", Type);
      Math = _global.Math;
      $__export("Math", Math);
      Date = _global.Date;
      $__export("Date", Date);
      assertionsEnabled_ = typeof assert !== 'undefined';
      if (assertionsEnabled_) {
        _global.assert = assert;
        $__export("int", int = assert.define('int', function(value) {
          return typeof value === 'number' && value % 1 === 0;
        }));
      } else {
        $__export("int", int = {});
        _global.assert = function() {};
      }
      $__export("int", int);
      CONST = (function() {
        function CONST() {}
        return ($traceurRuntime.createClass)(CONST, {}, {});
      }());
      $__export("CONST", CONST);
      ABSTRACT = (function() {
        function ABSTRACT() {}
        return ($traceurRuntime.createClass)(ABSTRACT, {}, {});
      }());
      $__export("ABSTRACT", ABSTRACT);
      IMPLEMENTS = (function() {
        function IMPLEMENTS() {}
        return ($traceurRuntime.createClass)(IMPLEMENTS, {}, {});
      }());
      $__export("IMPLEMENTS", IMPLEMENTS);
      StringWrapper = (function() {
        function StringWrapper() {}
        return ($traceurRuntime.createClass)(StringWrapper, {}, {
          fromCharCode: function(code) {
            return String.fromCharCode(code);
          },
          charCodeAt: function(s, index) {
            return s.charCodeAt(index);
          },
          split: function(s, regExp) {
            return s.split(regExp);
          },
          equals: function(s, s2) {
            return s === s2;
          },
          replace: function(s, from, replace) {
            return s.replace(from, replace);
          },
          replaceAll: function(s, from, replace) {
            return s.replace(from, replace);
          },
          startsWith: function(s, start) {
            return s.startsWith(start);
          },
          substring: function(s, start) {
            var end = arguments[2] !== (void 0) ? arguments[2] : null;
            return s.substring(start, end === null ? undefined : end);
          },
          replaceAllMapped: function(s, from, cb) {
            return s.replace(from, function() {
              for (var matches = [],
                  $__1 = 0; $__1 < arguments.length; $__1++)
                matches[$__1] = arguments[$__1];
              matches.splice(-2, 2);
              return cb(matches);
            });
          },
          contains: function(s, substr) {
            return s.indexOf(substr) != -1;
          }
        });
      }());
      $__export("StringWrapper", StringWrapper);
      StringJoiner = (function() {
        function StringJoiner() {
          var parts = arguments[0] !== (void 0) ? arguments[0] : [];
          this.parts = parts;
        }
        return ($traceurRuntime.createClass)(StringJoiner, {
          add: function(part) {
            this.parts.push(part);
          },
          toString: function() {
            return this.parts.join("");
          }
        }, {});
      }());
      $__export("StringJoiner", StringJoiner);
      NumberParseError = (function() {
        function NumberParseError(message) {
          this.message = message;
        }
        return ($traceurRuntime.createClass)(NumberParseError, {toString: function() {
            return this.message;
          }}, {});
      }());
      $__export("NumberParseError", NumberParseError);
      NumberWrapper = (function() {
        function NumberWrapper() {}
        return ($traceurRuntime.createClass)(NumberWrapper, {}, {
          toFixed: function(n, fractionDigits) {
            return n.toFixed(fractionDigits);
          },
          equal: function(a, b) {
            return a === b;
          },
          parseIntAutoRadix: function(text) {
            var result = parseInt(text);
            if (isNaN(result)) {
              throw new NumberParseError("Invalid integer literal when parsing " + text);
            }
            return result;
          },
          parseInt: function(text, radix) {
            if (radix == 10) {
              if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else if (radix == 16) {
              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else {
              var result = parseInt(text, radix);
              if (!isNaN(result)) {
                return result;
              }
            }
            throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
          },
          parseFloat: function(text) {
            return parseFloat(text);
          },
          get NaN() {
            return NaN;
          },
          isNaN: function(value) {
            return isNaN(value);
          },
          isInteger: function(value) {
            return Number.isInteger(value);
          }
        });
      }());
      $__export("NumberWrapper", NumberWrapper);
      RegExp = _global.RegExp;
      $__export("RegExp", RegExp);
      RegExpWrapper = (function() {
        function RegExpWrapper() {}
        return ($traceurRuntime.createClass)(RegExpWrapper, {}, {
          create: function(regExpStr) {
            var flags = arguments[1] !== (void 0) ? arguments[1] : '';
            flags = flags.replace(/g/g, '');
            return new _global.RegExp(regExpStr, flags + 'g');
          },
          firstMatch: function(regExp, input) {
            regExp.lastIndex = 0;
            return regExp.exec(input);
          },
          matcher: function(regExp, input) {
            regExp.lastIndex = 0;
            return {
              re: regExp,
              input: input
            };
          }
        });
      }());
      $__export("RegExpWrapper", RegExpWrapper);
      RegExpMatcherWrapper = (function() {
        function RegExpMatcherWrapper() {}
        return ($traceurRuntime.createClass)(RegExpMatcherWrapper, {}, {next: function(matcher) {
            return matcher.re.exec(matcher.input);
          }});
      }());
      $__export("RegExpMatcherWrapper", RegExpMatcherWrapper);
      FunctionWrapper = (function() {
        function FunctionWrapper() {}
        return ($traceurRuntime.createClass)(FunctionWrapper, {}, {apply: function(fn, posArgs) {
            return fn.apply(null, posArgs);
          }});
      }());
      $__export("FunctionWrapper", FunctionWrapper);
      BaseException = Error;
      $__export("BaseException", BaseException);
      Json = _global.JSON;
      $__export("Json", Json);
      DateWrapper = (function() {
        function DateWrapper() {}
        return ($traceurRuntime.createClass)(DateWrapper, {}, {
          fromMillis: function(ms) {
            return new Date(ms);
          },
          toMillis: function(date) {
            return date.getTime();
          },
          now: function() {
            return new Date();
          },
          toJson: function(date) {
            return date.toJSON();
          }
        });
      }());
      $__export("DateWrapper", DateWrapper);
    }
  };
});

System.register("angular2/src/facade/collection", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/collection";
  var isJsObject,
      global,
      __esModule,
      List,
      Map,
      Set,
      StringMap,
      MapWrapper,
      StringMapWrapper,
      ListWrapper,
      SetWrapper;
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return ListWrapper.isList(obj) || (!(obj instanceof Map) && Symbol.iterator in obj);
  }
  function iterateListLike(obj, fn) {
    if (ListWrapper.isList(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[Symbol.iterator]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  $__export("isListLikeIterable", isListLikeIterable);
  $__export("iterateListLike", iterateListLike);
  return {
    setters: [function($__m) {
      isJsObject = $__m.isJsObject;
      global = $__m.global;
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      List = global.Array;
      $__export("List", List);
      Map = global.Map;
      $__export("Map", Map);
      Set = global.Set;
      $__export("Set", Set);
      StringMap = global.Object;
      $__export("StringMap", StringMap);
      MapWrapper = (function() {
        function MapWrapper() {}
        return ($traceurRuntime.createClass)(MapWrapper, {}, {
          create: function() {
            return new Map();
          },
          clone: function(m) {
            return new Map(m);
          },
          createFromStringMap: function(stringMap) {
            var result = MapWrapper.create();
            for (var prop in stringMap) {
              MapWrapper.set(result, prop, stringMap[prop]);
            }
            return result;
          },
          createFromPairs: function(pairs) {
            return new Map(pairs);
          },
          get: function(m, k) {
            return m.get(k);
          },
          set: function(m, k, v) {
            m.set(k, v);
          },
          contains: function(m, k) {
            return m.has(k);
          },
          forEach: function(m, fn) {
            m.forEach(fn);
          },
          size: function(m) {
            return m.size;
          },
          delete: function(m, k) {
            m.delete(k);
          },
          clear: function(m) {
            m.clear();
          },
          clearValues: function(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
              m.set(k.value, null);
            }
          },
          iterable: function(m) {
            return m;
          },
          keys: function(m) {
            return m.keys();
          },
          values: function(m) {
            return m.values();
          }
        });
      }());
      $__export("MapWrapper", MapWrapper);
      StringMapWrapper = (function() {
        function StringMapWrapper() {}
        return ($traceurRuntime.createClass)(StringMapWrapper, {}, {
          create: function() {
            return {};
          },
          contains: function(map, key) {
            return map.hasOwnProperty(key);
          },
          get: function(map, key) {
            return map.hasOwnProperty(key) ? map[key] : undefined;
          },
          set: function(map, key, value) {
            map[key] = value;
          },
          isEmpty: function(map) {
            for (var prop in map) {
              return false;
            }
            return true;
          },
          delete: function(map, key) {
            delete map[key];
          },
          forEach: function(map, callback) {
            for (var prop in map) {
              if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
              }
            }
          },
          merge: function(m1, m2) {
            var m = {};
            for (var attr in m1) {
              if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
              }
            }
            for (var attr in m2) {
              if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
              }
            }
            return m;
          }
        });
      }());
      $__export("StringMapWrapper", StringMapWrapper);
      ListWrapper = (function() {
        function ListWrapper() {}
        return ($traceurRuntime.createClass)(ListWrapper, {}, {
          create: function() {
            return new List();
          },
          createFixedSize: function(size) {
            return new List(size);
          },
          get: function(m, k) {
            return m[k];
          },
          set: function(m, k, v) {
            m[k] = v;
          },
          clone: function(array) {
            return array.slice(0);
          },
          map: function(array, fn) {
            return array.map(fn);
          },
          forEach: function(array, fn) {
            for (var i = 0; i < array.length; i++) {
              fn(array[i]);
            }
          },
          push: function(array, el) {
            array.push(el);
          },
          first: function(array) {
            if (!array)
              return null;
            return array[0];
          },
          last: function(array) {
            if (!array || array.length == 0)
              return null;
            return array[array.length - 1];
          },
          find: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return list[i];
            }
            return null;
          },
          indexOf: function(array, value) {
            var startIndex = arguments[2] !== (void 0) ? arguments[2] : -1;
            return array.indexOf(value, startIndex);
          },
          reduce: function(list, fn, init) {
            return list.reduce(fn, init);
          },
          filter: function(array, pred) {
            return array.filter(pred);
          },
          any: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return true;
            }
            return false;
          },
          contains: function(list, el) {
            return list.indexOf(el) !== -1;
          },
          reversed: function(array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
          },
          concat: function(a, b) {
            return a.concat(b);
          },
          isList: function(list) {
            return Array.isArray(list);
          },
          insert: function(list, index, value) {
            list.splice(index, 0, value);
          },
          removeAt: function(list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
          },
          removeAll: function(list, items) {
            for (var i = 0; i < items.length; ++i) {
              var index = list.indexOf(items[i]);
              list.splice(index, 1);
            }
          },
          removeLast: function(list) {
            return list.pop();
          },
          remove: function(list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
              list.splice(index, 1);
              return true;
            }
            return false;
          },
          clear: function(list) {
            list.splice(0, list.length);
          },
          join: function(list, s) {
            return list.join(s);
          },
          isEmpty: function(list) {
            return list.length == 0;
          },
          fill: function(list, value) {
            var start = arguments[2] !== (void 0) ? arguments[2] : 0;
            var end = arguments[3] !== (void 0) ? arguments[3] : null;
            list.fill(value, start, end === null ? undefined : end);
          },
          equals: function(a, b) {
            if (a.length != b.length)
              return false;
            for (var i = 0; i < a.length; ++i) {
              if (a[i] !== b[i])
                return false;
            }
            return true;
          },
          slice: function(l) {
            var from = arguments[1] !== (void 0) ? arguments[1] : 0;
            var to = arguments[2] !== (void 0) ? arguments[2] : null;
            return l.slice(from, to === null ? undefined : to);
          },
          splice: function(l, from, length) {
            return l.splice(from, length);
          },
          sort: function(l, compareFn) {
            l.sort(compareFn);
          }
        });
      }());
      $__export("ListWrapper", ListWrapper);
      SetWrapper = (function() {
        function SetWrapper() {}
        return ($traceurRuntime.createClass)(SetWrapper, {}, {
          createFromList: function(lst) {
            return new Set(lst);
          },
          has: function(s, key) {
            return s.has(key);
          }
        });
      }());
      $__export("SetWrapper", SetWrapper);
    }
  };
});

System.register("angular2/src/di/annotations", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/annotations";
  var CONST,
      Inject,
      InjectPromise,
      InjectLazy,
      Optional,
      DependencyAnnotation,
      Injectable;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      Inject = (function() {
        function Inject(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(Inject, {}, {});
      }());
      $__export("Inject", Inject);
      Object.defineProperty(Inject, "annotations", {get: function() {
          return [new CONST()];
        }});
      InjectPromise = (function() {
        function InjectPromise(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(InjectPromise, {}, {});
      }());
      $__export("InjectPromise", InjectPromise);
      Object.defineProperty(InjectPromise, "annotations", {get: function() {
          return [new CONST()];
        }});
      InjectLazy = (function() {
        function InjectLazy(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(InjectLazy, {}, {});
      }());
      $__export("InjectLazy", InjectLazy);
      Object.defineProperty(InjectLazy, "annotations", {get: function() {
          return [new CONST()];
        }});
      Optional = (function() {
        function Optional() {}
        return ($traceurRuntime.createClass)(Optional, {}, {});
      }());
      $__export("Optional", Optional);
      Object.defineProperty(Optional, "annotations", {get: function() {
          return [new CONST()];
        }});
      DependencyAnnotation = (function() {
        function DependencyAnnotation() {}
        return ($traceurRuntime.createClass)(DependencyAnnotation, {get token() {
            return null;
          }}, {});
      }());
      $__export("DependencyAnnotation", DependencyAnnotation);
      Object.defineProperty(DependencyAnnotation, "annotations", {get: function() {
          return [new CONST()];
        }});
      Injectable = (function() {
        function Injectable() {}
        return ($traceurRuntime.createClass)(Injectable, {}, {});
      }());
      $__export("Injectable", Injectable);
      Object.defineProperty(Injectable, "annotations", {get: function() {
          return [new CONST()];
        }});
    }
  };
});

System.register("angular2/src/reflection/types", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/types";
  var __esModule;
  return {
    setters: [],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      $__export("SetterFn", Function);
      $__export("GetterFn", Function);
      $__export("MethodFn", Function);
    }
  };
});

System.register("angular2/src/reflection/reflection_capabilities", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection_capabilities";
  var isPresent,
      global,
      ListWrapper,
      __esModule,
      ReflectionCapabilities;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      global = $__m.global;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      ReflectionCapabilities = (function() {
        function ReflectionCapabilities() {}
        return ($traceurRuntime.createClass)(ReflectionCapabilities, {
          factory: function(type) {
            switch (type.length) {
              case 0:
                return function() {
                  return new type();
                };
              case 1:
                return function(a1) {
                  return new type(a1);
                };
              case 2:
                return function(a1, a2) {
                  return new type(a1, a2);
                };
              case 3:
                return function(a1, a2, a3) {
                  return new type(a1, a2, a3);
                };
              case 4:
                return function(a1, a2, a3, a4) {
                  return new type(a1, a2, a3, a4);
                };
              case 5:
                return function(a1, a2, a3, a4, a5) {
                  return new type(a1, a2, a3, a4, a5);
                };
              case 6:
                return function(a1, a2, a3, a4, a5, a6) {
                  return new type(a1, a2, a3, a4, a5, a6);
                };
              case 7:
                return function(a1, a2, a3, a4, a5, a6, a7) {
                  return new type(a1, a2, a3, a4, a5, a6, a7);
                };
              case 8:
                return function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return new type(a1, a2, a3, a4, a5, a6, a7, a8);
                };
              case 9:
                return function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return new type(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                };
              case 10:
                return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                  return new type(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                };
            }
            ;
            throw new Error("Factory cannot take more than 10 arguments");
          },
          _zipTypesAndAnnotaions: function(paramTypes, paramAnnotations) {
            var result = ListWrapper.createFixedSize(paramTypes.length);
            for (var i = 0; i < result.length; i++) {
              if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
              } else {
                result[i] = [];
              }
              if (isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
              }
            }
            return result;
          },
          parameters: function(typeOfFunc) {
            if (isPresent(typeOfFunc.parameters)) {
              return typeOfFunc.parameters;
            }
            if (isPresent(global.Reflect) && isPresent(global.Reflect.getMetadata)) {
              var paramAnnotations = global.Reflect.getMetadata('parameters', typeOfFunc);
              var paramTypes = global.Reflect.getMetadata('design:paramtypes', typeOfFunc);
              if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
              }
            }
            return ListWrapper.createFixedSize(typeOfFunc.length);
          },
          annotations: function(typeOfFunc) {
            if (isPresent(typeOfFunc.annotations)) {
              return typeOfFunc.annotations;
            }
            if (isPresent(global.Reflect) && isPresent(global.Reflect.getMetadata)) {
              var annotations = global.Reflect.getMetadata('annotations', typeOfFunc);
              if (isPresent(annotations))
                return annotations;
            }
            return [];
          },
          getter: function(name) {
            return new Function('o', 'return o.' + name + ';');
          },
          setter: function(name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
          },
          method: function(name) {
            var functionBody = ("if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);");
            return new Function('o', 'args', functionBody);
          }
        }, {});
      }());
      $__export("ReflectionCapabilities", ReflectionCapabilities);
    }
  };
});

System.register("angular2/src/di/key", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/key";
  var MapWrapper,
      stringify,
      Key,
      KeyRegistry,
      _globalKeyRegistry;
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
    }],
    execute: function() {
      Key = (function() {
        function Key(token, id) {
          this.token = token;
          this.id = id;
        }
        return ($traceurRuntime.createClass)(Key, {get displayName() {
            return stringify(this.token);
          }}, {
          get: function(token) {
            return _globalKeyRegistry.get(token);
          },
          get numberOfKeys() {
            return _globalKeyRegistry.numberOfKeys;
          }
        });
      }());
      $__export("Key", Key);
      KeyRegistry = (function() {
        function KeyRegistry() {
          this._allKeys = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(KeyRegistry, {
          get: function(token) {
            if (token instanceof Key)
              return token;
            if (MapWrapper.contains(this._allKeys, token)) {
              return MapWrapper.get(this._allKeys, token);
            }
            var newKey = new Key(token, Key.numberOfKeys);
            MapWrapper.set(this._allKeys, token, newKey);
            return newKey;
          },
          get numberOfKeys() {
            return MapWrapper.size(this._allKeys);
          }
        }, {});
      }());
      $__export("KeyRegistry", KeyRegistry);
      _globalKeyRegistry = new KeyRegistry();
    }
  };
});

System.register("angular2/src/di/exceptions", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/exceptions";
  var ListWrapper,
      List,
      stringify,
      AbstractBindingError,
      NoBindingError,
      AsyncBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      NoAnnotationError;
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (ListWrapper.contains(res, keys[i])) {
        ListWrapper.push(res, keys[i]);
        return res;
      } else {
        ListWrapper.push(res, keys[i]);
      }
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
      var tokenStrs = ListWrapper.map(reversed, (function(k) {
        return stringify(k.token);
      }));
      return " (" + tokenStrs.join(' -> ') + ")";
    } else {
      return "";
    }
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      stringify = $__m.stringify;
    }],
    execute: function() {
      Object.defineProperty(findFirstClosedCycle, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(constructResolvingPath, "parameters", {get: function() {
          return [[List]];
        }});
      AbstractBindingError = (function($__super) {
        function AbstractBindingError(key, constructResolvingMessage) {
          $traceurRuntime.superConstructor(AbstractBindingError).call(this);
          this.keys = [key];
          this.constructResolvingMessage = constructResolvingMessage;
          this.message = this.constructResolvingMessage(this.keys);
        }
        return ($traceurRuntime.createClass)(AbstractBindingError, {
          addKey: function(key) {
            ListWrapper.push(this.keys, key);
            this.message = this.constructResolvingMessage(this.keys);
          },
          toString: function() {
            return this.message;
          }
        }, {}, $__super);
      }(Error));
      $__export("AbstractBindingError", AbstractBindingError);
      Object.defineProperty(AbstractBindingError, "parameters", {get: function() {
          return [[], [Function]];
        }});
      NoBindingError = (function($__super) {
        function NoBindingError(key) {
          $traceurRuntime.superConstructor(NoBindingError).call(this, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("No provider for " + first + "!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(NoBindingError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("NoBindingError", NoBindingError);
      AsyncBindingError = (function($__super) {
        function AsyncBindingError(key) {
          $traceurRuntime.superConstructor(AsyncBindingError).call(this, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("Cannot instantiate " + first + " synchronously. ") + ("It is provided as a promise!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(AsyncBindingError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("AsyncBindingError", AsyncBindingError);
      CyclicDependencyError = (function($__super) {
        function CyclicDependencyError(key) {
          $traceurRuntime.superConstructor(CyclicDependencyError).call(this, key, function(keys) {
            return ("Cannot instantiate cyclic dependency!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(CyclicDependencyError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("CyclicDependencyError", CyclicDependencyError);
      InstantiationError = (function($__super) {
        function InstantiationError(cause, key) {
          $traceurRuntime.superConstructor(InstantiationError).call(this, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("Error during instantiation of " + first + "!" + constructResolvingPath(keys) + ".") + (" ORIGINAL ERROR: " + cause);
          });
          this.cause = cause;
          this.causeKey = key;
        }
        return ($traceurRuntime.createClass)(InstantiationError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("InstantiationError", InstantiationError);
      InvalidBindingError = (function($__super) {
        function InvalidBindingError(binding) {
          $traceurRuntime.superConstructor(InvalidBindingError).call(this);
          this.message = ("Invalid binding - only instances of Binding and Type are allowed, got: " + binding);
        }
        return ($traceurRuntime.createClass)(InvalidBindingError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      $__export("InvalidBindingError", InvalidBindingError);
      NoAnnotationError = (function($__super) {
        function NoAnnotationError(typeOrFunc) {
          $traceurRuntime.superConstructor(NoAnnotationError).call(this);
          this.message = ("Cannot resolve all parameters for " + stringify(typeOrFunc) + ".") + " Make sure they all have valid type or annotations.";
        }
        return ($traceurRuntime.createClass)(NoAnnotationError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      $__export("NoAnnotationError", NoAnnotationError);
    }
  };
});

System.register("angular2/src/di/opaque_token", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/opaque_token";
  var OpaqueToken;
  return {
    setters: [],
    execute: function() {
      OpaqueToken = (function() {
        function OpaqueToken(desc) {
          this._desc = ("Token(" + desc + ")");
        }
        return ($traceurRuntime.createClass)(OpaqueToken, {toString: function() {
            return this._desc;
          }}, {});
      }());
      $__export("OpaqueToken", OpaqueToken);
      Object.defineProperty(OpaqueToken, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/parser/parser", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/lexer", "angular2/src/reflection/reflection", "angular2/src/change_detection/parser/ast"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/parser";
  var Injectable,
      int,
      isBlank,
      isPresent,
      BaseException,
      StringWrapper,
      RegExpWrapper,
      ListWrapper,
      List,
      Lexer,
      EOF,
      Token,
      $PERIOD,
      $COLON,
      $SEMICOLON,
      $LBRACKET,
      $RBRACKET,
      $COMMA,
      $LBRACE,
      $RBRACE,
      $LPAREN,
      $RPAREN,
      reflector,
      Reflector,
      AST,
      EmptyExpr,
      ImplicitReceiver,
      AccessMember,
      LiteralPrimitive,
      Expression,
      Binary,
      PrefixNot,
      Conditional,
      Pipe,
      Assignment,
      Chain,
      KeyedAccess,
      LiteralArray,
      LiteralMap,
      Interpolation,
      MethodCall,
      FunctionCall,
      TemplateBindings,
      TemplateBinding,
      ASTWithSource,
      _implicitReceiver,
      INTERPOLATION_REGEXP,
      Parser,
      _ParseAST;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      int = $__m.int;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Lexer = $__m.Lexer;
      EOF = $__m.EOF;
      Token = $__m.Token;
      $PERIOD = $__m.$PERIOD;
      $COLON = $__m.$COLON;
      $SEMICOLON = $__m.$SEMICOLON;
      $LBRACKET = $__m.$LBRACKET;
      $RBRACKET = $__m.$RBRACKET;
      $COMMA = $__m.$COMMA;
      $LBRACE = $__m.$LBRACE;
      $RBRACE = $__m.$RBRACE;
      $LPAREN = $__m.$LPAREN;
      $RPAREN = $__m.$RPAREN;
    }, function($__m) {
      reflector = $__m.reflector;
      Reflector = $__m.Reflector;
    }, function($__m) {
      AST = $__m.AST;
      EmptyExpr = $__m.EmptyExpr;
      ImplicitReceiver = $__m.ImplicitReceiver;
      AccessMember = $__m.AccessMember;
      LiteralPrimitive = $__m.LiteralPrimitive;
      Expression = $__m.Expression;
      Binary = $__m.Binary;
      PrefixNot = $__m.PrefixNot;
      Conditional = $__m.Conditional;
      Pipe = $__m.Pipe;
      Assignment = $__m.Assignment;
      Chain = $__m.Chain;
      KeyedAccess = $__m.KeyedAccess;
      LiteralArray = $__m.LiteralArray;
      LiteralMap = $__m.LiteralMap;
      Interpolation = $__m.Interpolation;
      MethodCall = $__m.MethodCall;
      FunctionCall = $__m.FunctionCall;
      TemplateBindings = $__m.TemplateBindings;
      TemplateBinding = $__m.TemplateBinding;
      ASTWithSource = $__m.ASTWithSource;
    }],
    execute: function() {
      _implicitReceiver = new ImplicitReceiver();
      INTERPOLATION_REGEXP = RegExpWrapper.create('\\{\\{(.*?)\\}\\}');
      Parser = (function() {
        function Parser(lexer) {
          var providedReflector = arguments[1] !== (void 0) ? arguments[1] : null;
          this._lexer = lexer;
          this._reflector = isPresent(providedReflector) ? providedReflector : reflector;
        }
        return ($traceurRuntime.createClass)(Parser, {
          parseAction: function(input, location) {
            var tokens = this._lexer.tokenize(input);
            var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
            return new ASTWithSource(ast, input, location);
          },
          parseBinding: function(input, location) {
            var tokens = this._lexer.tokenize(input);
            var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
            return new ASTWithSource(ast, input, location);
          },
          addPipes: function(bindingAst, pipes) {
            if (ListWrapper.isEmpty(pipes))
              return bindingAst;
            var res = ListWrapper.reduce(pipes, (function(result, currentPipeName) {
              return new Pipe(result, currentPipeName, [], false);
            }), bindingAst.ast);
            return new ASTWithSource(res, bindingAst.source, bindingAst.location);
          },
          parseTemplateBindings: function(input, location) {
            var tokens = this._lexer.tokenize(input);
            return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
          },
          parseInterpolation: function(input, location) {
            var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
            if (parts.length <= 1) {
              return null;
            }
            var strings = [];
            var expressions = [];
            for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              if (i % 2 === 0) {
                ListWrapper.push(strings, part);
              } else {
                var tokens = this._lexer.tokenize(part);
                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                ListWrapper.push(expressions, ast);
              }
            }
            return new ASTWithSource(new Interpolation(strings, expressions), input, location);
          },
          wrapLiteralPrimitive: function(input, location) {
            return new ASTWithSource(new LiteralPrimitive(input), input, location);
          }
        }, {});
      }());
      $__export("Parser", Parser);
      Object.defineProperty(Parser, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(Parser, "parameters", {get: function() {
          return [[Lexer], [Reflector]];
        }});
      Object.defineProperty(Parser.prototype.parseAction, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(Parser.prototype.parseBinding, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(Parser.prototype.addPipes, "parameters", {get: function() {
          return [[ASTWithSource], [assert.genericType(List, String)]];
        }});
      Object.defineProperty(Parser.prototype.parseTemplateBindings, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(Parser.prototype.parseInterpolation, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(Parser.prototype.wrapLiteralPrimitive, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      _ParseAST = (function() {
        function _ParseAST(input, location, tokens, reflector, parseAction) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.index = 0;
          this.reflector = reflector;
          this.parseAction = parseAction;
        }
        return ($traceurRuntime.createClass)(_ParseAST, {
          peek: function(offset) {
            var i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
          },
          get next() {
            return this.peek(0);
          },
          get inputIndex() {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
          },
          advance: function() {
            this.index++;
          },
          optionalCharacter: function(code) {
            if (this.next.isCharacter(code)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          optionalKeywordVar: function() {
            if (this.peekKeywordVar()) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          peekKeywordVar: function() {
            return this.next.isKeywordVar() || this.next.isOperator('#');
          },
          expectCharacter: function(code) {
            if (this.optionalCharacter(code))
              return ;
            this.error(("Missing expected " + StringWrapper.fromCharCode(code)));
          },
          optionalOperator: function(op) {
            if (this.next.isOperator(op)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          expectOperator: function(operator) {
            if (this.optionalOperator(operator))
              return ;
            this.error(("Missing expected operator " + operator));
          },
          expectIdentifierOrKeyword: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
              this.error(("Unexpected token " + n + ", expected identifier or keyword"));
            }
            this.advance();
            return n.toString();
          },
          expectIdentifierOrKeywordOrString: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error(("Unexpected token " + n + ", expected identifier, keyword, or string"));
            }
            this.advance();
            return n.toString();
          },
          parseChain: function() {
            var exprs = [];
            while (this.index < this.tokens.length) {
              var expr = this.parsePipe();
              ListWrapper.push(exprs, expr);
              if (this.optionalCharacter($SEMICOLON)) {
                if (!this.parseAction) {
                  this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter($SEMICOLON)) {}
              } else if (this.index < this.tokens.length) {
                this.error(("Unexpected token '" + this.next + "'"));
              }
            }
            if (exprs.length == 0)
              return new EmptyExpr();
            if (exprs.length == 1)
              return exprs[0];
            return new Chain(exprs);
          },
          parsePipe: function() {
            var result = this.parseExpression();
            if (this.optionalOperator("|")) {
              return this.parseInlinedPipe(result);
            } else {
              return result;
            }
          },
          parseExpression: function() {
            var start = this.inputIndex;
            var result = this.parseConditional();
            while (this.next.isOperator('=')) {
              if (!result.isAssignable) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error(("Expression " + expression + " is not assignable"));
              }
              if (!this.parseAction) {
                this.error("Binding expression cannot contain assignments");
              }
              this.expectOperator('=');
              result = new Assignment(result, this.parseConditional());
            }
            return result;
          },
          parseConditional: function() {
            var start = this.inputIndex;
            var result = this.parseLogicalOr();
            if (this.optionalOperator('?')) {
              var yes = this.parseExpression();
              if (!this.optionalCharacter($COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error(("Conditional expression " + expression + " requires all 3 expressions"));
              }
              var no = this.parseExpression();
              return new Conditional(result, yes, no);
            } else {
              return result;
            }
          },
          parseLogicalOr: function() {
            var result = this.parseLogicalAnd();
            while (this.optionalOperator('||')) {
              result = new Binary('||', result, this.parseLogicalAnd());
            }
            return result;
          },
          parseLogicalAnd: function() {
            var result = this.parseEquality();
            while (this.optionalOperator('&&')) {
              result = new Binary('&&', result, this.parseEquality());
            }
            return result;
          },
          parseEquality: function() {
            var result = this.parseRelational();
            while (true) {
              if (this.optionalOperator('==')) {
                result = new Binary('==', result, this.parseRelational());
              } else if (this.optionalOperator('===')) {
                result = new Binary('===', result, this.parseRelational());
              } else if (this.optionalOperator('!=')) {
                result = new Binary('!=', result, this.parseRelational());
              } else if (this.optionalOperator('!==')) {
                result = new Binary('!==', result, this.parseRelational());
              } else {
                return result;
              }
            }
          },
          parseRelational: function() {
            var result = this.parseAdditive();
            while (true) {
              if (this.optionalOperator('<')) {
                result = new Binary('<', result, this.parseAdditive());
              } else if (this.optionalOperator('>')) {
                result = new Binary('>', result, this.parseAdditive());
              } else if (this.optionalOperator('<=')) {
                result = new Binary('<=', result, this.parseAdditive());
              } else if (this.optionalOperator('>=')) {
                result = new Binary('>=', result, this.parseAdditive());
              } else {
                return result;
              }
            }
          },
          parseAdditive: function() {
            var result = this.parseMultiplicative();
            while (true) {
              if (this.optionalOperator('+')) {
                result = new Binary('+', result, this.parseMultiplicative());
              } else if (this.optionalOperator('-')) {
                result = new Binary('-', result, this.parseMultiplicative());
              } else {
                return result;
              }
            }
          },
          parseMultiplicative: function() {
            var result = this.parsePrefix();
            while (true) {
              if (this.optionalOperator('*')) {
                result = new Binary('*', result, this.parsePrefix());
              } else if (this.optionalOperator('%')) {
                result = new Binary('%', result, this.parsePrefix());
              } else if (this.optionalOperator('/')) {
                result = new Binary('/', result, this.parsePrefix());
              } else {
                return result;
              }
            }
          },
          parsePrefix: function() {
            if (this.optionalOperator('+')) {
              return this.parsePrefix();
            } else if (this.optionalOperator('-')) {
              return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
            } else if (this.optionalOperator('!')) {
              return new PrefixNot(this.parsePrefix());
            } else {
              return this.parseCallChain();
            }
          },
          parseCallChain: function() {
            var result = this.parsePrimary();
            while (true) {
              if (this.optionalCharacter($PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result);
              } else if (this.optionalCharacter($LBRACKET)) {
                var key = this.parseExpression();
                this.expectCharacter($RBRACKET);
                result = new KeyedAccess(result, key);
              } else if (this.optionalCharacter($LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter($RPAREN);
                result = new FunctionCall(result, args);
              } else {
                return result;
              }
            }
          },
          parsePrimary: function() {
            if (this.optionalCharacter($LPAREN)) {
              var result = this.parsePipe();
              this.expectCharacter($RPAREN);
              return result;
            } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(null);
            } else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(true);
            } else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(false);
            } else if (this.optionalCharacter($LBRACKET)) {
              var elements = this.parseExpressionList($RBRACKET);
              this.expectCharacter($RBRACKET);
              return new LiteralArray(elements);
            } else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
            } else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(_implicitReceiver);
            } else if (this.next.isNumber()) {
              var value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(value);
            } else if (this.next.isString()) {
              var value = this.next.toString();
              this.advance();
              return new LiteralPrimitive(value);
            } else if (this.index >= this.tokens.length) {
              this.error(("Unexpected end of expression: " + this.input));
            } else {
              this.error(("Unexpected token " + this.next));
            }
          },
          parseExpressionList: function(terminator) {
            var result = [];
            if (!this.next.isCharacter(terminator)) {
              do {
                ListWrapper.push(result, this.parseExpression());
              } while (this.optionalCharacter($COMMA));
            }
            return result;
          },
          parseLiteralMap: function() {
            var keys = [];
            var values = [];
            this.expectCharacter($LBRACE);
            if (!this.optionalCharacter($RBRACE)) {
              do {
                var key = this.expectIdentifierOrKeywordOrString();
                ListWrapper.push(keys, key);
                this.expectCharacter($COLON);
                ListWrapper.push(values, this.parseExpression());
              } while (this.optionalCharacter($COMMA));
              this.expectCharacter($RBRACE);
            }
            return new LiteralMap(keys, values);
          },
          parseAccessMemberOrMethodCall: function(receiver) {
            var id = this.expectIdentifierOrKeyword();
            if (this.optionalCharacter($LPAREN)) {
              var args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              var fn = this.reflector.method(id);
              return new MethodCall(receiver, id, fn, args);
            } else {
              var getter = this.reflector.getter(id);
              var setter = this.reflector.setter(id);
              var am = new AccessMember(receiver, id, getter, setter);
              if (this.optionalOperator("|")) {
                return this.parseInlinedPipe(am);
              } else {
                return am;
              }
            }
          },
          parseInlinedPipe: function(result) {
            do {
              if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
              }
              var name = this.expectIdentifierOrKeyword();
              var args = ListWrapper.create();
              while (this.optionalCharacter($COLON)) {
                ListWrapper.push(args, this.parseExpression());
              }
              result = new Pipe(result, name, args, true);
            } while (this.optionalOperator("|"));
            return result;
          },
          parseCallArguments: function() {
            if (this.next.isCharacter($RPAREN))
              return [];
            var positionals = [];
            do {
              ListWrapper.push(positionals, this.parseExpression());
            } while (this.optionalCharacter($COMMA));
            return positionals;
          },
          expectTemplateBindingKey: function() {
            var result = '';
            var operatorFound = false;
            do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                result += '-';
              }
            } while (operatorFound);
            return result.toString();
          },
          parseTemplateBindings: function() {
            var bindings = [];
            while (this.index < this.tokens.length) {
              var keyIsVar = this.optionalKeywordVar();
              var key = this.expectTemplateBindingKey();
              this.optionalCharacter($COLON);
              var name = null;
              var expression = null;
              if (this.next !== EOF) {
                if (keyIsVar) {
                  if (this.optionalOperator("=")) {
                    name = this.expectTemplateBindingKey();
                  } else {
                    name = '\$implicit';
                  }
                } else if (!this.peekKeywordVar()) {
                  var start = this.inputIndex;
                  var ast = this.parsePipe();
                  var source = this.input.substring(start, this.inputIndex);
                  expression = new ASTWithSource(ast, source, this.location);
                }
              }
              ListWrapper.push(bindings, new TemplateBinding(key, keyIsVar, name, expression));
              if (!this.optionalCharacter($SEMICOLON)) {
                this.optionalCharacter($COMMA);
              }
            }
            return bindings;
          },
          error: function(message) {
            var index = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isBlank(index))
              index = this.index;
            var location = (index < this.tokens.length) ? ("at column " + (this.tokens[index].index + 1) + " in") : "at the end of the expression";
            throw new BaseException(("Parser Error: " + message + " " + location + " [" + this.input + "] in " + this.location));
          }
        }, {});
      }());
      Object.defineProperty(_ParseAST, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any], [List], [Reflector], [assert.type.boolean]];
        }});
      Object.defineProperty(_ParseAST.prototype.peek, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(_ParseAST.prototype.optionalCharacter, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(_ParseAST.prototype.expectCharacter, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(_ParseAST.prototype.optionalOperator, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_ParseAST.prototype.expectOperator, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_ParseAST.prototype.parseExpressionList, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(_ParseAST.prototype.error, "parameters", {get: function() {
          return [[assert.type.string], [int]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/parser/locals", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/locals";
  var isPresent,
      BaseException,
      ListWrapper,
      MapWrapper,
      Locals;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      Locals = (function() {
        function Locals(parent, current) {
          this.parent = parent;
          this.current = current;
        }
        return ($traceurRuntime.createClass)(Locals, {
          contains: function(name) {
            if (MapWrapper.contains(this.current, name)) {
              return true;
            }
            if (isPresent(this.parent)) {
              return this.parent.contains(name);
            }
            return false;
          },
          get: function(name) {
            if (MapWrapper.contains(this.current, name)) {
              return MapWrapper.get(this.current, name);
            }
            if (isPresent(this.parent)) {
              return this.parent.get(name);
            }
            throw new BaseException(("Cannot find '" + name + "'"));
          },
          set: function(name, value) {
            if (MapWrapper.contains(this.current, name)) {
              MapWrapper.set(this.current, name, value);
            } else {
              throw new BaseException('Setting of new keys post-construction is not supported.');
            }
          },
          clearValues: function() {
            MapWrapper.clearValues(this.current);
          }
        }, {});
      }());
      $__export("Locals", Locals);
      Object.defineProperty(Locals, "parameters", {get: function() {
          return [[Locals], [Map]];
        }});
      Object.defineProperty(Locals.prototype.contains, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(Locals.prototype.get, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(Locals.prototype.set, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/change_detection/constants", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/constants";
  var CHECK_ONCE,
      CHECKED,
      CHECK_ALWAYS,
      DETACHED,
      ON_PUSH,
      DEFAULT;
  return {
    setters: [],
    execute: function() {
      CHECK_ONCE = "CHECK_ONCE";
      $__export("CHECK_ONCE", CHECK_ONCE);
      CHECKED = "CHECKED";
      $__export("CHECKED", CHECKED);
      CHECK_ALWAYS = "ALWAYS_CHECK";
      $__export("CHECK_ALWAYS", CHECK_ALWAYS);
      DETACHED = "DETACHED";
      $__export("DETACHED", DETACHED);
      ON_PUSH = "ON_PUSH";
      $__export("ON_PUSH", ON_PUSH);
      DEFAULT = "DEFAULT";
      $__export("DEFAULT", DEFAULT);
    }
  };
});

System.register("angular2/src/change_detection/interfaces", ["angular2/src/facade/collection", "angular2/src/change_detection/parser/locals", "angular2/src/change_detection/constants", "angular2/src/change_detection/binding_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/interfaces";
  var List,
      Locals,
      DEFAULT,
      BindingRecord,
      ProtoChangeDetector,
      ChangeDetection,
      ChangeDispatcher,
      ChangeDetector;
  return {
    setters: [function($__m) {
      List = $__m.List;
    }, function($__m) {
      Locals = $__m.Locals;
    }, function($__m) {
      DEFAULT = $__m.DEFAULT;
    }, function($__m) {
      BindingRecord = $__m.BindingRecord;
    }],
    execute: function() {
      ProtoChangeDetector = (function() {
        function ProtoChangeDetector() {}
        return ($traceurRuntime.createClass)(ProtoChangeDetector, {instantiate: function(dispatcher) {
            return null;
          }}, {});
      }());
      $__export("ProtoChangeDetector", ProtoChangeDetector);
      Object.defineProperty(ProtoChangeDetector.prototype.instantiate, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      ChangeDetection = (function() {
        function ChangeDetection() {}
        return ($traceurRuntime.createClass)(ChangeDetection, {createProtoChangeDetector: function(name, bindingRecords, variableBindings, directiveRecords) {
            var changeControlStrategy = arguments[4] !== (void 0) ? arguments[4] : DEFAULT;
            return null;
          }}, {});
      }());
      $__export("ChangeDetection", ChangeDetection);
      Object.defineProperty(ChangeDetection.prototype.createProtoChangeDetector, "parameters", {get: function() {
          return [[assert.type.string], [List], [List], [List], [assert.type.string]];
        }});
      ChangeDispatcher = (function() {
        function ChangeDispatcher() {}
        return ($traceurRuntime.createClass)(ChangeDispatcher, {notifyOnBinding: function(bindingRecord, value) {}}, {});
      }());
      $__export("ChangeDispatcher", ChangeDispatcher);
      Object.defineProperty(ChangeDispatcher.prototype.notifyOnBinding, "parameters", {get: function() {
          return [[BindingRecord], [assert.type.any]];
        }});
      ChangeDetector = (function() {
        function ChangeDetector() {}
        return ($traceurRuntime.createClass)(ChangeDetector, {
          addChild: function(cd) {},
          addShadowDomChild: function(cd) {},
          removeChild: function(cd) {},
          removeShadowDomChild: function(cd) {},
          remove: function() {},
          hydrate: function(context, locals, directives) {},
          dehydrate: function() {},
          markPathToRootAsCheckOnce: function() {},
          detectChanges: function() {},
          checkNoChanges: function() {}
        }, {});
      }());
      $__export("ChangeDetector", ChangeDetector);
      Object.defineProperty(ChangeDetector.prototype.addChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(ChangeDetector.prototype.addShadowDomChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(ChangeDetector.prototype.removeChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(ChangeDetector.prototype.removeShadowDomChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(ChangeDetector.prototype.hydrate, "parameters", {get: function() {
          return [[assert.type.any], [Locals], [assert.type.any]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/pipes/pipe", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/pipe";
  var WrappedValue,
      _wrappedValues,
      _wrappedIndex,
      Pipe;
  return {
    setters: [],
    execute: function() {
      WrappedValue = (function() {
        function WrappedValue(wrapped) {
          this.wrapped = wrapped;
        }
        return ($traceurRuntime.createClass)(WrappedValue, {}, {wrap: function(value) {
            var w = _wrappedValues[_wrappedIndex++ % 5];
            w.wrapped = value;
            return w;
          }});
      }());
      $__export("WrappedValue", WrappedValue);
      Object.defineProperty(WrappedValue, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(WrappedValue.wrap, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
      _wrappedIndex = 0;
      Pipe = (function() {
        function Pipe() {}
        return ($traceurRuntime.createClass)(Pipe, {
          supports: function(obj) {
            return false;
          },
          onDestroy: function() {},
          transform: function(value) {
            return null;
          }
        }, {});
      }());
      $__export("Pipe", Pipe);
      Object.defineProperty(Pipe.prototype.transform, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/change_detector_ref", ["angular2/src/change_detection/interfaces", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detector_ref";
  var ChangeDetector,
      CHECK_ONCE,
      DETACHED,
      CHECK_ALWAYS,
      ChangeDetectorRef;
  return {
    setters: [function($__m) {
      ChangeDetector = $__m.ChangeDetector;
    }, function($__m) {
      CHECK_ONCE = $__m.CHECK_ONCE;
      DETACHED = $__m.DETACHED;
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
    }],
    execute: function() {
      ChangeDetectorRef = (function() {
        function ChangeDetectorRef(cd) {
          this._cd = cd;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorRef, {
          requestCheck: function() {
            this._cd.markPathToRootAsCheckOnce();
          },
          detach: function() {
            this._cd.mode = DETACHED;
          },
          reattach: function() {
            this._cd.mode = CHECK_ALWAYS;
            this.requestCheck();
          }
        }, {});
      }());
      $__export("ChangeDetectorRef", ChangeDetectorRef);
      Object.defineProperty(ChangeDetectorRef, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/pipes/pipe_registry", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe", "angular2/di", "angular2/src/change_detection/change_detector_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/pipe_registry";
  var List,
      ListWrapper,
      isBlank,
      isPresent,
      BaseException,
      CONST,
      Pipe,
      Injectable,
      ChangeDetectorRef,
      PipeRegistry;
  return {
    setters: [function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }],
    execute: function() {
      PipeRegistry = (function() {
        function PipeRegistry(config) {
          this.config = config;
        }
        return ($traceurRuntime.createClass)(PipeRegistry, {get: function(type, obj, cdRef) {
            var listOfConfigs = this.config[type];
            if (isBlank(listOfConfigs)) {
              throw new BaseException(("Cannot find '" + type + "' pipe supporting object '" + obj + "'"));
            }
            var matchingConfig = ListWrapper.find(listOfConfigs, (function(pipeConfig) {
              return pipeConfig.supports(obj);
            }));
            if (isBlank(matchingConfig)) {
              throw new BaseException(("Cannot find '" + type + "' pipe supporting object '" + obj + "'"));
            }
            return matchingConfig.create(cdRef);
          }}, {});
      }());
      $__export("PipeRegistry", PipeRegistry);
      Object.defineProperty(PipeRegistry, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(PipeRegistry.prototype.get, "parameters", {get: function() {
          return [[assert.type.string], [], [ChangeDetectorRef]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/change_detection_jit_generator", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_jit_generator";
  var isPresent,
      isBlank,
      BaseException,
      Type,
      List,
      ListWrapper,
      MapWrapper,
      StringMapWrapper,
      AbstractChangeDetector,
      ChangeDetectionUtil,
      DirectiveIndex,
      DirectiveRecord,
      ProtoRecord,
      RECORD_TYPE_SELF,
      RECORD_TYPE_PROPERTY,
      RECORD_TYPE_LOCAL,
      RECORD_TYPE_INVOKE_METHOD,
      RECORD_TYPE_CONST,
      RECORD_TYPE_INVOKE_CLOSURE,
      RECORD_TYPE_PRIMITIVE_OP,
      RECORD_TYPE_KEYED_ACCESS,
      RECORD_TYPE_PIPE,
      RECORD_TYPE_BINDING_PIPE,
      RECORD_TYPE_INTERPOLATE,
      ABSTRACT_CHANGE_DETECTOR,
      UTIL,
      DISPATCHER_ACCESSOR,
      PIPE_REGISTRY_ACCESSOR,
      PROTOS_ACCESSOR,
      DIRECTIVES_ACCESSOR,
      CONTEXT_ACCESSOR,
      IS_CHANGED_LOCAL,
      CHANGES_LOCAL,
      LOCALS_ACCESSOR,
      MODE_ACCESSOR,
      TEMP_LOCAL,
      CURRENT_PROTO,
      ChangeDetectorJITGenerator;
  function typeTemplate(type, cons, detectChanges, notifyOnAllChangesDone, setContext) {
    return ("\n" + cons + "\n" + detectChanges + "\n" + notifyOnAllChangesDone + "\n" + setContext + ";\n\nreturn function(dispatcher, pipeRegistry) {\n  return new " + type + "(dispatcher, pipeRegistry, protos, directiveRecords);\n}\n");
  }
  function constructorTemplate(type, fieldsDefinitions) {
    return ("\nvar " + type + " = function " + type + "(dispatcher, pipeRegistry, protos, directiveRecords) {\n" + ABSTRACT_CHANGE_DETECTOR + ".call(this);\n" + DISPATCHER_ACCESSOR + " = dispatcher;\n" + PIPE_REGISTRY_ACCESSOR + " = pipeRegistry;\n" + PROTOS_ACCESSOR + " = protos;\n" + DIRECTIVES_ACCESSOR + " = directiveRecords;\n" + LOCALS_ACCESSOR + " = null;\n" + fieldsDefinitions + "\n}\n\n" + type + ".prototype = Object.create(" + ABSTRACT_CHANGE_DETECTOR + ".prototype);\n");
  }
  function pipeOnDestroyTemplate(pipeNames) {
    return pipeNames.map((function(p) {
      return (p + ".onDestroy()");
    })).join("\n");
  }
  function hydrateTemplate(type, mode, fieldDefinitions, pipeOnDestroy, directiveFieldNames, detectorFieldNames) {
    var directiveInit = "";
    for (var i = 0; i < directiveFieldNames.length; ++i) {
      directiveInit += (directiveFieldNames[i] + " = directives.getDirectiveFor(this.directiveRecords[" + i + "].directiveIndex);\n");
    }
    var detectorInit = "";
    for (var i = 0; i < detectorFieldNames.length; ++i) {
      detectorInit += (detectorFieldNames[i] + " = directives.getDetectorFor(this.directiveRecords[" + i + "].directiveIndex);\n");
    }
    return ("\n" + type + ".prototype.hydrate = function(context, locals, directives) {\n  " + MODE_ACCESSOR + " = \"" + mode + "\";\n  " + CONTEXT_ACCESSOR + " = context;\n  " + LOCALS_ACCESSOR + " = locals;\n  " + directiveInit + "\n  " + detectorInit + "\n}\n" + type + ".prototype.dehydrate = function() {\n  " + pipeOnDestroy + "\n  " + fieldDefinitions + "\n  " + LOCALS_ACCESSOR + " = null;\n}\n" + type + ".prototype.hydrated = function() {\n  return " + CONTEXT_ACCESSOR + " !== " + UTIL + ".unitialized();\n}\n");
  }
  function detectChangesTemplate(type, body) {
    return ("\n" + type + ".prototype.detectChangesInRecords = function(throwOnChange) {\n  " + body + "\n}\n");
  }
  function callOnAllChangesDoneTemplate(type, body) {
    return ("\n" + type + ".prototype.callOnAllChangesDone = function() {\n  " + body + "\n}\n");
  }
  function onAllChangesDoneTemplate(directive) {
    return (directive + ".onAllChangesDone();");
  }
  function detectChangesBodyTemplate(localDefinitions, changeDefinitions, records) {
    return ("\n" + localDefinitions + "\n" + changeDefinitions + "\nvar " + TEMP_LOCAL + ";\nvar " + IS_CHANGED_LOCAL + " = false;\nvar " + CURRENT_PROTO + ";\nvar " + CHANGES_LOCAL + " = null;\n\ncontext = " + CONTEXT_ACCESSOR + ";\n" + records + "\n");
  }
  function pipeCheckTemplate(protoIndex, context, bindingPropagationConfig, pipe, pipeType, oldValue, newValue, change, update, addToChanges, lastInDirective) {
    return ("\n" + CURRENT_PROTO + " = " + PROTOS_ACCESSOR + "[" + protoIndex + "];\nif (" + pipe + " === " + UTIL + ".unitialized()) {\n  " + pipe + " = " + PIPE_REGISTRY_ACCESSOR + ".get('" + pipeType + "', " + context + ", " + bindingPropagationConfig + ");\n} else if (!" + pipe + ".supports(" + context + ")) {\n  " + pipe + ".onDestroy();\n  " + pipe + " = " + PIPE_REGISTRY_ACCESSOR + ".get('" + pipeType + "', " + context + ", " + bindingPropagationConfig + ");\n}\n\n" + newValue + " = " + pipe + ".transform(" + context + ");\nif (" + oldValue + " !== " + newValue + ") {\n  " + newValue + " = " + UTIL + ".unwrapValue(" + newValue + ");\n  " + change + " = true;\n  " + update + "\n  " + addToChanges + "\n  " + oldValue + " = " + newValue + ";\n}\n" + lastInDirective + "\n");
  }
  function referenceCheckTemplate(protoIndex, assignment, oldValue, newValue, change, update, addToChanges, lastInDirective) {
    return ("\n" + CURRENT_PROTO + " = " + PROTOS_ACCESSOR + "[" + protoIndex + "];\n" + assignment + "\nif (" + newValue + " !== " + oldValue + " || (" + newValue + " !== " + newValue + ") && (" + oldValue + " !== " + oldValue + ")) {\n  " + change + " = true;\n  " + update + "\n  " + addToChanges + "\n  " + oldValue + " = " + newValue + ";\n}\n" + lastInDirective + "\n");
  }
  function assignmentTemplate(field, value) {
    return (field + " = " + value + ";");
  }
  function localDefinitionsTemplate(names) {
    return names.map((function(n) {
      return ("var " + n + ";");
    })).join("\n");
  }
  function changeDefinitionsTemplate(names) {
    return names.map((function(n) {
      return ("var " + n + " = false;");
    })).join("\n");
  }
  function fieldDefinitionsTemplate(names) {
    return names.map((function(n) {
      return (n + " = " + UTIL + ".unitialized();");
    })).join("\n");
  }
  function ifChangedGuardTemplate(changeNames, body) {
    var cond = changeNames.join(" || ");
    return ("\nif (" + cond + ") {\n  " + body + "\n}\n");
  }
  function addToChangesTemplate(oldValue, newValue) {
    return (CHANGES_LOCAL + " = " + UTIL + ".addChange(" + CHANGES_LOCAL + ", " + CURRENT_PROTO + ".bindingRecord.propertyName, " + UTIL + ".simpleChange(" + oldValue + ", " + newValue + "));");
  }
  function updateDirectiveTemplate(oldValue, newValue, directiveProperty) {
    return ("\nif(throwOnChange) " + UTIL + ".throwOnChange(" + CURRENT_PROTO + ", " + UTIL + ".simpleChange(" + oldValue + ", " + newValue + "));\n" + directiveProperty + " = " + newValue + ";\n" + IS_CHANGED_LOCAL + " = true;\n  ");
  }
  function updateElementTemplate(oldValue, newValue) {
    return ("\nif(throwOnChange) " + UTIL + ".throwOnChange(" + CURRENT_PROTO + ", " + UTIL + ".simpleChange(" + oldValue + ", " + newValue + "));\n" + DISPATCHER_ACCESSOR + ".notifyOnBinding(" + CURRENT_PROTO + ".bindingRecord, " + newValue + ");\n  ");
  }
  function notifyOnChangesTemplate(directive) {
    return ("\nif(" + CHANGES_LOCAL + ") {\n  " + directive + ".onChange(" + CHANGES_LOCAL + ");\n  " + CHANGES_LOCAL + " = null;\n}\n");
  }
  function notifyOnPushDetectorsTemplate(detector) {
    return ("\nif(" + IS_CHANGED_LOCAL + ") {\n  " + detector + ".markAsCheckOnce();\n}\n");
  }
  function lastInDirectiveTemplate(notifyOnChanges, notifyOnPush) {
    return ("\n" + notifyOnChanges + "\n" + notifyOnPush + "\n" + IS_CHANGED_LOCAL + " = false;\n");
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      Type = $__m.Type;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
      DirectiveRecord = $__m.DirectiveRecord;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
      RECORD_TYPE_SELF = $__m.RECORD_TYPE_SELF;
      RECORD_TYPE_PROPERTY = $__m.RECORD_TYPE_PROPERTY;
      RECORD_TYPE_LOCAL = $__m.RECORD_TYPE_LOCAL;
      RECORD_TYPE_INVOKE_METHOD = $__m.RECORD_TYPE_INVOKE_METHOD;
      RECORD_TYPE_CONST = $__m.RECORD_TYPE_CONST;
      RECORD_TYPE_INVOKE_CLOSURE = $__m.RECORD_TYPE_INVOKE_CLOSURE;
      RECORD_TYPE_PRIMITIVE_OP = $__m.RECORD_TYPE_PRIMITIVE_OP;
      RECORD_TYPE_KEYED_ACCESS = $__m.RECORD_TYPE_KEYED_ACCESS;
      RECORD_TYPE_PIPE = $__m.RECORD_TYPE_PIPE;
      RECORD_TYPE_BINDING_PIPE = $__m.RECORD_TYPE_BINDING_PIPE;
      RECORD_TYPE_INTERPOLATE = $__m.RECORD_TYPE_INTERPOLATE;
    }],
    execute: function() {
      ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
      UTIL = "ChangeDetectionUtil";
      DISPATCHER_ACCESSOR = "this.dispatcher";
      PIPE_REGISTRY_ACCESSOR = "this.pipeRegistry";
      PROTOS_ACCESSOR = "this.protos";
      DIRECTIVES_ACCESSOR = "this.directiveRecords";
      CONTEXT_ACCESSOR = "this.context";
      IS_CHANGED_LOCAL = "isChanged";
      CHANGES_LOCAL = "changes";
      LOCALS_ACCESSOR = "this.locals";
      MODE_ACCESSOR = "this.mode";
      TEMP_LOCAL = "temp";
      CURRENT_PROTO = "currentProto";
      Object.defineProperty(typeTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(constructorTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(pipeOnDestroyTemplate, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(hydrateTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.genericType(List, String)], [assert.genericType(List, String)]];
        }});
      Object.defineProperty(detectChangesTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(callOnAllChangesDoneTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(onAllChangesDoneTemplate, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(detectChangesBodyTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(pipeCheckTemplate, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [], [assert.type.string]];
        }});
      Object.defineProperty(referenceCheckTemplate, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(assignmentTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(localDefinitionsTemplate, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(changeDefinitionsTemplate, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(fieldDefinitionsTemplate, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(ifChangedGuardTemplate, "parameters", {get: function() {
          return [[List], [assert.type.string]];
        }});
      Object.defineProperty(addToChangesTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(updateDirectiveTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(updateElementTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(notifyOnChangesTemplate, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(notifyOnPushDetectorsTemplate, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(lastInDirectiveTemplate, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      ChangeDetectorJITGenerator = (function() {
        function ChangeDetectorJITGenerator(typeName, changeDetectionStrategy, records, directiveRecords) {
          this.typeName = typeName;
          this.changeDetectionStrategy = changeDetectionStrategy;
          this.records = records;
          this.directiveRecords = directiveRecords;
          this.localNames = this.getLocalNames(records);
          this.changeNames = this.getChangeNames(this.localNames);
          this.fieldNames = this.getFieldNames(this.localNames);
          this.pipeNames = this.getPipeNames(this.localNames);
        }
        return ($traceurRuntime.createClass)(ChangeDetectorJITGenerator, {
          getLocalNames: function(records) {
            var index = 0;
            var names = records.map((function(r) {
              var sanitizedName = r.name.replace(new RegExp("\\W", "g"), '');
              return ("" + sanitizedName + index++);
            }));
            return ["context"].concat(names);
          },
          getChangeNames: function(localNames) {
            return localNames.map((function(n) {
              return ("change_" + n);
            }));
          },
          getFieldNames: function(localNames) {
            return localNames.map((function(n) {
              return ("this." + n);
            }));
          },
          getPipeNames: function(localNames) {
            return localNames.map((function(n) {
              return ("this." + n + "_pipe");
            }));
          },
          generate: function() {
            var text = typeTemplate(this.typeName, this.genConstructor(), this.genDetectChanges(), this.genCallOnAllChangesDone(), this.genHydrate());
            return new Function('AbstractChangeDetector', 'ChangeDetectionUtil', 'protos', 'directiveRecords', text)(AbstractChangeDetector, ChangeDetectionUtil, this.records, this.directiveRecords);
          },
          genConstructor: function() {
            return constructorTemplate(this.typeName, this.genFieldDefinitions());
          },
          genHydrate: function() {
            var mode = ChangeDetectionUtil.changeDetectionMode(this.changeDetectionStrategy);
            return hydrateTemplate(this.typeName, mode, this.genFieldDefinitions(), pipeOnDestroyTemplate(this.getNonNullPipeNames()), this.getDirectiveFieldNames(), this.getDetectorFieldNames());
          },
          getDirectiveFieldNames: function() {
            var $__0 = this;
            return this.directiveRecords.map((function(d) {
              return $__0.getDirective(d.directiveIndex);
            }));
          },
          getDetectorFieldNames: function() {
            var $__0 = this;
            return this.directiveRecords.filter((function(r) {
              return r.isOnPushChangeDetection();
            })).map((function(d) {
              return $__0.getDetector(d.directiveIndex);
            }));
          },
          getDirective: function(d) {
            return ("this.directive_" + d.name);
          },
          getDetector: function(d) {
            return ("this.detector_" + d.name);
          },
          genFieldDefinitions: function() {
            var fields = [];
            fields = fields.concat(this.fieldNames);
            fields = fields.concat(this.getNonNullPipeNames());
            fields = fields.concat(this.getDirectiveFieldNames());
            fields = fields.concat(this.getDetectorFieldNames());
            return fieldDefinitionsTemplate(fields);
          },
          getNonNullPipeNames: function() {
            var $__0 = this;
            var pipes = [];
            this.records.forEach((function(r) {
              if (r.mode === RECORD_TYPE_PIPE || r.mode === RECORD_TYPE_BINDING_PIPE) {
                pipes.push($__0.pipeNames[r.selfIndex]);
              }
            }));
            return pipes;
          },
          genDetectChanges: function() {
            var body = this.genDetectChangesBody();
            return detectChangesTemplate(this.typeName, body);
          },
          genCallOnAllChangesDone: function() {
            var notifications = [];
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                var directive = ("this.directive_" + dir.directiveIndex.name);
                notifications.push(onAllChangesDoneTemplate(directive));
              }
            }
            return callOnAllChangesDoneTemplate(this.typeName, notifications.join(";\n"));
          },
          genDetectChangesBody: function() {
            var $__0 = this;
            var rec = this.records.map((function(r) {
              return $__0.genRecord(r);
            })).join("\n");
            return detectChangesBodyTemplate(this.genLocalDefinitions(), this.genChangeDefinitions(), rec);
          },
          genLocalDefinitions: function() {
            return localDefinitionsTemplate(this.localNames);
          },
          genChangeDefinitions: function() {
            return changeDefinitionsTemplate(this.changeNames);
          },
          genRecord: function(r) {
            if (r.mode === RECORD_TYPE_PIPE || r.mode === RECORD_TYPE_BINDING_PIPE) {
              return this.genPipeCheck(r);
            } else {
              return this.genReferenceCheck(r);
            }
          },
          genPipeCheck: function(r) {
            var context = this.localNames[r.contextIndex];
            var oldValue = this.fieldNames[r.selfIndex];
            var newValue = this.localNames[r.selfIndex];
            var change = this.changeNames[r.selfIndex];
            var pipe = this.pipeNames[r.selfIndex];
            var cdRef = r.mode === RECORD_TYPE_BINDING_PIPE ? "this.ref" : "null";
            var update = this.genUpdateDirectiveOrElement(r);
            var addToChanges = this.genAddToChanges(r);
            var lastInDirective = this.genLastInDirective(r);
            return pipeCheckTemplate(r.selfIndex - 1, context, cdRef, pipe, r.name, oldValue, newValue, change, update, addToChanges, lastInDirective);
          },
          genReferenceCheck: function(r) {
            var oldValue = this.fieldNames[r.selfIndex];
            var newValue = this.localNames[r.selfIndex];
            var change = this.changeNames[r.selfIndex];
            var assignment = this.genUpdateCurrentValue(r);
            var update = this.genUpdateDirectiveOrElement(r);
            var addToChanges = this.genAddToChanges(r);
            var lastInDirective = this.genLastInDirective(r);
            var check = referenceCheckTemplate(r.selfIndex - 1, assignment, oldValue, newValue, change, update, addToChanges, lastInDirective);
            if (r.isPureFunction()) {
              return this.ifChangedGuard(r, check);
            } else {
              return check;
            }
          },
          genUpdateCurrentValue: function(r) {
            var context = this.getContext(r);
            var newValue = this.localNames[r.selfIndex];
            var args = this.genArgs(r);
            switch (r.mode) {
              case RECORD_TYPE_SELF:
                return assignmentTemplate(newValue, context);
              case RECORD_TYPE_CONST:
                return (newValue + " = " + this.genLiteral(r.funcOrValue));
              case RECORD_TYPE_PROPERTY:
                return assignmentTemplate(newValue, (context + "." + r.name));
              case RECORD_TYPE_LOCAL:
                return assignmentTemplate(newValue, (LOCALS_ACCESSOR + ".get('" + r.name + "')"));
              case RECORD_TYPE_INVOKE_METHOD:
                return assignmentTemplate(newValue, (context + "." + r.name + "(" + args + ")"));
              case RECORD_TYPE_INVOKE_CLOSURE:
                return assignmentTemplate(newValue, (context + "(" + args + ")"));
              case RECORD_TYPE_PRIMITIVE_OP:
                return assignmentTemplate(newValue, (UTIL + "." + r.name + "(" + args + ")"));
              case RECORD_TYPE_INTERPOLATE:
                return assignmentTemplate(newValue, this.genInterpolation(r));
              case RECORD_TYPE_KEYED_ACCESS:
                var key = this.localNames[r.args[0]];
                return assignmentTemplate(newValue, (context + "[" + key + "]"));
              default:
                throw new BaseException(("Unknown operation " + r.mode));
            }
          },
          getContext: function(r) {
            if (r.contextIndex == -1) {
              return this.getDirective(r.directiveIndex);
            } else {
              return this.localNames[r.contextIndex];
            }
          },
          ifChangedGuard: function(r, body) {
            var $__0 = this;
            return ifChangedGuardTemplate(r.args.map((function(a) {
              return $__0.changeNames[a];
            })), body);
          },
          genInterpolation: function(r) {
            var res = "";
            for (var i = 0; i < r.args.length; ++i) {
              res += this.genLiteral(r.fixedArgs[i]);
              res += " + ";
              res += this.localNames[r.args[i]];
              res += " + ";
            }
            res += this.genLiteral(r.fixedArgs[r.args.length]);
            return res;
          },
          genLiteral: function(value) {
            return JSON.stringify(value);
          },
          genUpdateDirectiveOrElement: function(r) {
            if (!r.lastInBinding)
              return "";
            var newValue = this.localNames[r.selfIndex];
            var oldValue = this.fieldNames[r.selfIndex];
            var br = r.bindingRecord;
            if (br.isDirective()) {
              var directiveProperty = (this.getDirective(br.directiveRecord.directiveIndex) + "." + br.propertyName);
              return updateDirectiveTemplate(oldValue, newValue, directiveProperty);
            } else {
              return updateElementTemplate(oldValue, newValue);
            }
          },
          genAddToChanges: function(r) {
            var newValue = this.localNames[r.selfIndex];
            var oldValue = this.fieldNames[r.selfIndex];
            return r.bindingRecord.callOnChange() ? addToChangesTemplate(oldValue, newValue) : "";
          },
          genLastInDirective: function(r) {
            var onChanges = this.genNotifyOnChanges(r);
            var onPush = this.genNotifyOnPushDetectors(r);
            return lastInDirectiveTemplate(onChanges, onPush);
          },
          genNotifyOnChanges: function(r) {
            var br = r.bindingRecord;
            if (r.lastInDirective && br.callOnChange()) {
              return notifyOnChangesTemplate(this.getDirective(br.directiveRecord.directiveIndex));
            } else {
              return "";
            }
          },
          genNotifyOnPushDetectors: function(r) {
            var br = r.bindingRecord;
            if (r.lastInDirective && br.isOnPushChangeDetection()) {
              return notifyOnPushDetectorsTemplate(this.getDetector(br.directiveRecord.directiveIndex));
            } else {
              return "";
            }
          },
          genArgs: function(r) {
            var $__0 = this;
            return r.args.map((function(arg) {
              return $__0.localNames[arg];
            })).join(", ");
          }
        }, {});
      }());
      $__export("ChangeDetectorJITGenerator", ChangeDetectorJITGenerator);
      Object.defineProperty(ChangeDetectorJITGenerator, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.genericType(List, ProtoRecord)], [List]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getLocalNames, "parameters", {get: function() {
          return [[assert.genericType(List, ProtoRecord)]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getChangeNames, "parameters", {get: function() {
          return [[assert.genericType(List, assert.type.string)]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getFieldNames, "parameters", {get: function() {
          return [[assert.genericType(List, assert.type.string)]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getPipeNames, "parameters", {get: function() {
          return [[assert.genericType(List, assert.type.string)]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getDirective, "parameters", {get: function() {
          return [[DirectiveIndex]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getDetector, "parameters", {get: function() {
          return [[DirectiveIndex]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genRecord, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genPipeCheck, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genReferenceCheck, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genUpdateCurrentValue, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.getContext, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.ifChangedGuard, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.string]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genInterpolation, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genUpdateDirectiveOrElement, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genAddToChanges, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genLastInDirective, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genNotifyOnChanges, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genNotifyOnPushDetectors, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(ChangeDetectorJITGenerator.prototype.genArgs, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/coalesce", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/coalesce";
  var isPresent,
      List,
      ListWrapper,
      Map,
      MapWrapper,
      RECORD_TYPE_SELF,
      ProtoRecord;
  function coalesce(records) {
    var res = ListWrapper.create();
    var indexMap = MapWrapper.create();
    for (var i = 0; i < records.length; ++i) {
      var r = records[i];
      var record = _replaceIndices(r, res.length + 1, indexMap);
      var matchingRecord = _findMatching(record, res);
      if (isPresent(matchingRecord) && record.lastInBinding) {
        ListWrapper.push(res, _selfRecord(record, matchingRecord.selfIndex, res.length + 1));
        MapWrapper.set(indexMap, r.selfIndex, matchingRecord.selfIndex);
      } else if (isPresent(matchingRecord) && !record.lastInBinding) {
        MapWrapper.set(indexMap, r.selfIndex, matchingRecord.selfIndex);
      } else {
        ListWrapper.push(res, record);
        MapWrapper.set(indexMap, r.selfIndex, record.selfIndex);
      }
    }
    return res;
  }
  function _selfRecord(r, contextIndex, selfIndex) {
    return new ProtoRecord(RECORD_TYPE_SELF, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
  }
  function _findMatching(r, rs) {
    return ListWrapper.find(rs, (function(rr) {
      return rr.mode === r.mode && rr.funcOrValue === r.funcOrValue && rr.contextIndex === r.contextIndex && ListWrapper.equals(rr.args, r.args);
    }));
  }
  function _replaceIndices(r, selfIndex, indexMap) {
    var args = ListWrapper.map(r.args, (function(a) {
      return _map(indexMap, a);
    }));
    var contextIndex = _map(indexMap, r.contextIndex);
    return new ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
  }
  function _map(indexMap, value) {
    var r = MapWrapper.get(indexMap, value);
    return isPresent(r) ? r : value;
  }
  $__export("coalesce", coalesce);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      RECORD_TYPE_SELF = $__m.RECORD_TYPE_SELF;
      ProtoRecord = $__m.ProtoRecord;
    }],
    execute: function() {
      Object.defineProperty(coalesce, "parameters", {get: function() {
          return [[assert.genericType(List, ProtoRecord)]];
        }});
      Object.defineProperty(_selfRecord, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.number], [assert.type.number]];
        }});
      Object.defineProperty(_findMatching, "parameters", {get: function() {
          return [[ProtoRecord], [assert.genericType(List, ProtoRecord)]];
        }});
      Object.defineProperty(_replaceIndices, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.number], [Map]];
        }});
      Object.defineProperty(_map, "parameters", {get: function() {
          return [[Map], [assert.type.number]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/pipes/iterable_changes", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/iterable_changes";
  var isListLikeIterable,
      iterateListLike,
      ListWrapper,
      MapWrapper,
      int,
      isBlank,
      isPresent,
      stringify,
      getMapKey,
      looseIdentical,
      WrappedValue,
      Pipe,
      IterableChangesFactory,
      IterableChanges,
      CollectionChangeRecord,
      _DuplicateItemRecordList,
      _DuplicateMap;
  return {
    setters: [function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
      iterateListLike = $__m.iterateListLike;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      int = $__m.int;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      stringify = $__m.stringify;
      getMapKey = $__m.getMapKey;
      looseIdentical = $__m.looseIdentical;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      IterableChangesFactory = (function() {
        function IterableChangesFactory() {}
        return ($traceurRuntime.createClass)(IterableChangesFactory, {
          supports: function(obj) {
            return IterableChanges.supportsObj(obj);
          },
          create: function(cdRef) {
            return new IterableChanges();
          }
        }, {});
      }());
      $__export("IterableChangesFactory", IterableChangesFactory);
      IterableChanges = (function($__super) {
        function IterableChanges() {
          $traceurRuntime.superConstructor(IterableChanges).call(this);
          this._collection = null;
          this._length = null;
          this._linkedRecords = null;
          this._unlinkedRecords = null;
          this._previousItHead = null;
          this._itHead = null;
          this._itTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._movesHead = null;
          this._movesTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(IterableChanges, {
          supports: function(obj) {
            return IterableChanges.supportsObj(obj);
          },
          get collection() {
            return this._collection;
          },
          get length() {
            return this._length;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._itHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachMovedItem: function(fn) {
            var record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          transform: function(collection) {
            if (this.check(collection)) {
              return WrappedValue.wrap(this);
            } else {
              return this;
            }
          },
          check: function(collection) {
            var $__0 = this;
            this._reset();
            var record = this._itHead;
            var mayBeDirty = false;
            var index;
            var item;
            if (ListWrapper.isList(collection)) {
              var list = collection;
              this._length = collection.length;
              for (index = 0; index < this._length; index++) {
                item = list[index];
                if (record === null || !looseIdentical(record.item, item)) {
                  record = this._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = this._verifyReinsertion(record, item, index);
                }
                record = record._next;
              }
            } else {
              index = 0;
              iterateListLike(collection, (function(item) {
                if (record === null || !looseIdentical(record.item, item)) {
                  record = $__0._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = $__0._verifyReinsertion(record, item, index);
                }
                record = record._next;
                index++;
              }));
              this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
          },
          get isDirty() {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              var nextRecord;
              for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
              }
              this._additionsHead = this._additionsTail = null;
              for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
              }
              this._movesHead = this._movesTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _mismatch: function(record, item, index) {
            var previousRecord;
            if (record === null) {
              previousRecord = this._itTail;
            } else {
              previousRecord = record._prev;
              this._remove(record);
            }
            record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
            if (record !== null) {
              this._moveAfter(record, previousRecord, index);
            } else {
              record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
              if (record !== null) {
                this._reinsertAfter(record, previousRecord, index);
              } else {
                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
              }
            }
            return record;
          },
          _verifyReinsertion: function(record, item, index) {
            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
            if (reinsertRecord !== null) {
              record = this._reinsertAfter(reinsertRecord, record._prev, index);
            } else if (record.currentIndex != index) {
              record.currentIndex = index;
              this._addToMoves(record, index);
            }
            return record;
          },
          _truncate: function(record) {
            while (record !== null) {
              var nextRecord = record._next;
              this._addToRemovals(this._unlink(record));
              record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
              this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
              this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
              this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
              this._removalsTail._nextRemoved = null;
            }
          },
          _reinsertAfter: function(record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.remove(record);
            }
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _moveAfter: function(record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _addAfter: function(record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
              this._additionsTail = this._additionsHead = record;
            } else {
              this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
          },
          _insertAfter: function(record, prevRecord, index) {
            var next = prevRecord === null ? this._itHead : prevRecord._next;
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
              this._itTail = record;
            } else {
              next._prev = record;
            }
            if (prevRecord === null) {
              this._itHead = record;
            } else {
              prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
              this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
          },
          _remove: function(record) {
            return this._addToRemovals(this._unlink(record));
          },
          _unlink: function(record) {
            if (this._linkedRecords !== null) {
              this._linkedRecords.remove(record);
            }
            var prev = record._prev;
            var next = record._next;
            if (prev === null) {
              this._itHead = next;
            } else {
              prev._next = next;
            }
            if (next === null) {
              this._itTail = prev;
            } else {
              next._prev = prev;
            }
            return record;
          },
          _addToMoves: function(record, toIndex) {
            if (record.previousIndex === toIndex) {
              return record;
            }
            if (this._movesTail === null) {
              this._movesTail = this._movesHead = record;
            } else {
              this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
          },
          _addToRemovals: function(record) {
            if (this._unlinkedRecords === null) {
              this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
              this._removalsTail = this._removalsHead = record;
              record._prevRemoved = null;
            } else {
              record._prevRemoved = this._removalsTail;
              this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
          },
          toString: function() {
            var record;
            var list = [];
            for (record = this._itHead; record !== null; record = record._next) {
              ListWrapper.push(list, record);
            }
            var previous = [];
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              ListWrapper.push(previous, record);
            }
            var additions = [];
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              ListWrapper.push(additions, record);
            }
            var moves = [];
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              ListWrapper.push(moves, record);
            }
            var removals = [];
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              ListWrapper.push(removals, record);
            }
            return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          }
        }, {supportsObj: function(obj) {
            return isListLikeIterable(obj);
          }}, $__super);
      }(Pipe));
      $__export("IterableChanges", IterableChanges);
      Object.defineProperty(IterableChanges.prototype.forEachItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(IterableChanges.prototype.forEachPreviousItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(IterableChanges.prototype.forEachAddedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(IterableChanges.prototype.forEachMovedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(IterableChanges.prototype.forEachRemovedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(IterableChanges.prototype._mismatch, "parameters", {get: function() {
          return [[CollectionChangeRecord], [], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._verifyReinsertion, "parameters", {get: function() {
          return [[CollectionChangeRecord], [], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._truncate, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      Object.defineProperty(IterableChanges.prototype._reinsertAfter, "parameters", {get: function() {
          return [[CollectionChangeRecord], [CollectionChangeRecord], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._moveAfter, "parameters", {get: function() {
          return [[CollectionChangeRecord], [CollectionChangeRecord], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._addAfter, "parameters", {get: function() {
          return [[CollectionChangeRecord], [CollectionChangeRecord], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._insertAfter, "parameters", {get: function() {
          return [[CollectionChangeRecord], [CollectionChangeRecord], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._remove, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      Object.defineProperty(IterableChanges.prototype._unlink, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      Object.defineProperty(IterableChanges.prototype._addToMoves, "parameters", {get: function() {
          return [[CollectionChangeRecord], [int]];
        }});
      Object.defineProperty(IterableChanges.prototype._addToRemovals, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      CollectionChangeRecord = (function() {
        function CollectionChangeRecord(item) {
          this.currentIndex = null;
          this.previousIndex = null;
          this.item = item;
          this._nextPrevious = null;
          this._prev = null;
          this._next = null;
          this._prevDup = null;
          this._nextDup = null;
          this._prevRemoved = null;
          this._nextRemoved = null;
          this._nextAdded = null;
          this._nextMoved = null;
        }
        return ($traceurRuntime.createClass)(CollectionChangeRecord, {toString: function() {
            return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
          }}, {});
      }());
      $__export("CollectionChangeRecord", CollectionChangeRecord);
      _DuplicateItemRecordList = (function() {
        function _DuplicateItemRecordList() {
          this._head = null;
          this._tail = null;
        }
        return ($traceurRuntime.createClass)(_DuplicateItemRecordList, {
          add: function(record) {
            if (this._head === null) {
              this._head = this._tail = record;
              record._nextDup = null;
              record._prevDup = null;
            } else {
              this._tail._nextDup = record;
              record._prevDup = this._tail;
              record._nextDup = null;
              this._tail = record;
            }
          },
          get: function(item, afterIndex) {
            var record;
            for (record = this._head; record !== null; record = record._nextDup) {
              if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.item, item)) {
                return record;
              }
            }
            return null;
          },
          remove: function(record) {
            var prev = record._prevDup;
            var next = record._nextDup;
            if (prev === null) {
              this._head = next;
            } else {
              prev._nextDup = next;
            }
            if (next === null) {
              this._tail = prev;
            } else {
              next._prevDup = prev;
            }
            return this._head === null;
          }
        }, {});
      }());
      Object.defineProperty(_DuplicateItemRecordList.prototype.add, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      Object.defineProperty(_DuplicateItemRecordList.prototype.get, "parameters", {get: function() {
          return [[], [int]];
        }});
      Object.defineProperty(_DuplicateItemRecordList.prototype.remove, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      _DuplicateMap = (function() {
        function _DuplicateMap() {
          this.map = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(_DuplicateMap, {
          put: function(record) {
            var key = getMapKey(record.item);
            var duplicates = MapWrapper.get(this.map, key);
            if (!isPresent(duplicates)) {
              duplicates = new _DuplicateItemRecordList();
              MapWrapper.set(this.map, key, duplicates);
            }
            duplicates.add(record);
          },
          get: function(value) {
            var afterIndex = arguments[1] !== (void 0) ? arguments[1] : null;
            var key = getMapKey(value);
            var recordList = MapWrapper.get(this.map, key);
            return isBlank(recordList) ? null : recordList.get(value, afterIndex);
          },
          remove: function(record) {
            var key = getMapKey(record.item);
            var recordList = MapWrapper.get(this.map, key);
            if (recordList.remove(record)) {
              MapWrapper.delete(this.map, key);
            }
            return record;
          },
          get isEmpty() {
            return MapWrapper.size(this.map) === 0;
          },
          clear: function() {
            MapWrapper.clear(this.map);
          },
          toString: function() {
            return '_DuplicateMap(' + stringify(this.map) + ')';
          }
        }, {});
      }());
      Object.defineProperty(_DuplicateMap.prototype.put, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
      Object.defineProperty(_DuplicateMap.prototype.remove, "parameters", {get: function() {
          return [[CollectionChangeRecord]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/pipes/keyvalue_changes", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/keyvalue_changes";
  var ListWrapper,
      MapWrapper,
      StringMapWrapper,
      stringify,
      looseIdentical,
      isJsObject,
      WrappedValue,
      Pipe,
      KeyValueChangesFactory,
      KeyValueChanges,
      KVChangeRecord;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      looseIdentical = $__m.looseIdentical;
      isJsObject = $__m.isJsObject;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      KeyValueChangesFactory = (function() {
        function KeyValueChangesFactory() {}
        return ($traceurRuntime.createClass)(KeyValueChangesFactory, {
          supports: function(obj) {
            return KeyValueChanges.supportsObj(obj);
          },
          create: function(cdRef) {
            return new KeyValueChanges();
          }
        }, {});
      }());
      $__export("KeyValueChangesFactory", KeyValueChangesFactory);
      KeyValueChanges = (function($__super) {
        function KeyValueChanges() {
          $traceurRuntime.superConstructor(KeyValueChanges).call(this);
          this._records = MapWrapper.create();
          this._mapHead = null;
          this._previousMapHead = null;
          this._changesHead = null;
          this._changesTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(KeyValueChanges, {
          supports: function(obj) {
            return KeyValueChanges.supportsObj(obj);
          },
          transform: function(map) {
            if (this.check(map)) {
              return WrappedValue.wrap(this);
            } else {
              return this;
            }
          },
          get isDirty() {
            return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachChangedItem: function(fn) {
            var record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          check: function(map) {
            var $__0 = this;
            this._reset();
            var records = this._records;
            var oldSeqRecord = this._mapHead;
            var lastOldSeqRecord = null;
            var lastNewSeqRecord = null;
            var seqChanged = false;
            this._forEach(map, (function(value, key) {
              var newSeqRecord;
              if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!looseIdentical(value, oldSeqRecord.currentValue)) {
                  oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                  oldSeqRecord.currentValue = value;
                  $__0._addToChanges(oldSeqRecord);
                }
              } else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                  oldSeqRecord._next = null;
                  $__0._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                  $__0._addToRemovals(oldSeqRecord);
                }
                if (MapWrapper.contains(records, key)) {
                  newSeqRecord = MapWrapper.get(records, key);
                } else {
                  newSeqRecord = new KVChangeRecord(key);
                  MapWrapper.set(records, key, newSeqRecord);
                  newSeqRecord.currentValue = value;
                  $__0._addToAdditions(newSeqRecord);
                }
              }
              if (seqChanged) {
                if ($__0._isInRemovals(newSeqRecord)) {
                  $__0._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                  $__0._mapHead = newSeqRecord;
                } else {
                  lastNewSeqRecord._next = newSeqRecord;
                }
              }
              lastOldSeqRecord = oldSeqRecord;
              lastNewSeqRecord = newSeqRecord;
              oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
            }));
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
              }
              for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
              }
              this._changesHead = this._changesTail = null;
              this._additionsHead = this._additionsTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _truncate: function(lastRecord, record) {
            while (record !== null) {
              if (lastRecord === null) {
                this._mapHead = null;
              } else {
                lastRecord._next = null;
              }
              var nextRecord = record._next;
              this._addToRemovals(record);
              lastRecord = record;
              record = nextRecord;
            }
            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
              rec.previousValue = rec.currentValue;
              rec.currentValue = null;
              MapWrapper.delete(this._records, rec.key);
            }
          },
          _isInRemovals: function(record) {
            return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
          },
          _addToRemovals: function(record) {
            if (this._removalsHead === null) {
              this._removalsHead = this._removalsTail = record;
            } else {
              this._removalsTail._nextRemoved = record;
              record._prevRemoved = this._removalsTail;
              this._removalsTail = record;
            }
          },
          _removeFromSeq: function(prev, record) {
            var next = record._next;
            if (prev === null) {
              this._mapHead = next;
            } else {
              prev._next = next;
            }
          },
          _removeFromRemovals: function(record) {
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
          },
          _addToAdditions: function(record) {
            if (this._additionsHead === null) {
              this._additionsHead = this._additionsTail = record;
            } else {
              this._additionsTail._nextAdded = record;
              this._additionsTail = record;
            }
          },
          _addToChanges: function(record) {
            if (this._changesHead === null) {
              this._changesHead = this._changesTail = record;
            } else {
              this._changesTail._nextChanged = record;
              this._changesTail = record;
            }
          },
          toString: function() {
            var items = [];
            var previous = [];
            var changes = [];
            var additions = [];
            var removals = [];
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              ListWrapper.push(items, stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              ListWrapper.push(previous, stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              ListWrapper.push(changes, stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              ListWrapper.push(additions, stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              ListWrapper.push(removals, stringify(record));
            }
            return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          },
          _forEach: function(obj, fn) {
            if (obj instanceof Map) {
              MapWrapper.forEach(obj, fn);
            } else {
              StringMapWrapper.forEach(obj, fn);
            }
          }
        }, {supportsObj: function(obj) {
            return obj instanceof Map || isJsObject(obj);
          }}, $__super);
      }(Pipe));
      $__export("KeyValueChanges", KeyValueChanges);
      Object.defineProperty(KeyValueChanges.prototype.forEachItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(KeyValueChanges.prototype.forEachPreviousItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(KeyValueChanges.prototype.forEachChangedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(KeyValueChanges.prototype.forEachAddedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(KeyValueChanges.prototype.forEachRemovedItem, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._truncate, "parameters", {get: function() {
          return [[KVChangeRecord], [KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._isInRemovals, "parameters", {get: function() {
          return [[KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._addToRemovals, "parameters", {get: function() {
          return [[KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._removeFromSeq, "parameters", {get: function() {
          return [[KVChangeRecord], [KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._removeFromRemovals, "parameters", {get: function() {
          return [[KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._addToAdditions, "parameters", {get: function() {
          return [[KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._addToChanges, "parameters", {get: function() {
          return [[KVChangeRecord]];
        }});
      Object.defineProperty(KeyValueChanges.prototype._forEach, "parameters", {get: function() {
          return [[], [Function]];
        }});
      KVChangeRecord = (function() {
        function KVChangeRecord(key) {
          this.key = key;
          this.previousValue = null;
          this.currentValue = null;
          this._nextPrevious = null;
          this._next = null;
          this._nextAdded = null;
          this._nextRemoved = null;
          this._prevRemoved = null;
          this._nextChanged = null;
        }
        return ($traceurRuntime.createClass)(KVChangeRecord, {toString: function() {
            return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : (stringify(this.key) + '[' + stringify(this.previousValue) + '->' + stringify(this.currentValue) + ']');
          }}, {});
      }());
      $__export("KVChangeRecord", KVChangeRecord);
    }
  };
});

System.register("angular2/src/change_detection/pipes/async_pipe", ["angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe", "angular2/src/change_detection/change_detector_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/async_pipe";
  var Observable,
      ObservableWrapper,
      isBlank,
      isPresent,
      Pipe,
      WrappedValue,
      ChangeDetectorRef,
      AsyncPipe,
      AsyncPipeFactory;
  return {
    setters: [function($__m) {
      Observable = $__m.Observable;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      Pipe = $__m.Pipe;
      WrappedValue = $__m.WrappedValue;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }],
    execute: function() {
      AsyncPipe = (function($__super) {
        function AsyncPipe(ref) {
          $traceurRuntime.superConstructor(AsyncPipe).call(this);
          this._ref = ref;
          this._latestValue = null;
          this._latestReturnedValue = null;
          this._subscription = null;
          this._observable = null;
        }
        return ($traceurRuntime.createClass)(AsyncPipe, {
          supports: function(obs) {
            return ObservableWrapper.isObservable(obs);
          },
          onDestroy: function() {
            if (isPresent(this._subscription)) {
              this._dispose();
            }
            ;
          },
          transform: function(obs) {
            if (isBlank(this._subscription)) {
              this._subscribe(obs);
              return null;
            }
            if (obs !== this._observable) {
              this._dispose();
              return this.transform(obs);
            }
            if (this._latestValue === this._latestReturnedValue) {
              return this._latestReturnedValue;
            } else {
              this._latestReturnedValue = this._latestValue;
              return WrappedValue.wrap(this._latestValue);
            }
          },
          _subscribe: function(obs) {
            var $__0 = this;
            this._observable = obs;
            this._subscription = ObservableWrapper.subscribe(obs, (function(value) {
              return $__0._updateLatestValue(value);
            }), (function(e) {
              throw e;
            }));
          },
          _dispose: function() {
            ObservableWrapper.dispose(this._subscription);
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._observable = null;
          },
          _updateLatestValue: function(value) {
            this._latestValue = value;
            this._ref.requestCheck();
          }
        }, {}, $__super);
      }(Pipe));
      $__export("AsyncPipe", AsyncPipe);
      Object.defineProperty(AsyncPipe, "parameters", {get: function() {
          return [[ChangeDetectorRef]];
        }});
      Object.defineProperty(AsyncPipe.prototype.transform, "parameters", {get: function() {
          return [[Observable]];
        }});
      Object.defineProperty(AsyncPipe.prototype._subscribe, "parameters", {get: function() {
          return [[Observable]];
        }});
      Object.defineProperty(AsyncPipe.prototype._updateLatestValue, "parameters", {get: function() {
          return [[Object]];
        }});
      AsyncPipeFactory = (function() {
        function AsyncPipeFactory() {}
        return ($traceurRuntime.createClass)(AsyncPipeFactory, {
          supports: function(obs) {
            return ObservableWrapper.isObservable(obs);
          },
          create: function(cdRef) {
            return new AsyncPipe(cdRef);
          }
        }, {});
      }());
      $__export("AsyncPipeFactory", AsyncPipeFactory);
    }
  };
});

System.register("angular2/src/change_detection/pipes/null_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/null_pipe";
  var isBlank,
      Pipe,
      WrappedValue,
      NullPipeFactory,
      NullPipe;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
    }, function($__m) {
      Pipe = $__m.Pipe;
      WrappedValue = $__m.WrappedValue;
    }],
    execute: function() {
      NullPipeFactory = (function() {
        function NullPipeFactory() {}
        return ($traceurRuntime.createClass)(NullPipeFactory, {
          supports: function(obj) {
            return NullPipe.supportsObj(obj);
          },
          create: function(cdRef) {
            return new NullPipe();
          }
        }, {});
      }());
      $__export("NullPipeFactory", NullPipeFactory);
      NullPipe = (function($__super) {
        function NullPipe() {
          $traceurRuntime.superConstructor(NullPipe).call(this);
          this.called = false;
        }
        return ($traceurRuntime.createClass)(NullPipe, {
          supports: function(obj) {
            return NullPipe.supportsObj(obj);
          },
          transform: function(value) {
            if (!this.called) {
              this.called = true;
              return WrappedValue.wrap(null);
            } else {
              return null;
            }
          }
        }, {supportsObj: function(obj) {
            return isBlank(obj);
          }}, $__super);
      }(Pipe));
      $__export("NullPipe", NullPipe);
    }
  };
});

System.register("angular2/src/core/annotations_impl/visibility", ["angular2/src/facade/lang", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/visibility";
  var CONST,
      DependencyAnnotation,
      Parent,
      Ancestor;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      DependencyAnnotation = $__m.DependencyAnnotation;
    }],
    execute: function() {
      Parent = (function($__super) {
        function Parent() {
          $traceurRuntime.superConstructor(Parent).call(this);
        }
        return ($traceurRuntime.createClass)(Parent, {}, {}, $__super);
      }(DependencyAnnotation));
      $__export("Parent", Parent);
      Object.defineProperty(Parent, "annotations", {get: function() {
          return [new CONST()];
        }});
      Ancestor = (function($__super) {
        function Ancestor() {
          $traceurRuntime.superConstructor(Ancestor).call(this);
        }
        return ($traceurRuntime.createClass)(Ancestor, {}, {}, $__super);
      }(DependencyAnnotation));
      $__export("Ancestor", Ancestor);
      Object.defineProperty(Ancestor, "annotations", {get: function() {
          return [new CONST()];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/interfaces", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/interfaces";
  var OnChange;
  return {
    setters: [],
    execute: function() {
      OnChange = (function() {
        function OnChange() {}
        return ($traceurRuntime.createClass)(OnChange, {onChange: function(changes) {
            throw "OnChange.onChange is not implemented";
          }}, {});
      }());
      $__export("OnChange", OnChange);
    }
  };
});

System.register("angular2/src/core/annotations_impl/view", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/view";
  var ABSTRACT,
      CONST,
      Type,
      View;
  return {
    setters: [function($__m) {
      ABSTRACT = $__m.ABSTRACT;
      CONST = $__m.CONST;
      Type = $__m.Type;
    }],
    execute: function() {
      View = (function() {
        function View($__1) {
          var $__2 = $__1,
              templateUrl = $__2.templateUrl,
              template = $__2.template,
              directives = $__2.directives,
              renderer = $__2.renderer;
          this.templateUrl = templateUrl;
          this.template = template;
          this.directives = directives;
          this.renderer = renderer;
        }
        return ($traceurRuntime.createClass)(View, {}, {});
      }());
      $__export("View", View);
      Object.defineProperty(View, "annotations", {get: function() {
          return [new CONST()];
        }});
    }
  };
});

System.register("angular2/src/dom/dom_adapter", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/dom_adapter";
  var ABSTRACT,
      BaseException,
      DOM,
      DomAdapter;
  function setRootDomAdapter(adapter) {
    $__export("DOM", DOM = adapter);
  }
  function _abstract() {
    return new BaseException('This method is abstract');
  }
  $__export("setRootDomAdapter", setRootDomAdapter);
  return {
    setters: [function($__m) {
      ABSTRACT = $__m.ABSTRACT;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      $__export("DOM", DOM);
      Object.defineProperty(setRootDomAdapter, "parameters", {get: function() {
          return [[DomAdapter]];
        }});
      DomAdapter = (function() {
        function DomAdapter() {}
        return ($traceurRuntime.createClass)(DomAdapter, {
          logError: function(error) {
            throw _abstract();
          },
          get attrToPropMap() {
            throw _abstract();
          },
          parse: function(templateHtml) {
            throw _abstract();
          },
          query: function(selector) {
            throw _abstract();
          },
          querySelector: function(el, selector) {
            throw _abstract();
          },
          querySelectorAll: function(el, selector) {
            throw _abstract();
          },
          on: function(el, evt, listener) {
            throw _abstract();
          },
          onAndCancel: function(el, evt, listener) {
            throw _abstract();
          },
          dispatchEvent: function(el, evt) {
            throw _abstract();
          },
          createMouseEvent: function(eventType) {
            throw _abstract();
          },
          createEvent: function(eventType) {
            throw _abstract();
          },
          getInnerHTML: function(el) {
            throw _abstract();
          },
          getOuterHTML: function(el) {
            throw _abstract();
          },
          nodeName: function(node) {
            throw _abstract();
          },
          nodeValue: function(node) {
            throw _abstract();
          },
          type: function(node) {
            throw _abstract();
          },
          content: function(node) {
            throw _abstract();
          },
          firstChild: function(el) {
            throw _abstract();
          },
          nextSibling: function(el) {
            throw _abstract();
          },
          parentElement: function(el) {
            throw _abstract();
          },
          childNodes: function(el) {
            throw _abstract();
          },
          childNodesAsList: function(el) {
            throw _abstract();
          },
          clearNodes: function(el) {
            throw _abstract();
          },
          appendChild: function(el, node) {
            throw _abstract();
          },
          removeChild: function(el, node) {
            throw _abstract();
          },
          replaceChild: function(el, newNode, oldNode) {
            throw _abstract();
          },
          remove: function(el) {
            throw _abstract();
          },
          insertBefore: function(el, node) {
            throw _abstract();
          },
          insertAllBefore: function(el, nodes) {
            throw _abstract();
          },
          insertAfter: function(el, node) {
            throw _abstract();
          },
          setInnerHTML: function(el, value) {
            throw _abstract();
          },
          getText: function(el) {
            throw _abstract();
          },
          setText: function(el, value) {
            throw _abstract();
          },
          getValue: function(el) {
            throw _abstract();
          },
          setValue: function(el, value) {
            throw _abstract();
          },
          getChecked: function(el) {
            throw _abstract();
          },
          setChecked: function(el, value) {
            throw _abstract();
          },
          createTemplate: function(html) {
            throw _abstract();
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : null;
            throw _abstract();
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createShadowRoot: function(el) {
            throw _abstract();
          },
          getShadowRoot: function(el) {
            throw _abstract();
          },
          getHost: function(el) {
            throw _abstract();
          },
          getDistributedNodes: function(el) {
            throw _abstract();
          },
          clone: function(node) {
            throw _abstract();
          },
          hasProperty: function(element, name) {
            throw _abstract();
          },
          getElementsByClassName: function(element, name) {
            throw _abstract();
          },
          getElementsByTagName: function(element, name) {
            throw _abstract();
          },
          classList: function(element) {
            throw _abstract();
          },
          addClass: function(element, classname) {
            throw _abstract();
          },
          removeClass: function(element, classname) {
            throw _abstract();
          },
          hasClass: function(element, classname) {
            throw _abstract();
          },
          setStyle: function(element, stylename, stylevalue) {
            throw _abstract();
          },
          removeStyle: function(element, stylename) {
            throw _abstract();
          },
          getStyle: function(element, stylename) {
            throw _abstract();
          },
          tagName: function(element) {
            throw _abstract();
          },
          attributeMap: function(element) {
            throw _abstract();
          },
          getAttribute: function(element, attribute) {
            throw _abstract();
          },
          setAttribute: function(element, name, value) {
            throw _abstract();
          },
          removeAttribute: function(element, attribute) {
            throw _abstract();
          },
          templateAwareRoot: function(el) {
            throw _abstract();
          },
          createHtmlDocument: function() {
            throw _abstract();
          },
          defaultDoc: function() {
            throw _abstract();
          },
          getBoundingClientRect: function(el) {
            throw _abstract();
          },
          getTitle: function() {
            throw _abstract();
          },
          setTitle: function(newTitle) {
            throw _abstract();
          },
          elementMatches: function(n, selector) {
            throw _abstract();
          },
          isTemplateElement: function(el) {
            throw _abstract();
          },
          isTextNode: function(node) {
            throw _abstract();
          },
          isCommentNode: function(node) {
            throw _abstract();
          },
          isElementNode: function(node) {
            throw _abstract();
          },
          hasShadowRoot: function(node) {
            throw _abstract();
          },
          isShadowRoot: function(node) {
            throw _abstract();
          },
          importIntoDoc: function(node) {
            throw _abstract();
          },
          isPageRule: function(rule) {
            throw _abstract();
          },
          isStyleRule: function(rule) {
            throw _abstract();
          },
          isMediaRule: function(rule) {
            throw _abstract();
          },
          isKeyframesRule: function(rule) {
            throw _abstract();
          },
          getHref: function(element) {
            throw _abstract();
          },
          getEventKey: function(event) {
            throw _abstract();
          },
          resolveAndSetHref: function(element, baseUrl, href) {
            throw _abstract();
          },
          cssToRules: function(css) {
            throw _abstract();
          },
          supportsDOMEvents: function() {
            throw _abstract();
          },
          supportsNativeShadowDOM: function() {
            throw _abstract();
          },
          getGlobalEventTarget: function(target) {
            throw _abstract();
          }
        }, {});
      }());
      $__export("DomAdapter", DomAdapter);
      Object.defineProperty(DomAdapter, "annotations", {get: function() {
          return [new ABSTRACT()];
        }});
      Object.defineProperty(DomAdapter.prototype.parse, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.query, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.querySelector, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.querySelectorAll, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setText, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setValue, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setChecked, "parameters", {get: function() {
          return [[], [assert.type.boolean]];
        }});
      Object.defineProperty(DomAdapter.prototype.createTextNode, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
      Object.defineProperty(DomAdapter.prototype.createScriptTag, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
      Object.defineProperty(DomAdapter.prototype.createStyleElement, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
      Object.defineProperty(DomAdapter.prototype.hasProperty, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.getElementsByClassName, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.getElementsByTagName, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.addClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.removeClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.hasClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setStyle, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.removeStyle, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.getStyle, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.getAttribute, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setAttribute, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.removeAttribute, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.setTitle, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.elementMatches, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.isTemplateElement, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(DomAdapter.prototype.resolveAndSetHref, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.cssToRules, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(DomAdapter.prototype.getGlobalEventTarget, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/dom/generic_browser_adapter", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/generic_browser_adapter";
  var ABSTRACT,
      List,
      ListWrapper,
      isPresent,
      isFunction,
      DomAdapter,
      GenericBrowserDomAdapter;
  return {
    setters: [function($__m) {
      ABSTRACT = $__m.ABSTRACT;
      isPresent = $__m.isPresent;
      isFunction = $__m.isFunction;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      DomAdapter = $__m.DomAdapter;
    }],
    execute: function() {
      GenericBrowserDomAdapter = (function($__super) {
        function GenericBrowserDomAdapter() {
          $traceurRuntime.superConstructor(GenericBrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(GenericBrowserDomAdapter, {
          getDistributedNodes: function(el) {
            return el.getDistributedNodes();
          },
          resolveAndSetHref: function(el, baseUrl, href) {
            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
          },
          cssToRules: function(css) {
            var style = this.createStyleElement(css);
            this.appendChild(this.defaultDoc().head, style);
            var rules = ListWrapper.create();
            if (isPresent(style.sheet)) {
              try {
                var rawRules = style.sheet.cssRules;
                rules = ListWrapper.createFixedSize(rawRules.length);
                for (var i = 0; i < rawRules.length; i++) {
                  rules[i] = rawRules[i];
                }
              } catch (e) {}
            } else {}
            this.remove(style);
            return rules;
          },
          supportsDOMEvents: function() {
            return true;
          },
          supportsNativeShadowDOM: function() {
            return isFunction(this.defaultDoc().body.createShadowRoot);
          }
        }, {}, $__super);
      }(DomAdapter));
      $__export("GenericBrowserDomAdapter", GenericBrowserDomAdapter);
      Object.defineProperty(GenericBrowserDomAdapter, "annotations", {get: function() {
          return [new ABSTRACT()];
        }});
      Object.defineProperty(GenericBrowserDomAdapter.prototype.resolveAndSetHref, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(GenericBrowserDomAdapter.prototype.cssToRules, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/core/annotations_impl/annotations", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/di", "angular2/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/annotations";
  var CONST,
      normalizeBlank,
      isPresent,
      ListWrapper,
      List,
      Injectable,
      DEFAULT,
      Directive,
      Component,
      onDestroy,
      onChange,
      onAllChangesDone;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      normalizeBlank = $__m.normalizeBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      DEFAULT = $__m.DEFAULT;
    }],
    execute: function() {
      Directive = (function($__super) {
        function Directive() {
          var $__2;
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__1.selector,
              properties = $__1.properties,
              events = $__1.events,
              hostListeners = $__1.hostListeners,
              hostProperties = $__1.hostProperties,
              lifecycle = $__1.lifecycle,
              compileChildren = ($__2 = $__1.compileChildren) === void 0 ? true : $__2;
          $traceurRuntime.superConstructor(Directive).call(this);
          this.selector = selector;
          this.properties = properties;
          this.events = events;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.lifecycle = lifecycle;
          this.compileChildren = compileChildren;
        }
        return ($traceurRuntime.createClass)(Directive, {hasLifecycleHook: function(hook) {
            return isPresent(this.lifecycle) ? ListWrapper.contains(this.lifecycle, hook) : false;
          }}, {}, $__super);
      }(Injectable));
      $__export("Directive", Directive);
      Object.defineProperty(Directive, "annotations", {get: function() {
          return [new CONST()];
        }});
      Object.defineProperty(Directive.prototype.hasLifecycleHook, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Component = (function($__super) {
        function Component() {
          var $__2,
              $__3;
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__1.selector,
              properties = $__1.properties,
              events = $__1.events,
              hostListeners = $__1.hostListeners,
              hostProperties = $__1.hostProperties,
              injectables = $__1.injectables,
              lifecycle = $__1.lifecycle,
              changeDetection = ($__2 = $__1.changeDetection) === void 0 ? DEFAULT : $__2,
              compileChildren = ($__3 = $__1.compileChildren) === void 0 ? true : $__3;
          $traceurRuntime.superConstructor(Component).call(this, {
            selector: selector,
            properties: properties,
            events: events,
            hostListeners: hostListeners,
            hostProperties: hostProperties,
            lifecycle: lifecycle,
            compileChildren: compileChildren
          });
          this.changeDetection = changeDetection;
          this.injectables = injectables;
        }
        return ($traceurRuntime.createClass)(Component, {}, {}, $__super);
      }(Directive));
      $__export("Component", Component);
      Object.defineProperty(Component, "annotations", {get: function() {
          return [new CONST()];
        }});
      onDestroy = "onDestroy";
      $__export("onDestroy", onDestroy);
      onChange = "onChange";
      $__export("onChange", onChange);
      onAllChangesDone = "onAllChangesDone";
      $__export("onAllChangesDone", onAllChangesDone);
    }
  };
});

System.register("angular2/src/core/compiler/directive_metadata", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/core/annotations_impl/annotations", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_metadata";
  var Type,
      List,
      Directive,
      ResolvedBinding,
      DirectiveMetadata;
  return {
    setters: [function($__m) {
      Type = $__m.Type;
    }, function($__m) {
      List = $__m.List;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ResolvedBinding = $__m.ResolvedBinding;
    }],
    execute: function() {
      DirectiveMetadata = (function() {
        function DirectiveMetadata(type, annotation, resolvedInjectables) {
          this.annotation = annotation;
          this.type = type;
          this.resolvedInjectables = resolvedInjectables;
        }
        return ($traceurRuntime.createClass)(DirectiveMetadata, {}, {});
      }());
      $__export("DirectiveMetadata", DirectiveMetadata);
      Object.defineProperty(DirectiveMetadata, "parameters", {get: function() {
          return [[Type], [Directive], [assert.genericType(List, ResolvedBinding)]];
        }});
    }
  };
});

System.register("angular2/src/facade/math", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/math";
  var global,
      __esModule,
      Math,
      NaN;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      Math = global.Math;
      $__export("Math", Math);
      NaN = typeof NaN;
      $__export("NaN", NaN);
    }
  };
});

System.register("angular2/src/core/annotations_impl/di", ["angular2/src/facade/lang", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/di";
  var CONST,
      DependencyAnnotation,
      Attribute,
      Query;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      DependencyAnnotation = $__m.DependencyAnnotation;
    }],
    execute: function() {
      Attribute = (function($__super) {
        function Attribute(attributeName) {
          $traceurRuntime.superConstructor(Attribute).call(this);
          this.attributeName = attributeName;
        }
        return ($traceurRuntime.createClass)(Attribute, {get token() {
            return this;
          }}, {}, $__super);
      }(DependencyAnnotation));
      $__export("Attribute", Attribute);
      Object.defineProperty(Attribute, "annotations", {get: function() {
          return [new CONST()];
        }});
      Query = (function($__super) {
        function Query(directive) {
          $traceurRuntime.superConstructor(Query).call(this);
          this.directive = directive;
        }
        return ($traceurRuntime.createClass)(Query, {}, {}, $__super);
      }(DependencyAnnotation));
      $__export("Query", Query);
      Object.defineProperty(Query, "annotations", {get: function() {
          return [new CONST()];
        }});
    }
  };
});

System.register("angular2/src/render/api", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/api";
  var isPresent,
      Promise,
      List,
      Map,
      ASTWithSource,
      EventBinding,
      ElementBinder,
      DirectiveBinder,
      ProtoViewDto,
      DirectiveMetadata,
      RenderProtoViewRef,
      RenderViewRef,
      RenderViewContainerRef,
      ViewDefinition,
      Renderer,
      EventDispatcher;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      List = $__m.List;
      Map = $__m.Map;
    }, function($__m) {
      ASTWithSource = $__m.ASTWithSource;
    }],
    execute: function() {
      EventBinding = (function() {
        function EventBinding(fullName, source) {
          this.fullName = fullName;
          this.source = source;
        }
        return ($traceurRuntime.createClass)(EventBinding, {}, {});
      }());
      $__export("EventBinding", EventBinding);
      Object.defineProperty(EventBinding, "parameters", {get: function() {
          return [[assert.type.string], [ASTWithSource]];
        }});
      ElementBinder = (function() {
        function ElementBinder($__1) {
          var $__2 = $__1,
              index = $__2.index,
              parentIndex = $__2.parentIndex,
              distanceToParent = $__2.distanceToParent,
              directives = $__2.directives,
              nestedProtoView = $__2.nestedProtoView,
              propertyBindings = $__2.propertyBindings,
              variableBindings = $__2.variableBindings,
              eventBindings = $__2.eventBindings,
              textBindings = $__2.textBindings,
              readAttributes = $__2.readAttributes;
          this.index = index;
          this.parentIndex = parentIndex;
          this.distanceToParent = distanceToParent;
          this.directives = directives;
          this.nestedProtoView = nestedProtoView;
          this.propertyBindings = propertyBindings;
          this.variableBindings = variableBindings;
          this.eventBindings = eventBindings;
          this.textBindings = textBindings;
          this.readAttributes = readAttributes;
        }
        return ($traceurRuntime.createClass)(ElementBinder, {}, {});
      }());
      $__export("ElementBinder", ElementBinder);
      DirectiveBinder = (function() {
        function DirectiveBinder($__1) {
          var $__2 = $__1,
              directiveIndex = $__2.directiveIndex,
              propertyBindings = $__2.propertyBindings,
              eventBindings = $__2.eventBindings,
              hostPropertyBindings = $__2.hostPropertyBindings;
          this.directiveIndex = directiveIndex;
          this.propertyBindings = propertyBindings;
          this.eventBindings = eventBindings;
          this.hostPropertyBindings = hostPropertyBindings;
        }
        return ($traceurRuntime.createClass)(DirectiveBinder, {}, {});
      }());
      $__export("DirectiveBinder", DirectiveBinder);
      ProtoViewDto = (function() {
        function ProtoViewDto() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              render = $__1.render,
              elementBinders = $__1.elementBinders,
              variableBindings = $__1.variableBindings,
              type = $__1.type;
          this.render = render;
          this.elementBinders = elementBinders;
          this.variableBindings = variableBindings;
          this.type = type;
        }
        return ($traceurRuntime.createClass)(ProtoViewDto, {}, {
          get HOST_VIEW_TYPE() {
            return 0;
          },
          get COMPONENT_VIEW_TYPE() {
            return 1;
          },
          get EMBEDDED_VIEW_TYPE() {
            return 1;
          }
        });
      }());
      $__export("ProtoViewDto", ProtoViewDto);
      DirectiveMetadata = (function() {
        function DirectiveMetadata($__1) {
          var $__2 = $__1,
              id = $__2.id,
              selector = $__2.selector,
              compileChildren = $__2.compileChildren,
              hostListeners = $__2.hostListeners,
              hostProperties = $__2.hostProperties,
              properties = $__2.properties,
              readAttributes = $__2.readAttributes,
              type = $__2.type;
          this.id = id;
          this.selector = selector;
          this.compileChildren = isPresent(compileChildren) ? compileChildren : true;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.properties = properties;
          this.readAttributes = readAttributes;
          this.type = type;
        }
        return ($traceurRuntime.createClass)(DirectiveMetadata, {}, {
          get DIRECTIVE_TYPE() {
            return 0;
          },
          get COMPONENT_TYPE() {
            return 1;
          }
        });
      }());
      $__export("DirectiveMetadata", DirectiveMetadata);
      RenderProtoViewRef = (function() {
        function RenderProtoViewRef() {}
        return ($traceurRuntime.createClass)(RenderProtoViewRef, {}, {});
      }());
      $__export("RenderProtoViewRef", RenderProtoViewRef);
      RenderViewRef = (function() {
        function RenderViewRef() {}
        return ($traceurRuntime.createClass)(RenderViewRef, {}, {});
      }());
      $__export("RenderViewRef", RenderViewRef);
      RenderViewContainerRef = (function() {
        function RenderViewContainerRef(view, elementIndex) {
          this.view = view;
          this.elementIndex = elementIndex;
        }
        return ($traceurRuntime.createClass)(RenderViewContainerRef, {}, {});
      }());
      $__export("RenderViewContainerRef", RenderViewContainerRef);
      Object.defineProperty(RenderViewContainerRef, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.number]];
        }});
      ViewDefinition = (function() {
        function ViewDefinition($__1) {
          var $__2 = $__1,
              componentId = $__2.componentId,
              absUrl = $__2.absUrl,
              template = $__2.template,
              directives = $__2.directives;
          this.componentId = componentId;
          this.absUrl = absUrl;
          this.template = template;
          this.directives = directives;
        }
        return ($traceurRuntime.createClass)(ViewDefinition, {}, {});
      }());
      $__export("ViewDefinition", ViewDefinition);
      Renderer = (function() {
        function Renderer() {}
        return ($traceurRuntime.createClass)(Renderer, {
          createHostProtoView: function(componentId) {
            return null;
          },
          createImperativeComponentProtoView: function(rendererId) {
            return null;
          },
          compile: function(template) {
            return null;
          },
          mergeChildComponentProtoViews: function(protoViewRef, componentProtoViewRefs) {
            return null;
          },
          createViewInContainer: function(vcRef, atIndex, protoViewRef) {
            return null;
          },
          destroyViewInContainer: function(vcRef, atIndex) {},
          insertViewIntoContainer: function(vcRef, atIndex, view) {},
          detachViewFromContainer: function(vcRef, atIndex) {},
          createDynamicComponentView: function(hostViewRef, elementIndex, componentProtoViewRef) {
            return null;
          },
          destroyDynamicComponentView: function(hostViewRef, elementIndex) {},
          createInPlaceHostView: function(parentViewRef, hostElementSelector, hostProtoViewRef) {
            return null;
          },
          destroyInPlaceHostView: function(parentViewRef, hostViewRef) {},
          setElementProperty: function(view, elementIndex, propertyName, propertyValue) {},
          setText: function(view, textNodeIndex, text) {},
          setEventDispatcher: function(viewRef, dispatcher) {},
          flush: function() {}
        }, {});
      }());
      $__export("Renderer", Renderer);
      Object.defineProperty(Renderer.prototype.compile, "parameters", {get: function() {
          return [[ViewDefinition]];
        }});
      Object.defineProperty(Renderer.prototype.mergeChildComponentProtoViews, "parameters", {get: function() {
          return [[RenderProtoViewRef], [assert.genericType(List, RenderProtoViewRef)]];
        }});
      Object.defineProperty(Renderer.prototype.createViewInContainer, "parameters", {get: function() {
          return [[RenderViewContainerRef], [assert.type.number], [RenderProtoViewRef]];
        }});
      Object.defineProperty(Renderer.prototype.destroyViewInContainer, "parameters", {get: function() {
          return [[RenderViewContainerRef], [assert.type.number]];
        }});
      Object.defineProperty(Renderer.prototype.insertViewIntoContainer, "parameters", {get: function() {
          return [[RenderViewContainerRef], [assert.type.number], [RenderViewRef]];
        }});
      Object.defineProperty(Renderer.prototype.detachViewFromContainer, "parameters", {get: function() {
          return [[RenderViewContainerRef], [assert.type.number]];
        }});
      Object.defineProperty(Renderer.prototype.createDynamicComponentView, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.number], [RenderProtoViewRef]];
        }});
      Object.defineProperty(Renderer.prototype.destroyDynamicComponentView, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.number]];
        }});
      Object.defineProperty(Renderer.prototype.createInPlaceHostView, "parameters", {get: function() {
          return [[RenderViewRef], [], [RenderProtoViewRef]];
        }});
      Object.defineProperty(Renderer.prototype.destroyInPlaceHostView, "parameters", {get: function() {
          return [[RenderViewRef], [RenderViewRef]];
        }});
      Object.defineProperty(Renderer.prototype.setElementProperty, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.number], [assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(Renderer.prototype.setText, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.number], [assert.type.string]];
        }});
      Object.defineProperty(Renderer.prototype.setEventDispatcher, "parameters", {get: function() {
          return [[RenderViewRef], [assert.type.any]];
        }});
      EventDispatcher = (function() {
        function EventDispatcher() {}
        return ($traceurRuntime.createClass)(EventDispatcher, {dispatchEvent: function(elementIndex, eventName, locals) {}}, {});
      }());
      $__export("EventDispatcher", EventDispatcher);
      Object.defineProperty(EventDispatcher.prototype.dispatchEvent, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [assert.genericType(Map, assert.type.string, assert.type.any)]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/view_container", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/view/view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view_container";
  var isPresent,
      isBlank,
      BaseException,
      ListWrapper,
      MapWrapper,
      List,
      DOM,
      viewModule,
      ViewContainer;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      List = $__m.List;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      viewModule = $__m;
    }],
    execute: function() {
      ViewContainer = (function() {
        function ViewContainer(parentView, boundElementIndex) {
          this.parentView = parentView;
          this.boundElementIndex = boundElementIndex;
          this.views = [];
        }
        return ($traceurRuntime.createClass)(ViewContainer, {
          get: function(index) {
            return this.views[index];
          },
          size: function() {
            return this.views.length;
          },
          _siblingToInsertAfter: function(index) {
            if (index == 0)
              return this.parentView.boundElements[this.boundElementIndex];
            return ListWrapper.last(this.views[index - 1].rootNodes);
          },
          _checkHydrated: function() {
            if (!this.parentView.hydrated)
              throw new BaseException('Cannot change dehydrated ViewContainer');
          },
          _getDirectParentLightDom: function() {
            return this.parentView.getDirectParentLightDom(this.boundElementIndex);
          },
          clear: function() {
            this._checkHydrated();
            for (var i = this.views.length - 1; i >= 0; i--) {
              this.detach(i);
            }
            if (isPresent(this._getDirectParentLightDom())) {
              this._getDirectParentLightDom().redistribute();
            }
          },
          insert: function(view) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            this._checkHydrated();
            if (atIndex == -1)
              atIndex = this.views.length;
            ListWrapper.insert(this.views, atIndex, view);
            if (isBlank(this._getDirectParentLightDom())) {
              ViewContainer.moveViewNodesAfterSibling(this._siblingToInsertAfter(atIndex), view);
            } else {
              this._getDirectParentLightDom().redistribute();
            }
            if (isPresent(this.parentView.hostLightDom)) {
              this.parentView.hostLightDom.redistribute();
            }
            return view;
          },
          detach: function(atIndex) {
            this._checkHydrated();
            var detachedView = this.get(atIndex);
            ListWrapper.removeAt(this.views, atIndex);
            if (isBlank(this._getDirectParentLightDom())) {
              ViewContainer.removeViewNodes(detachedView);
            } else {
              this._getDirectParentLightDom().redistribute();
            }
            if (isPresent(this.parentView.hostLightDom)) {
              this.parentView.hostLightDom.redistribute();
            }
            return detachedView;
          },
          contentTagContainers: function() {
            return this.views;
          },
          nodes: function() {
            var r = [];
            for (var i = 0; i < this.views.length; ++i) {
              r = ListWrapper.concat(r, this.views[i].rootNodes);
            }
            return r;
          }
        }, {
          moveViewNodesAfterSibling: function(sibling, view) {
            for (var i = view.rootNodes.length - 1; i >= 0; --i) {
              DOM.insertAfter(sibling, view.rootNodes[i]);
            }
          },
          removeViewNodes: function(view) {
            var len = view.rootNodes.length;
            if (len == 0)
              return ;
            var parent = view.rootNodes[0].parentNode;
            for (var i = len - 1; i >= 0; --i) {
              DOM.removeChild(parent, view.rootNodes[i]);
            }
          }
        });
      }());
      $__export("ViewContainer", ViewContainer);
      Object.defineProperty(ViewContainer, "parameters", {get: function() {
          return [[viewModule.RenderView], [assert.type.number]];
        }});
      Object.defineProperty(ViewContainer.prototype.get, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ViewContainer.prototype._siblingToInsertAfter, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ViewContainer.prototype.detach, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/element_binder", ["angular2/src/facade/lang", "angular2/change_detection", "angular2/src/reflection/types", "angular2/src/facade/collection", "angular2/src/render/dom/view/proto_view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/element_binder";
  var isBlank,
      isPresent,
      AST,
      SetterFn,
      List,
      ListWrapper,
      protoViewModule,
      ElementBinder,
      Event;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      AST = $__m.AST;
    }, function($__m) {
      SetterFn = $__m.SetterFn;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      protoViewModule = $__m;
    }],
    execute: function() {
      ElementBinder = (function() {
        function ElementBinder() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              textNodeIndices = $__1.textNodeIndices,
              contentTagSelector = $__1.contentTagSelector,
              nestedProtoView = $__1.nestedProtoView,
              componentId = $__1.componentId,
              eventLocals = $__1.eventLocals,
              localEvents = $__1.localEvents,
              globalEvents = $__1.globalEvents,
              parentIndex = $__1.parentIndex,
              distanceToParent = $__1.distanceToParent,
              propertySetters = $__1.propertySetters;
          this.textNodeIndices = textNodeIndices;
          this.contentTagSelector = contentTagSelector;
          this.nestedProtoView = nestedProtoView;
          this.componentId = componentId;
          this.eventLocals = eventLocals;
          this.localEvents = localEvents;
          this.globalEvents = globalEvents;
          this.parentIndex = parentIndex;
          this.distanceToParent = distanceToParent;
          this.propertySetters = propertySetters;
        }
        return ($traceurRuntime.createClass)(ElementBinder, {
          hasStaticComponent: function() {
            return isPresent(this.componentId) && isPresent(this.nestedProtoView);
          },
          hasDynamicComponent: function() {
            return isPresent(this.componentId) && isBlank(this.nestedProtoView);
          }
        }, {});
      }());
      $__export("ElementBinder", ElementBinder);
      Event = (function() {
        function Event(name, target, fullName) {
          this.name = name;
          this.target = target;
          this.fullName = fullName;
        }
        return ($traceurRuntime.createClass)(Event, {}, {});
      }());
      $__export("Event", Event);
      Object.defineProperty(Event, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/util", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/util";
  var StringWrapper,
      RegExpWrapper,
      isPresent,
      NG_BINDING_CLASS_SELECTOR,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      CAMEL_CASE_REGEXP,
      DASH_CASE_REGEXP;
  function camelCaseToDashCase(input) {
    return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, (function(m) {
      return '-' + m[1].toLowerCase();
    }));
  }
  function dashCaseToCamelCase(input) {
    return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, (function(m) {
      return m[1].toUpperCase();
    }));
  }
  $__export("camelCaseToDashCase", camelCaseToDashCase);
  $__export("dashCaseToCamelCase", dashCaseToCamelCase);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      NG_BINDING_CLASS_SELECTOR = '.ng-binding';
      $__export("NG_BINDING_CLASS_SELECTOR", NG_BINDING_CLASS_SELECTOR);
      NG_BINDING_CLASS = 'ng-binding';
      $__export("NG_BINDING_CLASS", NG_BINDING_CLASS);
      EVENT_TARGET_SEPARATOR = ':';
      $__export("EVENT_TARGET_SEPARATOR", EVENT_TARGET_SEPARATOR);
      CAMEL_CASE_REGEXP = RegExpWrapper.create('([A-Z])');
      DASH_CASE_REGEXP = RegExpWrapper.create('-([a-z])');
      Object.defineProperty(camelCaseToDashCase, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(dashCaseToCamelCase, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/content_tag", ["angular2/src/render/dom/shadow_dom/light_dom", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/content_tag";
  var ldModule,
      DOM,
      isPresent,
      List,
      ListWrapper,
      ContentStrategy,
      RenderedContent,
      IntermediateContent,
      Content;
  return {
    setters: [function($__m) {
      ldModule = $__m;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      ContentStrategy = (function() {
        function ContentStrategy() {}
        return ($traceurRuntime.createClass)(ContentStrategy, {insert: function(nodes) {}}, {});
      }());
      Object.defineProperty(ContentStrategy.prototype.insert, "parameters", {get: function() {
          return [[List]];
        }});
      RenderedContent = (function($__super) {
        function RenderedContent(contentEl) {
          $traceurRuntime.superConstructor(RenderedContent).call(this);
          this.beginScript = contentEl;
          this.endScript = DOM.nextSibling(this.beginScript);
          this.nodes = [];
        }
        return ($traceurRuntime.createClass)(RenderedContent, {
          insert: function(nodes) {
            this.nodes = nodes;
            DOM.insertAllBefore(this.endScript, nodes);
            this._removeNodesUntil(ListWrapper.isEmpty(nodes) ? this.endScript : nodes[0]);
          },
          _removeNodesUntil: function(node) {
            var p = DOM.parentElement(this.beginScript);
            for (var next = DOM.nextSibling(this.beginScript); next !== node; next = DOM.nextSibling(this.beginScript)) {
              DOM.removeChild(p, next);
            }
          }
        }, {}, $__super);
      }(ContentStrategy));
      Object.defineProperty(RenderedContent.prototype.insert, "parameters", {get: function() {
          return [[List]];
        }});
      IntermediateContent = (function($__super) {
        function IntermediateContent(destinationLightDom) {
          $traceurRuntime.superConstructor(IntermediateContent).call(this);
          this.nodes = [];
          this.destinationLightDom = destinationLightDom;
        }
        return ($traceurRuntime.createClass)(IntermediateContent, {insert: function(nodes) {
            this.nodes = nodes;
            this.destinationLightDom.redistribute();
          }}, {}, $__super);
      }(ContentStrategy));
      Object.defineProperty(IntermediateContent, "parameters", {get: function() {
          return [[ldModule.LightDom]];
        }});
      Object.defineProperty(IntermediateContent.prototype.insert, "parameters", {get: function() {
          return [[List]];
        }});
      Content = (function() {
        function Content(contentStartEl, selector) {
          this.select = selector;
          this.contentStartElement = contentStartEl;
          this._strategy = null;
        }
        return ($traceurRuntime.createClass)(Content, {
          hydrate: function(destinationLightDom) {
            this._strategy = isPresent(destinationLightDom) ? new IntermediateContent(destinationLightDom) : new RenderedContent(this.contentStartElement);
          },
          dehydrate: function() {
            this._strategy = null;
          },
          nodes: function() {
            return this._strategy.nodes;
          },
          insert: function(nodes) {
            this._strategy.insert(nodes);
          }
        }, {});
      }());
      $__export("Content", Content);
      Object.defineProperty(Content, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(Content.prototype.hydrate, "parameters", {get: function() {
          return [[ldModule.LightDom]];
        }});
      Object.defineProperty(Content.prototype.insert, "parameters", {get: function() {
          return [[List]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/shadow_dom_strategy", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/render/dom/view/view", "angular2/src/render/dom/shadow_dom/light_dom"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/shadow_dom_strategy";
  var isBlank,
      isPresent,
      Promise,
      viewModule,
      LightDom,
      ShadowDomStrategy;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      LightDom = $__m.LightDom;
    }],
    execute: function() {
      ShadowDomStrategy = (function() {
        function ShadowDomStrategy() {}
        return ($traceurRuntime.createClass)(ShadowDomStrategy, {
          hasNativeContentElement: function() {
            return true;
          },
          attachTemplate: function(el, view) {},
          constructLightDom: function(lightDomView, shadowDomView, el) {
            return null;
          },
          processStyleElement: function(hostComponentId, templateUrl, styleElement) {
            return null;
          },
          processElement: function(hostComponentId, elementComponentId, element) {}
        }, {});
      }());
      $__export("ShadowDomStrategy", ShadowDomStrategy);
      Object.defineProperty(ShadowDomStrategy.prototype.attachTemplate, "parameters", {get: function() {
          return [[], [viewModule.RenderView]];
        }});
      Object.defineProperty(ShadowDomStrategy.prototype.constructLightDom, "parameters", {get: function() {
          return [[viewModule.RenderView], [viewModule.RenderView], []];
        }});
      Object.defineProperty(ShadowDomStrategy.prototype.processStyleElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
      Object.defineProperty(ShadowDomStrategy.prototype.processElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/core/zone/vm_turn_zone", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/zone/vm_turn_zone";
  var List,
      ListWrapper,
      StringMapWrapper,
      normalizeBlank,
      isPresent,
      global,
      VmTurnZone;
  return {
    setters: [function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      normalizeBlank = $__m.normalizeBlank;
      isPresent = $__m.isPresent;
      global = $__m.global;
    }],
    execute: function() {
      VmTurnZone = (function() {
        function VmTurnZone($__2) {
          var enableLongStackTrace = $__2.enableLongStackTrace;
          this._nestedRunCounter = 0;
          this._onTurnStart = null;
          this._onTurnDone = null;
          this._onErrorHandler = null;
          this._outerZone = global.zone;
          this._innerZone = this._createInnerZone(this._outerZone, enableLongStackTrace);
        }
        return ($traceurRuntime.createClass)(VmTurnZone, {
          initCallbacks: function() {
            var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
                onTurnStart = $__2.onTurnStart,
                onTurnDone = $__2.onTurnDone,
                onScheduleMicrotask = $__2.onScheduleMicrotask,
                onErrorHandler = $__2.onErrorHandler;
            this._onTurnStart = normalizeBlank(onTurnStart);
            this._onTurnDone = normalizeBlank(onTurnDone);
            this._onErrorHandler = normalizeBlank(onErrorHandler);
          },
          run: function(fn) {
            return this._innerZone.run(fn);
          },
          runOutsideAngular: function(fn) {
            return this._outerZone.run(fn);
          },
          _createInnerZone: function(zone, enableLongStackTrace) {
            var $__0 = this;
            var vmTurnZone = this;
            var errorHandling;
            if (enableLongStackTrace) {
              errorHandling = StringMapWrapper.merge(Zone.longStackTraceZone, {onError: function(e) {
                  vmTurnZone._onError(this, e);
                }});
            } else {
              errorHandling = {onError: function(e) {
                  vmTurnZone._onError(this, e);
                }};
            }
            return zone.fork(errorHandling).fork({
              beforeTask: (function() {
                $__0._beforeTask();
              }),
              afterTask: (function() {
                $__0._afterTask();
              })
            });
          },
          _beforeTask: function() {
            this._nestedRunCounter++;
            if (this._nestedRunCounter === 1 && this._onTurnStart) {
              this._onTurnStart();
            }
          },
          _afterTask: function() {
            this._nestedRunCounter--;
            if (this._nestedRunCounter === 0 && this._onTurnDone) {
              this._onTurnDone();
            }
          },
          _onError: function(zone, e) {
            if (isPresent(this._onErrorHandler)) {
              var trace = [normalizeBlank(e.stack)];
              while (zone && zone.constructedAtException) {
                trace.push(zone.constructedAtException.get());
                zone = zone.parent;
              }
              this._onErrorHandler(e, trace);
            } else {
              throw e;
            }
          }
        }, {});
      }());
      $__export("VmTurnZone", VmTurnZone);
    }
  };
});

System.register("angular2/src/render/dom/view/view_hydrator", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/shadow_dom/light_dom", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/view/view_factory", "angular2/src/render/dom/view/view_container", "angular2/src/render/dom/view/view", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view_hydrator";
  var Injectable,
      int,
      isPresent,
      isBlank,
      BaseException,
      ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      ldModule,
      EventManager,
      ViewFactory,
      vcModule,
      viewModule,
      ShadowDomStrategy,
      RenderViewHydrator;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      int = $__m.int;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      ldModule = $__m;
    }, function($__m) {
      EventManager = $__m.EventManager;
    }, function($__m) {
      ViewFactory = $__m.ViewFactory;
    }, function($__m) {
      vcModule = $__m;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }],
    execute: function() {
      RenderViewHydrator = (function() {
        function RenderViewHydrator(eventManager, viewFactory, shadowDomStrategy) {
          this._eventManager = eventManager;
          this._viewFactory = viewFactory;
          this._shadowDomStrategy = shadowDomStrategy;
        }
        return ($traceurRuntime.createClass)(RenderViewHydrator, {
          hydrateDynamicComponentView: function(hostView, boundElementIndex, componentView) {
            ViewFactory.setComponentView(this._shadowDomStrategy, hostView, boundElementIndex, componentView);
            var lightDom = hostView.lightDoms[boundElementIndex];
            this._viewHydrateRecurse(componentView, lightDom);
            if (isPresent(lightDom)) {
              lightDom.redistribute();
            }
          },
          dehydrateDynamicComponentView: function(parentView, boundElementIndex) {
            throw new BaseException('Not supported yet');
          },
          hydrateInPlaceHostView: function(parentView, hostView) {
            if (isPresent(parentView)) {
              ListWrapper.push(parentView.imperativeHostViews, hostView);
            }
            this._viewHydrateRecurse(hostView, null);
          },
          dehydrateInPlaceHostView: function(parentView, hostView) {
            if (isPresent(parentView)) {
              ListWrapper.remove(parentView.imperativeHostViews, hostView);
            }
            vcModule.ViewContainer.removeViewNodes(hostView);
            hostView.rootNodes = [];
            this._viewDehydrateRecurse(hostView);
          },
          hydrateViewInViewContainer: function(viewContainer, view) {
            this._viewHydrateRecurse(view, viewContainer.parentView.hostLightDom);
          },
          dehydrateViewInViewContainer: function(viewContainer, view) {
            this._viewDehydrateRecurse(view);
          },
          _viewHydrateRecurse: function(view, hostLightDom) {
            if (view.hydrated)
              throw new BaseException('The view is already hydrated.');
            view.hydrated = true;
            view.hostLightDom = hostLightDom;
            for (var i = 0; i < view.contentTags.length; i++) {
              var destLightDom = view.getDirectParentLightDom(i);
              var ct = view.contentTags[i];
              if (isPresent(ct)) {
                ct.hydrate(destLightDom);
              }
            }
            for (var i = 0; i < view.componentChildViews.length; i++) {
              var cv = view.componentChildViews[i];
              if (isPresent(cv)) {
                this._viewHydrateRecurse(cv, view.lightDoms[i]);
              }
            }
            for (var i = 0; i < view.lightDoms.length; ++i) {
              var lightDom = view.lightDoms[i];
              if (isPresent(lightDom)) {
                lightDom.redistribute();
              }
            }
            view.eventHandlerRemovers = ListWrapper.create();
            var binders = view.proto.elementBinders;
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              if (isPresent(binder.globalEvents)) {
                for (var i = 0; i < binder.globalEvents.length; i++) {
                  var globalEvent = binder.globalEvents[i];
                  var remover = this._createGlobalEventListener(view, binderIdx, globalEvent.name, globalEvent.target, globalEvent.fullName);
                  ListWrapper.push(view.eventHandlerRemovers, remover);
                }
              }
            }
          },
          _createGlobalEventListener: function(view, elementIndex, eventName, eventTarget, fullName) {
            return this._eventManager.addGlobalEventListener(eventTarget, eventName, (function(event) {
              view.dispatchEvent(elementIndex, fullName, event);
            }));
          },
          _viewDehydrateRecurse: function(view) {
            for (var i = 0; i < view.componentChildViews.length; i++) {
              var cv = view.componentChildViews[i];
              if (isPresent(cv)) {
                this._viewDehydrateRecurse(cv);
                if (view.proto.elementBinders[i].hasDynamicComponent()) {
                  vcModule.ViewContainer.removeViewNodes(cv);
                  this._viewFactory.returnView(cv);
                  view.lightDoms[i] = null;
                  view.componentChildViews[i] = null;
                }
              }
            }
            for (var i = 0; i < view.imperativeHostViews.length; i++) {
              var hostView = view.imperativeHostViews[i];
              this._viewDehydrateRecurse(hostView);
              vcModule.ViewContainer.removeViewNodes(hostView);
              hostView.rootNodes = [];
              this._viewFactory.returnView(hostView);
            }
            view.imperativeHostViews = [];
            if (isPresent(view.viewContainers)) {
              for (var i = 0; i < view.viewContainers.length; i++) {
                var vc = view.viewContainers[i];
                if (isPresent(vc)) {
                  this._viewContainerDehydrateRecurse(vc);
                }
                var ct = view.contentTags[i];
                if (isPresent(ct)) {
                  ct.dehydrate();
                }
              }
            }
            for (var i = 0; i < view.eventHandlerRemovers.length; i++) {
              view.eventHandlerRemovers[i]();
            }
            view.hostLightDom = null;
            view.eventHandlerRemovers = null;
            view.setEventDispatcher(null);
            view.hydrated = false;
          },
          _viewContainerDehydrateRecurse: function(viewContainer) {
            for (var i = 0; i < viewContainer.views.length; i++) {
              var view = viewContainer.views[i];
              this._viewDehydrateRecurse(view);
              this._viewFactory.returnView(view);
            }
            viewContainer.clear();
          }
        }, {});
      }());
      $__export("RenderViewHydrator", RenderViewHydrator);
      Object.defineProperty(RenderViewHydrator, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(RenderViewHydrator, "parameters", {get: function() {
          return [[EventManager], [ViewFactory], [ShadowDomStrategy]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.hydrateDynamicComponentView, "parameters", {get: function() {
          return [[viewModule.RenderView], [assert.type.number], [viewModule.RenderView]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.dehydrateDynamicComponentView, "parameters", {get: function() {
          return [[viewModule.RenderView], [assert.type.number]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.hydrateInPlaceHostView, "parameters", {get: function() {
          return [[viewModule.RenderView], [viewModule.RenderView]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.dehydrateInPlaceHostView, "parameters", {get: function() {
          return [[viewModule.RenderView], [viewModule.RenderView]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.hydrateViewInViewContainer, "parameters", {get: function() {
          return [[vcModule.ViewContainer], [viewModule.RenderView]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype.dehydrateViewInViewContainer, "parameters", {get: function() {
          return [[vcModule.ViewContainer], [viewModule.RenderView]];
        }});
      Object.defineProperty(RenderViewHydrator.prototype._viewHydrateRecurse, "parameters", {get: function() {
          return [[], [ldModule.LightDom]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/property_setter_factory", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/util", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/property_setter_factory";
  var StringWrapper,
      RegExpWrapper,
      BaseException,
      isPresent,
      isBlank,
      isString,
      stringify,
      ListWrapper,
      StringMapWrapper,
      DOM,
      camelCaseToDashCase,
      dashCaseToCamelCase,
      reflector,
      STYLE_SEPARATOR,
      propertySettersCache,
      innerHTMLSetterCache,
      ATTRIBUTE_PREFIX,
      attributeSettersCache,
      CLASS_PREFIX,
      classSettersCache,
      STYLE_PREFIX,
      styleSettersCache;
  function setterFactory(property) {
    var setterFn,
        styleParts,
        styleSuffix;
    if (StringWrapper.startsWith(property, ATTRIBUTE_PREFIX)) {
      setterFn = attributeSetterFactory(StringWrapper.substring(property, ATTRIBUTE_PREFIX.length));
    } else if (StringWrapper.startsWith(property, CLASS_PREFIX)) {
      setterFn = classSetterFactory(StringWrapper.substring(property, CLASS_PREFIX.length));
    } else if (StringWrapper.startsWith(property, STYLE_PREFIX)) {
      styleParts = property.split(STYLE_SEPARATOR);
      styleSuffix = styleParts.length > 2 ? ListWrapper.get(styleParts, 2) : '';
      setterFn = styleSetterFactory(ListWrapper.get(styleParts, 1), styleSuffix);
    } else if (StringWrapper.equals(property, 'innerHtml')) {
      if (isBlank(innerHTMLSetterCache)) {
        innerHTMLSetterCache = (function(el, value) {
          return DOM.setInnerHTML(el, value);
        });
      }
      setterFn = innerHTMLSetterCache;
    } else {
      property = resolvePropertyName(property);
      setterFn = StringMapWrapper.get(propertySettersCache, property);
      if (isBlank(setterFn)) {
        var propertySetterFn = reflector.setter(property);
        setterFn = function(receiver, value) {
          if (DOM.hasProperty(receiver, property)) {
            return propertySetterFn(receiver, value);
          }
        };
        StringMapWrapper.set(propertySettersCache, property, setterFn);
      }
    }
    return setterFn;
  }
  function _isValidAttributeValue(attrName, value) {
    if (attrName == "role") {
      return isString(value);
    } else {
      return isPresent(value);
    }
  }
  function attributeSetterFactory(attrName) {
    var setterFn = StringMapWrapper.get(attributeSettersCache, attrName);
    var dashCasedAttributeName;
    if (isBlank(setterFn)) {
      dashCasedAttributeName = camelCaseToDashCase(attrName);
      setterFn = function(element, value) {
        if (_isValidAttributeValue(dashCasedAttributeName, value)) {
          DOM.setAttribute(element, dashCasedAttributeName, stringify(value));
        } else {
          if (isPresent(value)) {
            throw new BaseException("Invalid " + dashCasedAttributeName + " attribute, only string values are allowed, got '" + stringify(value) + "'");
          }
          DOM.removeAttribute(element, dashCasedAttributeName);
        }
      };
      StringMapWrapper.set(attributeSettersCache, attrName, setterFn);
    }
    return setterFn;
  }
  function classSetterFactory(className) {
    var setterFn = StringMapWrapper.get(classSettersCache, className);
    var dashCasedClassName;
    if (isBlank(setterFn)) {
      dashCasedClassName = camelCaseToDashCase(className);
      setterFn = function(element, value) {
        if (value) {
          DOM.addClass(element, dashCasedClassName);
        } else {
          DOM.removeClass(element, dashCasedClassName);
        }
      };
      StringMapWrapper.set(classSettersCache, className, setterFn);
    }
    return setterFn;
  }
  function styleSetterFactory(styleName, styleSuffix) {
    var cacheKey = styleName + styleSuffix;
    var setterFn = StringMapWrapper.get(styleSettersCache, cacheKey);
    var dashCasedStyleName;
    if (isBlank(setterFn)) {
      dashCasedStyleName = camelCaseToDashCase(styleName);
      setterFn = function(element, value) {
        var valAsStr;
        if (isPresent(value)) {
          valAsStr = stringify(value);
          DOM.setStyle(element, dashCasedStyleName, valAsStr + styleSuffix);
        } else {
          DOM.removeStyle(element, dashCasedStyleName);
        }
      };
      StringMapWrapper.set(styleSettersCache, cacheKey, setterFn);
    }
    return setterFn;
  }
  function resolvePropertyName(attrName) {
    var mappedPropName = StringMapWrapper.get(DOM.attrToPropMap, attrName);
    return isPresent(mappedPropName) ? mappedPropName : attrName;
  }
  $__export("setterFactory", setterFactory);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      isString = $__m.isString;
      stringify = $__m.stringify;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      camelCaseToDashCase = $__m.camelCaseToDashCase;
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      STYLE_SEPARATOR = '.';
      propertySettersCache = StringMapWrapper.create();
      Object.defineProperty(setterFactory, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      ATTRIBUTE_PREFIX = 'attr.';
      attributeSettersCache = StringMapWrapper.create();
      Object.defineProperty(_isValidAttributeValue, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(attributeSetterFactory, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      CLASS_PREFIX = 'class.';
      classSettersCache = StringMapWrapper.create();
      Object.defineProperty(classSetterFactory, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      STYLE_PREFIX = 'style.';
      styleSettersCache = StringMapWrapper.create();
      Object.defineProperty(styleSetterFactory, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(resolvePropertyName, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_step", ["angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_step";
  var CompileElement,
      compileControlModule,
      CompileStep;
  return {
    setters: [function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      compileControlModule = $__m;
    }],
    execute: function() {
      CompileStep = (function() {
        function CompileStep() {}
        return ($traceurRuntime.createClass)(CompileStep, {process: function(parent, current, control) {}}, {});
      }());
      $__export("CompileStep", CompileStep);
      Object.defineProperty(CompileStep.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [compileControlModule.CompileControl]];
        }});
    }
  };
});

System.register("angular2/src/services/xhr", ["angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/xhr";
  var Promise,
      XHR;
  return {
    setters: [function($__m) {
      Promise = $__m.Promise;
    }],
    execute: function() {
      XHR = (function() {
        function XHR() {}
        return ($traceurRuntime.createClass)(XHR, {get: function(url) {
            return null;
          }}, {});
      }());
      $__export("XHR", XHR);
      Object.defineProperty(XHR.prototype.get, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/services/url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/url_resolver";
  var Injectable,
      isPresent,
      isBlank,
      RegExpWrapper,
      BaseException,
      DOM,
      UrlResolver,
      _schemeRe;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      UrlResolver = (function() {
        function UrlResolver() {
          if (isBlank(UrlResolver.a)) {
            UrlResolver.a = DOM.createElement('a');
          }
        }
        return ($traceurRuntime.createClass)(UrlResolver, {resolve: function(baseUrl, url) {
            if (isBlank(baseUrl)) {
              DOM.resolveAndSetHref(UrlResolver.a, url, null);
              return DOM.getHref(UrlResolver.a);
            }
            if (isBlank(url) || url == '')
              return baseUrl;
            if (url[0] == '/') {
              throw new BaseException(("Could not resolve the url " + url + " from " + baseUrl));
            }
            var m = RegExpWrapper.firstMatch(_schemeRe, url);
            if (isPresent(m[1])) {
              return url;
            }
            DOM.resolveAndSetHref(UrlResolver.a, baseUrl, url);
            return DOM.getHref(UrlResolver.a);
          }}, {});
      }());
      $__export("UrlResolver", UrlResolver);
      Object.defineProperty(UrlResolver, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(UrlResolver.prototype.resolve, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      _schemeRe = RegExpWrapper.create('^([^:/?#]+:)?');
    }
  };
});

System.register("angular2/src/render/dom/compiler/property_binding_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/change_detection", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/property_binding_parser";
  var isPresent,
      RegExpWrapper,
      MapWrapper,
      Parser,
      CompileStep,
      CompileElement,
      CompileControl,
      dashCaseToCamelCase,
      BIND_NAME_REGEXP,
      PropertyBindingParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      BIND_NAME_REGEXP = RegExpWrapper.create('^(?:(?:(?:(bind-)|(var-|#)|(on-))(.+))|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$');
      PropertyBindingParser = (function($__super) {
        function PropertyBindingParser(parser) {
          $traceurRuntime.superConstructor(PropertyBindingParser).call(this);
          this._parser = parser;
        }
        return ($traceurRuntime.createClass)(PropertyBindingParser, {
          process: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var newAttrs = MapWrapper.create();
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              var bindParts = RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
              if (isPresent(bindParts)) {
                if (isPresent(bindParts[1])) {
                  $__0._bindProperty(bindParts[4], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[2])) {
                  var identifier = bindParts[4];
                  var value = attrValue == '' ? '\$implicit' : attrValue;
                  $__0._bindVariable(identifier, value, current, newAttrs);
                } else if (isPresent(bindParts[3])) {
                  $__0._bindEvent(bindParts[4], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[5])) {
                  $__0._bindProperty(bindParts[5], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[6])) {
                  $__0._bindEvent(bindParts[6], attrValue, current, newAttrs);
                }
              } else {
                var expr = $__0._parser.parseInterpolation(attrValue, current.elementDescription);
                if (isPresent(expr)) {
                  $__0._bindPropertyAst(attrName, expr, current, newAttrs);
                }
              }
            }));
            MapWrapper.forEach(newAttrs, (function(attrValue, attrName) {
              MapWrapper.set(attrs, attrName, attrValue);
            }));
          },
          _bindVariable: function(identifier, value, current, newAttrs) {
            current.bindElement().bindVariable(dashCaseToCamelCase(identifier), value);
            MapWrapper.set(newAttrs, identifier, value);
          },
          _bindProperty: function(name, expression, current, newAttrs) {
            this._bindPropertyAst(name, this._parser.parseBinding(expression, current.elementDescription), current, newAttrs);
          },
          _bindPropertyAst: function(name, ast, current, newAttrs) {
            var binder = current.bindElement();
            var camelCaseName = dashCaseToCamelCase(name);
            binder.bindProperty(camelCaseName, ast);
            MapWrapper.set(newAttrs, name, ast.source);
          },
          _bindEvent: function(name, expression, current, newAttrs) {
            current.bindElement().bindEvent(dashCaseToCamelCase(name), this._parser.parseAction(expression, current.elementDescription));
          }
        }, {}, $__super);
      }(CompileStep));
      $__export("PropertyBindingParser", PropertyBindingParser);
      Object.defineProperty(PropertyBindingParser, "parameters", {get: function() {
          return [[Parser]];
        }});
      Object.defineProperty(PropertyBindingParser.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [CompileControl]];
        }});
      Object.defineProperty(PropertyBindingParser.prototype._bindVariable, "parameters", {get: function() {
          return [[], [], [CompileElement], []];
        }});
      Object.defineProperty(PropertyBindingParser.prototype._bindProperty, "parameters", {get: function() {
          return [[], [], [CompileElement], []];
        }});
      Object.defineProperty(PropertyBindingParser.prototype._bindPropertyAst, "parameters", {get: function() {
          return [[], [], [CompileElement], []];
        }});
      Object.defineProperty(PropertyBindingParser.prototype._bindEvent, "parameters", {get: function() {
          return [[], [], [CompileElement], []];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/text_interpolation_parser", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/change_detection", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/text_interpolation_parser";
  var RegExpWrapper,
      StringWrapper,
      isPresent,
      DOM,
      Parser,
      CompileStep,
      CompileElement,
      CompileControl,
      TextInterpolationParser;
  return {
    setters: [function($__m) {
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }],
    execute: function() {
      TextInterpolationParser = (function($__super) {
        function TextInterpolationParser(parser) {
          $traceurRuntime.superConstructor(TextInterpolationParser).call(this);
          this._parser = parser;
        }
        return ($traceurRuntime.createClass)(TextInterpolationParser, {process: function(parent, current, control) {
            if (!current.compileChildren) {
              return ;
            }
            var element = current.element;
            var childNodes = DOM.childNodes(DOM.templateAwareRoot(element));
            for (var i = 0; i < childNodes.length; i++) {
              var node = childNodes[i];
              if (DOM.isTextNode(node)) {
                var text = DOM.nodeValue(node);
                var expr = this._parser.parseInterpolation(text, current.elementDescription);
                if (isPresent(expr)) {
                  DOM.setText(node, ' ');
                  current.bindElement().bindText(i, expr);
                }
              }
            }
          }}, {}, $__super);
      }(CompileStep));
      $__export("TextInterpolationParser", TextInterpolationParser);
      Object.defineProperty(TextInterpolationParser, "parameters", {get: function() {
          return [[Parser]];
        }});
      Object.defineProperty(TextInterpolationParser.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [CompileControl]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/selector", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/selector";
  var List,
      Map,
      ListWrapper,
      MapWrapper,
      isPresent,
      isBlank,
      RegExpWrapper,
      RegExpMatcherWrapper,
      StringWrapper,
      BaseException,
      _EMPTY_ATTR_VALUE,
      _SELECTOR_REGEXP,
      CssSelector,
      SelectorMatcher,
      SelectorListContext,
      SelectorContext;
  return {
    setters: [function($__m) {
      List = $__m.List;
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      _EMPTY_ATTR_VALUE = '';
      _SELECTOR_REGEXP = RegExpWrapper.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(?:\\))|' + '(\\s*,\\s*)');
      CssSelector = (function() {
        function CssSelector() {
          this.element = null;
          this.classNames = ListWrapper.create();
          this.attrs = ListWrapper.create();
          this.notSelector = null;
        }
        return ($traceurRuntime.createClass)(CssSelector, {
          isElementSelector: function() {
            return isPresent(this.element) && ListWrapper.isEmpty(this.classNames) && ListWrapper.isEmpty(this.attrs) && isBlank(this.notSelector);
          },
          setElement: function() {
            var element = arguments[0] !== (void 0) ? arguments[0] : null;
            if (isPresent(element)) {
              element = element.toLowerCase();
            }
            this.element = element;
          },
          addAttribute: function(name) {
            var value = arguments[1] !== (void 0) ? arguments[1] : _EMPTY_ATTR_VALUE;
            ListWrapper.push(this.attrs, name.toLowerCase());
            if (isPresent(value)) {
              value = value.toLowerCase();
            } else {
              value = _EMPTY_ATTR_VALUE;
            }
            ListWrapper.push(this.attrs, value);
          },
          addClassName: function(name) {
            ListWrapper.push(this.classNames, name.toLowerCase());
          },
          toString: function() {
            var res = '';
            if (isPresent(this.element)) {
              res += this.element;
            }
            if (isPresent(this.classNames)) {
              for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
              }
            }
            if (isPresent(this.attrs)) {
              for (var i = 0; i < this.attrs.length; ) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                  res += '=' + attrValue;
                }
                res += ']';
              }
            }
            if (isPresent(this.notSelector)) {
              res += ":not(" + this.notSelector.toString() + ")";
            }
            return res;
          }
        }, {parse: function(selector) {
            var results = ListWrapper.create();
            var _addResult = (function(res, cssSel) {
              if (isPresent(cssSel.notSelector) && isBlank(cssSel.element) && ListWrapper.isEmpty(cssSel.classNames) && ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
              }
              ListWrapper.push(res, cssSel);
            });
            var cssSelector = new CssSelector();
            var matcher = RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
            var match;
            var current = cssSelector;
            while (isPresent(match = RegExpMatcherWrapper.next(matcher))) {
              if (isPresent(match[1])) {
                if (isPresent(cssSelector.notSelector)) {
                  throw new BaseException('Nesting :not is not allowed in a selector');
                }
                current.notSelector = new CssSelector();
                current = current.notSelector;
              }
              if (isPresent(match[2])) {
                current.setElement(match[2]);
              }
              if (isPresent(match[3])) {
                current.addClassName(match[3]);
              }
              if (isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
              }
              if (isPresent(match[6])) {
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
              }
            }
            _addResult(results, cssSelector);
            return results;
          }});
      }());
      $__export("CssSelector", CssSelector);
      Object.defineProperty(CssSelector.parse, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(CssSelector.prototype.setElement, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(CssSelector.prototype.addAttribute, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(CssSelector.prototype.addClassName, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      SelectorMatcher = (function() {
        function SelectorMatcher() {
          this._elementMap = MapWrapper.create();
          this._elementPartialMap = MapWrapper.create();
          this._classMap = MapWrapper.create();
          this._classPartialMap = MapWrapper.create();
          this._attrValueMap = MapWrapper.create();
          this._attrValuePartialMap = MapWrapper.create();
          this._listContexts = ListWrapper.create();
        }
        return ($traceurRuntime.createClass)(SelectorMatcher, {
          addSelectables: function(cssSelectors, callbackCtxt) {
            var listContext = null;
            if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              ListWrapper.push(this._listContexts, listContext);
            }
            for (var i = 0; i < cssSelectors.length; i++) {
              this.addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
          },
          addSelectable: function(cssSelector, callbackCtxt, listContext) {
            var matcher = this;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (isPresent(element)) {
              var isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
              } else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
              }
            }
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                  this._addTerminal(matcher._classMap, className, selectable);
                } else {
                  matcher = this._addPartial(matcher._classPartialMap, className);
                }
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var map = isTerminal ? matcher._attrValueMap : matcher._attrValuePartialMap;
                var valuesMap = MapWrapper.get(map, attrName);
                if (isBlank(valuesMap)) {
                  valuesMap = MapWrapper.create();
                  MapWrapper.set(map, attrName, valuesMap);
                }
                if (isTerminal) {
                  this._addTerminal(valuesMap, attrValue, selectable);
                } else {
                  matcher = this._addPartial(valuesMap, attrValue);
                }
              }
            }
          },
          _addTerminal: function(map, name, selectable) {
            var terminalList = MapWrapper.get(map, name);
            if (isBlank(terminalList)) {
              terminalList = ListWrapper.create();
              MapWrapper.set(map, name, terminalList);
            }
            ListWrapper.push(terminalList, selectable);
          },
          _addPartial: function(map, name) {
            var matcher = MapWrapper.get(map, name);
            if (isBlank(matcher)) {
              matcher = new SelectorMatcher();
              MapWrapper.set(map, name, matcher);
            }
            return matcher;
          },
          match: function(cssSelector, matchedCallback) {
            var result = false;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            for (var i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var valuesMap = MapWrapper.get(this._attrValueMap, attrName);
                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                  result = this._matchTerminal(valuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                }
                result = this._matchTerminal(valuesMap, attrValue, cssSelector, matchedCallback) || result;
                valuesMap = MapWrapper.get(this._attrValuePartialMap, attrName);
                result = this._matchPartial(valuesMap, attrValue, cssSelector, matchedCallback) || result;
              }
            }
            return result;
          },
          _matchTerminal: function() {
            var map = arguments[0] !== (void 0) ? arguments[0] : null;
            var name = arguments[1];
            var cssSelector = arguments[2];
            var matchedCallback = arguments[3];
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var selectables = MapWrapper.get(map, name);
            var starSelectables = MapWrapper.get(map, "*");
            if (isPresent(starSelectables)) {
              selectables = ListWrapper.concat(selectables, starSelectables);
            }
            if (isBlank(selectables)) {
              return false;
            }
            var selectable;
            var result = false;
            for (var index = 0; index < selectables.length; index++) {
              selectable = selectables[index];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
          },
          _matchPartial: function() {
            var map = arguments[0] !== (void 0) ? arguments[0] : null;
            var name = arguments[1];
            var cssSelector = arguments[2];
            var matchedCallback = arguments[3];
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var nestedSelector = MapWrapper.get(map, name);
            if (isBlank(nestedSelector)) {
              return false;
            }
            return nestedSelector.match(cssSelector, matchedCallback);
          }
        }, {});
      }());
      $__export("SelectorMatcher", SelectorMatcher);
      Object.defineProperty(SelectorMatcher.prototype.addSelectables, "parameters", {get: function() {
          return [[assert.genericType(List, CssSelector)], []];
        }});
      Object.defineProperty(SelectorMatcher.prototype.addSelectable, "parameters", {get: function() {
          return [[], [], [SelectorListContext]];
        }});
      Object.defineProperty(SelectorMatcher.prototype._addTerminal, "parameters", {get: function() {
          return [[assert.genericType(Map, assert.type.string, assert.type.string)], [assert.type.string], []];
        }});
      Object.defineProperty(SelectorMatcher.prototype._addPartial, "parameters", {get: function() {
          return [[assert.genericType(Map, assert.type.string, assert.type.string)], [assert.type.string]];
        }});
      Object.defineProperty(SelectorMatcher.prototype.match, "parameters", {get: function() {
          return [[CssSelector], [Function]];
        }});
      Object.defineProperty(SelectorMatcher.prototype._matchTerminal, "parameters", {get: function() {
          return [[assert.genericType(Map, assert.type.string, assert.type.string)], [], [], []];
        }});
      Object.defineProperty(SelectorMatcher.prototype._matchPartial, "parameters", {get: function() {
          return [[assert.genericType(Map, assert.type.string, assert.type.string)], [], [], []];
        }});
      SelectorListContext = (function() {
        function SelectorListContext(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
        }
        return ($traceurRuntime.createClass)(SelectorListContext, {}, {});
      }());
      Object.defineProperty(SelectorListContext, "parameters", {get: function() {
          return [[assert.genericType(List, CssSelector)]];
        }});
      SelectorContext = (function() {
        function SelectorContext(selector, cbContext, listContext) {
          this.selector = selector;
          this.notSelector = selector.notSelector;
          this.cbContext = cbContext;
          this.listContext = listContext;
        }
        return ($traceurRuntime.createClass)(SelectorContext, {finalize: function(cssSelector, callback) {
            var result = true;
            if (isPresent(this.notSelector) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              var notMatcher = new SelectorMatcher();
              notMatcher.addSelectable(this.notSelector, null, null);
              result = !notMatcher.match(cssSelector, null);
            }
            if (result && isPresent(callback) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              if (isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
            }
            return result;
          }}, {});
      }());
      Object.defineProperty(SelectorContext, "parameters", {get: function() {
          return [[CssSelector], [], [SelectorListContext]];
        }});
      Object.defineProperty(SelectorContext.prototype.finalize, "parameters", {get: function() {
          return [[CssSelector], []];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/view_splitter", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/change_detection", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/view_splitter";
  var isBlank,
      isPresent,
      BaseException,
      StringWrapper,
      DOM,
      MapWrapper,
      ListWrapper,
      Parser,
      CompileStep,
      CompileElement,
      CompileControl,
      dashCaseToCamelCase,
      ViewSplitter;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      ViewSplitter = (function($__super) {
        function ViewSplitter(parser) {
          $traceurRuntime.superConstructor(ViewSplitter).call(this);
          this._parser = parser;
        }
        return ($traceurRuntime.createClass)(ViewSplitter, {
          process: function(parent, current, control) {
            var attrs = current.attrs();
            var templateBindings = MapWrapper.get(attrs, 'template');
            var hasTemplateBinding = isPresent(templateBindings);
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              if (StringWrapper.startsWith(attrName, '*')) {
                var key = StringWrapper.substring(attrName, 1);
                if (hasTemplateBinding) {
                  throw new BaseException("Only one template directive per element is allowed: " + (templateBindings + " and " + key + " cannot be used simultaneously ") + ("in " + current.elementDescription));
                } else {
                  templateBindings = (attrValue.length == 0) ? key : key + ' ' + attrValue;
                  hasTemplateBinding = true;
                }
              }
            }));
            if (isPresent(parent)) {
              if (DOM.isTemplateElement(current.element)) {
                if (!current.isViewRoot) {
                  var viewRoot = new CompileElement(DOM.createTemplate(''));
                  viewRoot.inheritedProtoView = current.bindElement().bindNestedProtoView(viewRoot.element);
                  viewRoot.elementDescription = current.elementDescription;
                  viewRoot.isViewRoot = true;
                  this._moveChildNodes(DOM.content(current.element), DOM.content(viewRoot.element));
                  control.addChild(viewRoot);
                }
              }
              if (hasTemplateBinding) {
                var newParent = new CompileElement(DOM.createTemplate(''));
                newParent.inheritedProtoView = current.inheritedProtoView;
                newParent.inheritedElementBinder = current.inheritedElementBinder;
                newParent.distanceToInheritedBinder = current.distanceToInheritedBinder;
                newParent.elementDescription = current.elementDescription;
                current.inheritedProtoView = newParent.bindElement().bindNestedProtoView(current.element);
                current.inheritedElementBinder = null;
                current.distanceToInheritedBinder = 0;
                current.isViewRoot = true;
                this._parseTemplateBindings(templateBindings, newParent);
                this._addParentElement(current.element, newParent.element);
                control.addParent(newParent);
                DOM.remove(current.element);
              }
            }
          },
          _moveChildNodes: function(source, target) {
            var next = DOM.firstChild(source);
            while (isPresent(next)) {
              DOM.appendChild(target, next);
              next = DOM.firstChild(source);
            }
          },
          _addParentElement: function(currentElement, newParentElement) {
            DOM.insertBefore(currentElement, newParentElement);
            DOM.appendChild(newParentElement, currentElement);
          },
          _parseTemplateBindings: function(templateBindings, compileElement) {
            var bindings = this._parser.parseTemplateBindings(templateBindings, compileElement.elementDescription);
            for (var i = 0; i < bindings.length; i++) {
              var binding = bindings[i];
              if (binding.keyIsVar) {
                compileElement.bindElement().bindVariable(dashCaseToCamelCase(binding.key), binding.name);
                MapWrapper.set(compileElement.attrs(), binding.key, binding.name);
              } else if (isPresent(binding.expression)) {
                compileElement.bindElement().bindProperty(dashCaseToCamelCase(binding.key), binding.expression);
                MapWrapper.set(compileElement.attrs(), binding.key, binding.expression.source);
              } else {
                DOM.setAttribute(compileElement.element, binding.key, '');
              }
            }
          }
        }, {}, $__super);
      }(CompileStep));
      $__export("ViewSplitter", ViewSplitter);
      Object.defineProperty(ViewSplitter, "parameters", {get: function() {
          return [[Parser]];
        }});
      Object.defineProperty(ViewSplitter.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [CompileControl]];
        }});
      Object.defineProperty(ViewSplitter.prototype._parseTemplateBindings, "parameters", {get: function() {
          return [[assert.type.string], [CompileElement]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/shadow_dom_compile_step", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/api", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/shadow_dom_compile_step";
  var isBlank,
      isPresent,
      assertionsEnabled,
      MapWrapper,
      List,
      ListWrapper,
      Promise,
      PromiseWrapper,
      DOM,
      CompileStep,
      CompileElement,
      CompileControl,
      ViewDefinition,
      ShadowDomStrategy,
      ShadowDomCompileStep;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      assertionsEnabled = $__m.assertionsEnabled;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }],
    execute: function() {
      ShadowDomCompileStep = (function($__super) {
        function ShadowDomCompileStep(shadowDomStrategy, template, subTaskPromises) {
          $traceurRuntime.superConstructor(ShadowDomCompileStep).call(this);
          this._shadowDomStrategy = shadowDomStrategy;
          this._template = template;
          this._subTaskPromises = subTaskPromises;
        }
        return ($traceurRuntime.createClass)(ShadowDomCompileStep, {
          process: function(parent, current, control) {
            var tagName = DOM.tagName(current.element).toUpperCase();
            if (tagName == 'STYLE') {
              this._processStyleElement(current, control);
            } else if (tagName == 'CONTENT') {
              this._processContentElement(current);
            } else {
              var componentId = current.isBound() ? current.inheritedElementBinder.componentId : null;
              this._shadowDomStrategy.processElement(this._template.componentId, componentId, current.element);
            }
          },
          _processStyleElement: function(current, control) {
            var stylePromise = this._shadowDomStrategy.processStyleElement(this._template.componentId, this._template.absUrl, current.element);
            if (isPresent(stylePromise) && PromiseWrapper.isPromise(stylePromise)) {
              ListWrapper.push(this._subTaskPromises, stylePromise);
            }
            control.ignoreCurrentElement();
          },
          _processContentElement: function(current) {
            if (this._shadowDomStrategy.hasNativeContentElement()) {
              return ;
            }
            var attrs = current.attrs();
            var selector = MapWrapper.get(attrs, 'select');
            selector = isPresent(selector) ? selector : '';
            var contentStart = DOM.createScriptTag('type', 'ng/contentStart');
            if (assertionsEnabled()) {
              DOM.setAttribute(contentStart, 'select', selector);
            }
            var contentEnd = DOM.createScriptTag('type', 'ng/contentEnd');
            DOM.insertBefore(current.element, contentStart);
            DOM.insertBefore(current.element, contentEnd);
            DOM.remove(current.element);
            current.element = contentStart;
            current.bindElement().setContentTagSelector(selector);
          }
        }, {}, $__super);
      }(CompileStep));
      $__export("ShadowDomCompileStep", ShadowDomCompileStep);
      Object.defineProperty(ShadowDomCompileStep, "parameters", {get: function() {
          return [[ShadowDomStrategy], [ViewDefinition], [assert.genericType(List, Promise)]];
        }});
      Object.defineProperty(ShadowDomCompileStep.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [CompileControl]];
        }});
      Object.defineProperty(ShadowDomCompileStep.prototype._processStyleElement, "parameters", {get: function() {
          return [[CompileElement], [CompileControl]];
        }});
      Object.defineProperty(ShadowDomCompileStep.prototype._processContentElement, "parameters", {get: function() {
          return [[CompileElement]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/view_container_ref", ["angular2/src/facade/collection", "angular2/di", "angular2/src/facade/lang", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_container_ref";
  var ListWrapper,
      List,
      Injector,
      isPresent,
      isBlank,
      avmModule,
      ElementRef,
      ViewRef,
      ProtoViewRef,
      internalView,
      ViewContainerRef;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Injector = $__m.Injector;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      avmModule = $__m;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      ViewRef = $__m.ViewRef;
      ProtoViewRef = $__m.ProtoViewRef;
      internalView = $__m.internalView;
    }],
    execute: function() {
      ViewContainerRef = (function() {
        function ViewContainerRef(viewManager, element) {
          this._viewManager = viewManager;
          this._element = element;
        }
        return ($traceurRuntime.createClass)(ViewContainerRef, {
          _getViews: function() {
            var vc = internalView(this._element.parentView).viewContainers[this._element.boundElementIndex];
            return isPresent(vc) ? vc.views : [];
          },
          clear: function() {
            for (var i = this.length - 1; i >= 0; i--) {
              this.remove(i);
            }
          },
          get: function(index) {
            return new ViewRef(this._getViews()[index]);
          },
          get length() {
            return this._getViews().length;
          },
          create: function() {
            var protoViewRef = arguments[0] !== (void 0) ? arguments[0] : null;
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            var injector = arguments[2] !== (void 0) ? arguments[2] : null;
            if (atIndex == -1)
              atIndex = this.length;
            return this._viewManager.createViewInContainer(this._element, atIndex, protoViewRef, injector);
          },
          insert: function(viewRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            if (atIndex == -1)
              atIndex = this.length;
            return this._viewManager.attachViewInContainer(this._element, atIndex, viewRef);
          },
          indexOf: function(viewRef) {
            return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
          },
          remove: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            this._viewManager.destroyViewInContainer(this._element, atIndex);
          },
          detach: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            return this._viewManager.detachViewInContainer(this._element, atIndex);
          }
        }, {});
      }());
      $__export("ViewContainerRef", ViewContainerRef);
      Object.defineProperty(ViewContainerRef, "parameters", {get: function() {
          return [[avmModule.AppViewManager], [ElementRef]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.get, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.create, "parameters", {get: function() {
          return [[ProtoViewRef], [assert.type.number], [Injector]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.insert, "parameters", {get: function() {
          return [[ViewRef], [assert.type.number]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.indexOf, "parameters", {get: function() {
          return [[ViewRef]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.remove, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ViewContainerRef.prototype.detach, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/view_manager_utils", ["angular2/di", "angular2/src/facade/collection", "angular2/src/core/compiler/element_injector", "angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/core/compiler/view_manager", "angular2/src/render/api", "angular2/change_detection", "angular2/src/core/compiler/directive_metadata_reader"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager_utils";
  var Injectable,
      Injector,
      Binding,
      ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      eli,
      isPresent,
      isBlank,
      BaseException,
      viewModule,
      avmModule,
      Renderer,
      BindingPropagationConfig,
      Locals,
      DirectiveMetadataReader,
      AppViewManagerUtils;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
      Injector = $__m.Injector;
      Binding = $__m.Binding;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      eli = $__m;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      avmModule = $__m;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      BindingPropagationConfig = $__m.BindingPropagationConfig;
      Locals = $__m.Locals;
    }, function($__m) {
      DirectiveMetadataReader = $__m.DirectiveMetadataReader;
    }],
    execute: function() {
      AppViewManagerUtils = (function() {
        function AppViewManagerUtils(metadataReader) {
          this._metadataReader = metadataReader;
        }
        return ($traceurRuntime.createClass)(AppViewManagerUtils, {
          getComponentInstance: function(parentView, boundElementIndex) {
            var binder = parentView.proto.elementBinders[boundElementIndex];
            var eli = parentView.elementInjectors[boundElementIndex];
            if (binder.hasDynamicComponent()) {
              return eli.getDynamicallyLoadedComponent();
            } else {
              return eli.getComponent();
            }
          },
          createView: function(protoView, viewManager, renderer) {
            var view = new viewModule.AppView(renderer, protoView, protoView.protoLocals);
            var changeDetector = protoView.protoChangeDetector.instantiate(view);
            var binders = protoView.elementBinders;
            var elementInjectors = ListWrapper.createFixedSize(binders.length);
            var rootElementInjectors = [];
            var preBuiltObjects = ListWrapper.createFixedSize(binders.length);
            var componentChildViews = ListWrapper.createFixedSize(binders.length);
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              var elementInjector = null;
              var protoElementInjector = binder.protoElementInjector;
              if (isPresent(protoElementInjector)) {
                if (isPresent(protoElementInjector.parent)) {
                  var parentElementInjector = elementInjectors[protoElementInjector.parent.index];
                  elementInjector = protoElementInjector.instantiate(parentElementInjector);
                } else {
                  elementInjector = protoElementInjector.instantiate(null);
                  ListWrapper.push(rootElementInjectors, elementInjector);
                }
              }
              elementInjectors[binderIdx] = elementInjector;
              if (isPresent(elementInjector)) {
                var embeddedProtoView = binder.hasEmbeddedProtoView() ? binder.nestedProtoView : null;
                preBuiltObjects[binderIdx] = new eli.PreBuiltObjects(viewManager, view, embeddedProtoView);
              }
            }
            view.init(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, componentChildViews);
            return view;
          },
          attachComponentView: function(hostView, boundElementIndex, componentView) {
            var childChangeDetector = componentView.changeDetector;
            hostView.changeDetector.addShadowDomChild(childChangeDetector);
            hostView.componentChildViews[boundElementIndex] = componentView;
          },
          detachComponentView: function(hostView, boundElementIndex) {
            var componentView = hostView.componentChildViews[boundElementIndex];
            hostView.changeDetector.removeShadowDomChild(componentView.changeDetector);
            hostView.componentChildViews[boundElementIndex] = null;
          },
          hydrateComponentView: function(hostView, boundElementIndex) {
            var injector = arguments[2] !== (void 0) ? arguments[2] : null;
            var elementInjector = hostView.elementInjectors[boundElementIndex];
            var componentView = hostView.componentChildViews[boundElementIndex];
            var component = this.getComponentInstance(hostView, boundElementIndex);
            this._hydrateView(componentView, injector, elementInjector, component, null);
          },
          attachAndHydrateInPlaceHostView: function(parentComponentHostView, parentComponentBoundElementIndex, hostView) {
            var injector = arguments[3] !== (void 0) ? arguments[3] : null;
            var hostElementInjector = null;
            if (isPresent(parentComponentHostView)) {
              hostElementInjector = parentComponentHostView.elementInjectors[parentComponentBoundElementIndex];
              var parentView = parentComponentHostView.componentChildViews[parentComponentBoundElementIndex];
              parentView.changeDetector.addChild(hostView.changeDetector);
              ListWrapper.push(parentView.imperativeHostViews, hostView);
            }
            this._hydrateView(hostView, injector, hostElementInjector, new Object(), null);
          },
          detachInPlaceHostView: function(parentView, hostView) {
            if (isPresent(parentView)) {
              parentView.changeDetector.removeChild(hostView.changeDetector);
              ListWrapper.remove(parentView.imperativeHostViews, hostView);
            }
          },
          attachViewInContainer: function(parentView, boundElementIndex, atIndex, view) {
            parentView.changeDetector.addChild(view.changeDetector);
            var viewContainer = parentView.viewContainers[boundElementIndex];
            if (isBlank(viewContainer)) {
              viewContainer = new viewModule.AppViewContainer();
              parentView.viewContainers[boundElementIndex] = viewContainer;
            }
            ListWrapper.insert(viewContainer.views, atIndex, view);
            var sibling;
            if (atIndex == 0) {
              sibling = null;
            } else {
              sibling = ListWrapper.last(viewContainer.views[atIndex - 1].rootElementInjectors);
            }
            var elementInjector = parentView.elementInjectors[boundElementIndex];
            for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
              view.rootElementInjectors[i].linkAfter(elementInjector, sibling);
            }
          },
          detachViewInContainer: function(parentView, boundElementIndex, atIndex) {
            var viewContainer = parentView.viewContainers[boundElementIndex];
            var view = viewContainer.views[atIndex];
            view.changeDetector.remove();
            ListWrapper.removeAt(viewContainer.views, atIndex);
            for (var i = 0; i < view.rootElementInjectors.length; ++i) {
              view.rootElementInjectors[i].unlink();
            }
          },
          hydrateViewInContainer: function(parentView, boundElementIndex, atIndex, injector) {
            var viewContainer = parentView.viewContainers[boundElementIndex];
            var view = viewContainer.views[atIndex];
            var elementInjector = parentView.elementInjectors[boundElementIndex];
            this._hydrateView(view, injector, elementInjector, parentView.context, parentView.locals);
          },
          hydrateDynamicComponentInElementInjector: function(hostView, boundElementIndex, componentBinding) {
            var injector = arguments[3] !== (void 0) ? arguments[3] : null;
            var elementInjector = hostView.elementInjectors[boundElementIndex];
            if (isPresent(elementInjector.getDynamicallyLoadedComponent())) {
              throw new BaseException(("There already is a dynamic component loaded at element " + boundElementIndex));
            }
            if (isBlank(injector)) {
              injector = elementInjector.getLightDomAppInjector();
            }
            var annotation = this._metadataReader.read(componentBinding.token).annotation;
            var componentDirective = eli.DirectiveBinding.createFromBinding(componentBinding, annotation);
            var shadowDomAppInjector = this._createShadowDomAppInjector(componentDirective, injector);
            elementInjector.dynamicallyCreateComponent(componentDirective, shadowDomAppInjector);
          },
          _createShadowDomAppInjector: function(componentDirective, appInjector) {
            var shadowDomAppInjector = null;
            var injectables = componentDirective.resolvedInjectables;
            if (isPresent(injectables)) {
              shadowDomAppInjector = appInjector.createChildFromResolved(injectables);
            } else {
              shadowDomAppInjector = appInjector;
            }
            return shadowDomAppInjector;
          },
          _hydrateView: function(view, appInjector, hostElementInjector, context, parentLocals) {
            if (isBlank(appInjector)) {
              appInjector = hostElementInjector.getShadowDomAppInjector();
            }
            if (isBlank(appInjector)) {
              appInjector = hostElementInjector.getLightDomAppInjector();
            }
            view.context = context;
            view.locals.parent = parentLocals;
            var binders = view.proto.elementBinders;
            for (var i = 0; i < binders.length; ++i) {
              var elementInjector = view.elementInjectors[i];
              if (isPresent(elementInjector)) {
                var componentDirective = view.proto.elementBinders[i].componentDirective;
                var shadowDomAppInjector = null;
                if (isPresent(componentDirective)) {
                  shadowDomAppInjector = this._createShadowDomAppInjector(componentDirective, appInjector);
                } else {
                  shadowDomAppInjector = null;
                }
                elementInjector.instantiateDirectives(appInjector, hostElementInjector, shadowDomAppInjector, view.preBuiltObjects[i]);
                this._setUpEventEmitters(view, elementInjector, i);
                var exportImplicitName = elementInjector.getExportImplicitName();
                if (elementInjector.isExportingComponent()) {
                  view.locals.set(exportImplicitName, elementInjector.getComponent());
                } else if (elementInjector.isExportingElement()) {
                  view.locals.set(exportImplicitName, elementInjector.getElementRef().domElement);
                }
              }
            }
            view.changeDetector.hydrate(view.context, view.locals, view);
          },
          _setUpEventEmitters: function(view, elementInjector, boundElementIndex) {
            var emitters = elementInjector.getEventEmitterAccessors();
            for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
              var directiveEmitters = emitters[directiveIndex];
              var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
              for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
                var eventEmitterAccessor = directiveEmitters[eventIndex];
                eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
              }
            }
          },
          dehydrateView: function(view) {
            var binders = view.proto.elementBinders;
            for (var i = 0; i < binders.length; ++i) {
              var elementInjector = view.elementInjectors[i];
              if (isPresent(elementInjector)) {
                elementInjector.clearDirectives();
              }
            }
            if (isPresent(view.locals)) {
              view.locals.clearValues();
            }
            view.context = null;
            view.changeDetector.dehydrate();
          }
        }, {});
      }());
      $__export("AppViewManagerUtils", AppViewManagerUtils);
      Object.defineProperty(AppViewManagerUtils, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(AppViewManagerUtils, "parameters", {get: function() {
          return [[DirectiveMetadataReader]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.getComponentInstance, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.createView, "parameters", {get: function() {
          return [[viewModule.AppProtoView], [avmModule.AppViewManager], [Renderer]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.attachComponentView, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [viewModule.AppView]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.detachComponentView, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.hydrateComponentView, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [Injector]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.attachAndHydrateInPlaceHostView, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [viewModule.AppView], [Injector]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.detachInPlaceHostView, "parameters", {get: function() {
          return [[viewModule.AppView], [viewModule.AppView]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.attachViewInContainer, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [assert.type.number], [viewModule.AppView]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.detachViewInContainer, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.hydrateViewInContainer, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [assert.type.number], [Injector]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.hydrateDynamicComponentInElementInjector, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [Binding], [Injector]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype._hydrateView, "parameters", {get: function() {
          return [[viewModule.AppView], [Injector], [eli.ElementInjector], [Object], [Locals]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype._setUpEventEmitters, "parameters", {get: function() {
          return [[viewModule.AppView], [eli.ElementInjector], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManagerUtils.prototype.dehydrateView, "parameters", {get: function() {
          return [[viewModule.AppView]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/view_pool", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/compiler/view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_pool";
  var Inject,
      OpaqueToken,
      ListWrapper,
      MapWrapper,
      Map,
      List,
      isPresent,
      isBlank,
      viewModule,
      APP_VIEW_POOL_CAPACITY,
      AppViewPool;
  return {
    setters: [function($__m) {
      Inject = $__m.Inject;
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      List = $__m.List;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      viewModule = $__m;
    }],
    execute: function() {
      APP_VIEW_POOL_CAPACITY = 'AppViewPool.viewPoolCapacity';
      $__export("APP_VIEW_POOL_CAPACITY", APP_VIEW_POOL_CAPACITY);
      AppViewPool = (function() {
        function AppViewPool(poolCapacityPerProtoView) {
          this._poolCapacityPerProtoView = poolCapacityPerProtoView;
          this._pooledViewsPerProtoView = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(AppViewPool, {
          getView: function(protoView) {
            var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
            if (isPresent(pooledViews) && pooledViews.length > 0) {
              return ListWrapper.removeLast(pooledViews);
            }
            return null;
          },
          returnView: function(view) {
            var protoView = view.proto;
            var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
            if (isBlank(pooledViews)) {
              pooledViews = [];
              MapWrapper.set(this._pooledViewsPerProtoView, protoView, pooledViews);
            }
            if (pooledViews.length < this._poolCapacityPerProtoView) {
              ListWrapper.push(pooledViews, view);
            }
          }
        }, {});
      }());
      $__export("AppViewPool", AppViewPool);
      Object.defineProperty(AppViewPool, "parameters", {get: function() {
          return [[new Inject(APP_VIEW_POOL_CAPACITY)]];
        }});
      Object.defineProperty(AppViewPool.prototype.getView, "parameters", {get: function() {
          return [[viewModule.AppProtoView]];
        }});
      Object.defineProperty(AppViewPool.prototype.returnView, "parameters", {get: function() {
          return [[viewModule.AppView]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/base_query_list", ["angular2/src/facade/collection", "angular2/src/core/annotations_impl/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/base_query_list";
  var List,
      MapWrapper,
      ListWrapper,
      Directive,
      BaseQueryList;
  return {
    setters: [function($__m) {
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Directive = $__m.Directive;
    }],
    execute: function() {
      BaseQueryList = (function() {
        var $__1;
        function BaseQueryList() {
          this._results = [];
          this._callbacks = [];
          this._dirty = false;
        }
        return ($traceurRuntime.createClass)(BaseQueryList, ($__1 = {}, Object.defineProperty($__1, Symbol.iterator, {
          value: function() {
            return this._results[Symbol.iterator]();
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "reset", {
          value: function(newList) {
            this._results = newList;
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "add", {
          value: function(obj) {
            ListWrapper.push(this._results, obj);
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "fireCallbacks", {
          value: function() {
            if (this._dirty) {
              ListWrapper.forEach(this._callbacks, (function(c) {
                return c();
              }));
              this._dirty = false;
            }
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "onChange", {
          value: function(callback) {
            ListWrapper.push(this._callbacks, callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "removeCallback", {
          value: function(callback) {
            ListWrapper.remove(this._callbacks, callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), $__1), {});
      }());
      $__export("BaseQueryList", BaseQueryList);
    }
  };
});

System.register("angular2/src/core/compiler/element_binder", ["angular2/src/facade/lang", "angular2/src/core/compiler/element_injector", "angular2/src/facade/collection", "angular2/src/core/compiler/view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_binder";
  var int,
      isBlank,
      isPresent,
      BaseException,
      eiModule,
      DirectiveBinding,
      List,
      StringMap,
      viewModule,
      ElementBinder;
  return {
    setters: [function($__m) {
      int = $__m.int;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      DirectiveBinding = $__m.DirectiveBinding;
      eiModule = $__m;
    }, function($__m) {
      List = $__m.List;
      StringMap = $__m.StringMap;
    }, function($__m) {
      viewModule = $__m;
    }],
    execute: function() {
      ElementBinder = (function() {
        function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective) {
          if (isBlank(index)) {
            throw new BaseException('null index not allowed.');
          }
          this.protoElementInjector = protoElementInjector;
          this.componentDirective = componentDirective;
          this.parent = parent;
          this.index = index;
          this.distanceToParent = distanceToParent;
          this.hostListeners = null;
          this.nestedProtoView = null;
        }
        return ($traceurRuntime.createClass)(ElementBinder, {
          hasStaticComponent: function() {
            return isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          },
          hasDynamicComponent: function() {
            return isPresent(this.componentDirective) && isBlank(this.nestedProtoView);
          },
          hasEmbeddedProtoView: function() {
            return !isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          }
        }, {});
      }());
      $__export("ElementBinder", ElementBinder);
      Object.defineProperty(ElementBinder, "parameters", {get: function() {
          return [[int], [ElementBinder], [int], [eiModule.ProtoElementInjector], [DirectiveBinding]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/template_resolver", ["angular2/di", "angular2/src/core/annotations_impl/view", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/template_resolver";
  var Injectable,
      View,
      Type,
      stringify,
      isBlank,
      BaseException,
      Map,
      MapWrapper,
      List,
      ListWrapper,
      reflector,
      TemplateResolver;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      View = $__m.View;
    }, function($__m) {
      Type = $__m.Type;
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      TemplateResolver = (function() {
        function TemplateResolver() {
          this._cache = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(TemplateResolver, {
          resolve: function(component) {
            var view = MapWrapper.get(this._cache, component);
            if (isBlank(view)) {
              view = this._resolve(component);
              MapWrapper.set(this._cache, component, view);
            }
            return view;
          },
          _resolve: function(component) {
            var annotations = reflector.annotations(component);
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              if (annotation instanceof View) {
                return annotation;
              }
            }
            return null;
          }
        }, {});
      }());
      $__export("TemplateResolver", TemplateResolver);
      Object.defineProperty(TemplateResolver, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(TemplateResolver.prototype.resolve, "parameters", {get: function() {
          return [[Type]];
        }});
      Object.defineProperty(TemplateResolver.prototype._resolve, "parameters", {get: function() {
          return [[Type]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/component_url_mapper", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/component_url_mapper";
  var Injectable,
      Type,
      isPresent,
      Map,
      MapWrapper,
      ComponentUrlMapper,
      RuntimeComponentUrlMapper;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      ComponentUrlMapper = (function() {
        function ComponentUrlMapper() {}
        return ($traceurRuntime.createClass)(ComponentUrlMapper, {getUrl: function(component) {
            return './';
          }}, {});
      }());
      $__export("ComponentUrlMapper", ComponentUrlMapper);
      Object.defineProperty(ComponentUrlMapper, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(ComponentUrlMapper.prototype.getUrl, "parameters", {get: function() {
          return [[Type]];
        }});
      RuntimeComponentUrlMapper = (function($__super) {
        function RuntimeComponentUrlMapper() {
          $traceurRuntime.superConstructor(RuntimeComponentUrlMapper).call(this);
          this._componentUrls = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(RuntimeComponentUrlMapper, {
          setComponentUrl: function(component, url) {
            MapWrapper.set(this._componentUrls, component, url);
          },
          getUrl: function(component) {
            var url = MapWrapper.get(this._componentUrls, component);
            if (isPresent(url))
              return url;
            return $traceurRuntime.superGet(this, RuntimeComponentUrlMapper.prototype, "getUrl").call(this, component);
          }
        }, {}, $__super);
      }(ComponentUrlMapper));
      $__export("RuntimeComponentUrlMapper", RuntimeComponentUrlMapper);
      Object.defineProperty(RuntimeComponentUrlMapper.prototype.setComponentUrl, "parameters", {get: function() {
          return [[Type], [assert.type.string]];
        }});
      Object.defineProperty(RuntimeComponentUrlMapper.prototype.getUrl, "parameters", {get: function() {
          return [[Type]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/proto_view_factory", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/reflection/reflection", "angular2/change_detection", "angular2/src/core/annotations_impl/annotations", "angular2/src/render/api", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/proto_view_factory";
  var Injectable,
      List,
      ListWrapper,
      MapWrapper,
      isPresent,
      isBlank,
      reflector,
      ChangeDetection,
      DirectiveIndex,
      BindingRecord,
      DirectiveRecord,
      ProtoChangeDetector,
      Component,
      renderApi,
      AppProtoView,
      ProtoElementInjector,
      DirectiveBinding,
      BindingRecordsCreator,
      ProtoViewFactory,
      SortedDirectives,
      ParentProtoElementInjectorWithDistance;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      DirectiveIndex = $__m.DirectiveIndex;
      BindingRecord = $__m.BindingRecord;
      DirectiveRecord = $__m.DirectiveRecord;
      ProtoChangeDetector = $__m.ProtoChangeDetector;
    }, function($__m) {
      Component = $__m.Component;
    }, function($__m) {
      renderApi = $__m;
    }, function($__m) {
      AppProtoView = $__m.AppProtoView;
    }, function($__m) {
      ProtoElementInjector = $__m.ProtoElementInjector;
      DirectiveBinding = $__m.DirectiveBinding;
    }],
    execute: function() {
      BindingRecordsCreator = (function() {
        function BindingRecordsCreator() {
          this._directiveRecordsMap = MapWrapper.create();
          this._textNodeIndex = 0;
        }
        return ($traceurRuntime.createClass)(BindingRecordsCreator, {
          getBindingRecords: function(elementBinders, sortedDirectives) {
            var bindings = [];
            for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
              var renderElementBinder = elementBinders[boundElementIndex];
              bindings = ListWrapper.concat(bindings, this._createTextNodeRecords(renderElementBinder));
              bindings = ListWrapper.concat(bindings, this._createElementPropertyRecords(boundElementIndex, renderElementBinder));
              bindings = ListWrapper.concat(bindings, this._createDirectiveRecords(boundElementIndex, sortedDirectives[boundElementIndex]));
            }
            return bindings;
          },
          getDirectiveRecords: function(sortedDirectives) {
            var directiveRecords = [];
            for (var elementIndex = 0; elementIndex < sortedDirectives.length; ++elementIndex) {
              var dirs = sortedDirectives[elementIndex].directives;
              for (var dirIndex = 0; dirIndex < dirs.length; ++dirIndex) {
                ListWrapper.push(directiveRecords, this._getDirectiveRecord(elementIndex, dirIndex, dirs[dirIndex]));
              }
            }
            return directiveRecords;
          },
          _createTextNodeRecords: function(renderElementBinder) {
            var $__0 = this;
            if (isBlank(renderElementBinder.textBindings))
              return [];
            return ListWrapper.map(renderElementBinder.textBindings, (function(b) {
              return BindingRecord.createForTextNode(b, $__0._textNodeIndex++);
            }));
          },
          _createElementPropertyRecords: function(boundElementIndex, renderElementBinder) {
            var res = [];
            MapWrapper.forEach(renderElementBinder.propertyBindings, (function(astWithSource, propertyName) {
              ListWrapper.push(res, BindingRecord.createForElement(astWithSource, boundElementIndex, propertyName));
            }));
            return res;
          },
          _createDirectiveRecords: function(boundElementIndex, sortedDirectives) {
            var $__0 = this;
            var res = [];
            for (var i = 0; i < sortedDirectives.renderDirectives.length; i++) {
              var directiveBinder = sortedDirectives.renderDirectives[i];
              MapWrapper.forEach(directiveBinder.propertyBindings, (function(astWithSource, propertyName) {
                var setter = reflector.setter(propertyName);
                var directiveRecord = $__0._getDirectiveRecord(boundElementIndex, i, sortedDirectives.directives[i]);
                var b = BindingRecord.createForDirective(astWithSource, propertyName, setter, directiveRecord);
                ListWrapper.push(res, b);
              }));
              MapWrapper.forEach(directiveBinder.hostPropertyBindings, (function(astWithSource, propertyName) {
                var dirIndex = new DirectiveIndex(boundElementIndex, i);
                var b = BindingRecord.createForHostProperty(dirIndex, astWithSource, propertyName);
                ListWrapper.push(res, b);
              }));
            }
            return res;
          },
          _getDirectiveRecord: function(boundElementIndex, directiveIndex, binding) {
            var id = boundElementIndex * 100 + directiveIndex;
            if (!MapWrapper.contains(this._directiveRecordsMap, id)) {
              var changeDetection = binding.changeDetection;
              MapWrapper.set(this._directiveRecordsMap, id, new DirectiveRecord(new DirectiveIndex(boundElementIndex, directiveIndex), binding.callOnAllChangesDone, binding.callOnChange, changeDetection));
            }
            return MapWrapper.get(this._directiveRecordsMap, id);
          }
        }, {});
      }());
      Object.defineProperty(BindingRecordsCreator.prototype.getBindingRecords, "parameters", {get: function() {
          return [[assert.genericType(List, renderApi.ElementBinder)], [assert.genericType(List, SortedDirectives)]];
        }});
      Object.defineProperty(BindingRecordsCreator.prototype.getDirectiveRecords, "parameters", {get: function() {
          return [[assert.genericType(List, SortedDirectives)]];
        }});
      Object.defineProperty(BindingRecordsCreator.prototype._createTextNodeRecords, "parameters", {get: function() {
          return [[renderApi.ElementBinder]];
        }});
      Object.defineProperty(BindingRecordsCreator.prototype._createElementPropertyRecords, "parameters", {get: function() {
          return [[assert.type.number], [renderApi.ElementBinder]];
        }});
      Object.defineProperty(BindingRecordsCreator.prototype._createDirectiveRecords, "parameters", {get: function() {
          return [[assert.type.number], [SortedDirectives]];
        }});
      Object.defineProperty(BindingRecordsCreator.prototype._getDirectiveRecord, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.number], [DirectiveBinding]];
        }});
      ProtoViewFactory = (function() {
        function ProtoViewFactory(changeDetection) {
          this._changeDetection = changeDetection;
        }
        return ($traceurRuntime.createClass)(ProtoViewFactory, {
          createProtoView: function(parentProtoView, componentBinding, renderProtoView, directives) {
            var elementBinders = renderProtoView.elementBinders;
            var sortedDirectives = ListWrapper.map(elementBinders, (function(b) {
              return new SortedDirectives(b.directives, directives);
            }));
            var variableBindings = this._createVariableBindings(renderProtoView);
            var protoLocals = this._createProtoLocals(renderProtoView);
            var variableNames = this._createVariableNames(parentProtoView, protoLocals);
            var protoChangeDetector = this._createProtoChangeDetector(elementBinders, sortedDirectives, componentBinding, variableNames);
            var protoView = new AppProtoView(renderProtoView.render, protoChangeDetector, variableBindings, protoLocals, variableNames);
            this._createElementBinders(protoView, elementBinders, sortedDirectives);
            this._bindDirectiveEvents(protoView, sortedDirectives);
            return protoView;
          },
          _createProtoLocals: function(renderProtoView) {
            var protoLocals = MapWrapper.create();
            MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
              MapWrapper.set(protoLocals, mappedName, null);
            }));
            return protoLocals;
          },
          _createVariableBindings: function(renderProtoView) {
            var variableBindings = MapWrapper.create();
            MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
              MapWrapper.set(variableBindings, varName, mappedName);
            }));
            return variableBindings;
          },
          _createVariableNames: function(parentProtoView, protoLocals) {
            var variableNames = isPresent(parentProtoView) ? ListWrapper.clone(parentProtoView.variableNames) : [];
            MapWrapper.forEach(protoLocals, (function(v, local) {
              ListWrapper.push(variableNames, local);
            }));
            return variableNames;
          },
          _createProtoChangeDetector: function(elementBinders, sortedDirectives, componentBinding, variableNames) {
            var bindingRecordsCreator = new BindingRecordsCreator();
            var bindingRecords = bindingRecordsCreator.getBindingRecords(elementBinders, sortedDirectives);
            var directiveRecords = bindingRecordsCreator.getDirectiveRecords(sortedDirectives);
            var changeDetection = null;
            var name = 'root';
            if (isPresent(componentBinding)) {
              var componentAnnotation = componentBinding.annotation;
              changeDetection = componentAnnotation.changeDetection;
              name = 'dummy';
            }
            return this._changeDetection.createProtoChangeDetector(name, bindingRecords, variableNames, directiveRecords, changeDetection);
          },
          _createElementBinders: function(protoView, elementBinders, sortedDirectives) {
            for (var i = 0; i < elementBinders.length; i++) {
              var renderElementBinder = elementBinders[i];
              var dirs = sortedDirectives[i];
              var parentPeiWithDistance = this._findParentProtoElementInjectorWithDistance(i, protoView.elementBinders, elementBinders);
              var protoElementInjector = this._createProtoElementInjector(i, parentPeiWithDistance, dirs, renderElementBinder);
              this._createElementBinder(protoView, i, renderElementBinder, protoElementInjector, dirs);
            }
          },
          _findParentProtoElementInjectorWithDistance: function(binderIndex, elementBinders, renderElementBinders) {
            var distance = 0;
            do {
              var renderElementBinder = renderElementBinders[binderIndex];
              binderIndex = renderElementBinder.parentIndex;
              if (binderIndex !== -1) {
                distance += renderElementBinder.distanceToParent;
                var elementBinder = elementBinders[binderIndex];
                if (isPresent(elementBinder.protoElementInjector)) {
                  return new ParentProtoElementInjectorWithDistance(elementBinder.protoElementInjector, distance);
                }
              }
            } while (binderIndex !== -1);
            return new ParentProtoElementInjectorWithDistance(null, -1);
          },
          _createProtoElementInjector: function(binderIndex, parentPeiWithDistance, sortedDirectives, renderElementBinder) {
            var protoElementInjector = null;
            var hasVariables = MapWrapper.size(renderElementBinder.variableBindings) > 0;
            if (sortedDirectives.directives.length > 0 || hasVariables) {
              protoElementInjector = new ProtoElementInjector(parentPeiWithDistance.protoElementInjector, binderIndex, sortedDirectives.directives, isPresent(sortedDirectives.componentDirective), parentPeiWithDistance.distance);
              protoElementInjector.attributes = renderElementBinder.readAttributes;
              if (hasVariables) {
                protoElementInjector.exportComponent = isPresent(sortedDirectives.componentDirective);
                protoElementInjector.exportElement = isBlank(sortedDirectives.componentDirective);
                var exportImplicitName = MapWrapper.get(renderElementBinder.variableBindings, '\$implicit');
                if (isPresent(exportImplicitName)) {
                  protoElementInjector.exportImplicitName = exportImplicitName;
                }
              }
            }
            return protoElementInjector;
          },
          _createElementBinder: function(protoView, boundElementIndex, renderElementBinder, protoElementInjector, sortedDirectives) {
            var parent = null;
            if (renderElementBinder.parentIndex !== -1) {
              parent = protoView.elementBinders[renderElementBinder.parentIndex];
            }
            var elBinder = protoView.bindElement(parent, renderElementBinder.distanceToParent, protoElementInjector, sortedDirectives.componentDirective);
            protoView.bindEvent(renderElementBinder.eventBindings, boundElementIndex, -1);
            MapWrapper.forEach(renderElementBinder.variableBindings, (function(mappedName, varName) {
              MapWrapper.set(protoView.protoLocals, mappedName, null);
            }));
            return elBinder;
          },
          _bindDirectiveEvents: function(protoView, sortedDirectives) {
            for (var boundElementIndex = 0; boundElementIndex < sortedDirectives.length; ++boundElementIndex) {
              var dirs = sortedDirectives[boundElementIndex].renderDirectives;
              for (var i = 0; i < dirs.length; i++) {
                var directiveBinder = dirs[i];
                protoView.bindEvent(directiveBinder.eventBindings, boundElementIndex, i);
              }
            }
          }
        }, {});
      }());
      $__export("ProtoViewFactory", ProtoViewFactory);
      Object.defineProperty(ProtoViewFactory, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(ProtoViewFactory, "parameters", {get: function() {
          return [[ChangeDetection]];
        }});
      Object.defineProperty(ProtoViewFactory.prototype.createProtoView, "parameters", {get: function() {
          return [[AppProtoView], [DirectiveBinding], [renderApi.ProtoViewDto], [assert.genericType(List, DirectiveBinding)]];
        }});
      Object.defineProperty(ProtoViewFactory.prototype._bindDirectiveEvents, "parameters", {get: function() {
          return [[], [assert.genericType(List, SortedDirectives)]];
        }});
      SortedDirectives = (function() {
        function SortedDirectives(renderDirectives, allDirectives) {
          var $__0 = this;
          this.renderDirectives = [];
          this.directives = [];
          this.componentDirective = null;
          ListWrapper.forEach(renderDirectives, (function(renderDirectiveBinder) {
            var directiveBinding = allDirectives[renderDirectiveBinder.directiveIndex];
            if (directiveBinding.annotation instanceof Component) {
              $__0.componentDirective = directiveBinding;
              ListWrapper.insert($__0.renderDirectives, 0, renderDirectiveBinder);
              ListWrapper.insert($__0.directives, 0, directiveBinding);
            } else {
              ListWrapper.push($__0.renderDirectives, renderDirectiveBinder);
              ListWrapper.push($__0.directives, directiveBinding);
            }
          }));
        }
        return ($traceurRuntime.createClass)(SortedDirectives, {}, {});
      }());
      ParentProtoElementInjectorWithDistance = (function() {
        function ParentProtoElementInjectorWithDistance(protoElementInjector, distance) {
          this.protoElementInjector = protoElementInjector;
          this.distance = distance;
        }
        return ($traceurRuntime.createClass)(ParentProtoElementInjectorWithDistance, {}, {});
      }());
      Object.defineProperty(ParentProtoElementInjectorWithDistance, "parameters", {get: function() {
          return [[ProtoElementInjector], [assert.type.number]];
        }});
    }
  };
});

System.register("angular2/src/core/exception_handler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/exception_handler";
  var Injectable,
      isPresent,
      print,
      ListWrapper,
      isListLikeIterable,
      DOM,
      ExceptionHandler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      print = $__m.print;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      isListLikeIterable = $__m.isListLikeIterable;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      ExceptionHandler = (function() {
        function ExceptionHandler() {}
        return ($traceurRuntime.createClass)(ExceptionHandler, {call: function(error) {
            var stackTrace = arguments[1] !== (void 0) ? arguments[1] : null;
            var reason = arguments[2] !== (void 0) ? arguments[2] : null;
            var longStackTrace = isListLikeIterable(stackTrace) ? ListWrapper.join(stackTrace, "\n\n") : stackTrace;
            var reasonStr = isPresent(reason) ? ("\n" + reason) : '';
            DOM.logError(("" + error + reasonStr + "\nSTACKTRACE:\n" + longStackTrace));
          }}, {});
      }());
      $__export("ExceptionHandler", ExceptionHandler);
      Object.defineProperty(ExceptionHandler, "annotations", {get: function() {
          return [new Injectable()];
        }});
    }
  };
});

System.register("angular2/src/core/life_cycle/life_cycle", ["angular2/di", "angular2/change_detection", "angular2/src/core/zone/vm_turn_zone", "angular2/src/core/exception_handler", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/life_cycle/life_cycle";
  var Injectable,
      ChangeDetector,
      VmTurnZone,
      ExceptionHandler,
      isPresent,
      LifeCycle;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ChangeDetector = $__m.ChangeDetector;
    }, function($__m) {
      VmTurnZone = $__m.VmTurnZone;
    }, function($__m) {
      ExceptionHandler = $__m.ExceptionHandler;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      LifeCycle = (function() {
        function LifeCycle(exceptionHandler) {
          var changeDetector = arguments[1] !== (void 0) ? arguments[1] : null;
          var enforceNoNewChanges = arguments[2] !== (void 0) ? arguments[2] : false;
          this._errorHandler = (function(exception, stackTrace) {
            exceptionHandler.call(exception, stackTrace);
            throw exception;
          });
          this._changeDetector = changeDetector;
          this._enforceNoNewChanges = enforceNoNewChanges;
        }
        return ($traceurRuntime.createClass)(LifeCycle, {
          registerWith: function(zone) {
            var changeDetector = arguments[1] !== (void 0) ? arguments[1] : null;
            var $__0 = this;
            if (isPresent(changeDetector)) {
              this._changeDetector = changeDetector;
            }
            zone.initCallbacks({
              onErrorHandler: this._errorHandler,
              onTurnDone: (function() {
                return $__0.tick();
              })
            });
          },
          tick: function() {
            this._changeDetector.detectChanges();
            if (this._enforceNoNewChanges) {
              this._changeDetector.checkNoChanges();
            }
          }
        }, {});
      }());
      $__export("LifeCycle", LifeCycle);
      Object.defineProperty(LifeCycle, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(LifeCycle, "parameters", {get: function() {
          return [[ExceptionHandler], [ChangeDetector], [assert.type.boolean]];
        }});
      Object.defineProperty(LifeCycle.prototype.registerWith, "parameters", {get: function() {
          return [[VmTurnZone], [ChangeDetector]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/style_url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/services/url_resolver"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/style_url_resolver";
  var Injectable,
      RegExp,
      RegExpWrapper,
      StringWrapper,
      UrlResolver,
      StyleUrlResolver,
      _cssUrlRe,
      _cssImportRe,
      _quoteRe;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      RegExp = $__m.RegExp;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }],
    execute: function() {
      StyleUrlResolver = (function() {
        function StyleUrlResolver(resolver) {
          this._resolver = resolver;
        }
        return ($traceurRuntime.createClass)(StyleUrlResolver, {
          resolveUrls: function(cssText, baseUrl) {
            cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
            cssText = this._replaceUrls(cssText, _cssImportRe, baseUrl);
            return cssText;
          },
          _replaceUrls: function(cssText, re, baseUrl) {
            var $__0 = this;
            return StringWrapper.replaceAllMapped(cssText, re, (function(m) {
              var pre = m[1];
              var url = StringWrapper.replaceAll(m[2], _quoteRe, '');
              var post = m[3];
              var resolvedUrl = $__0._resolver.resolve(baseUrl, url);
              return pre + "'" + resolvedUrl + "'" + post;
            }));
          }
        }, {});
      }());
      $__export("StyleUrlResolver", StyleUrlResolver);
      Object.defineProperty(StyleUrlResolver, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(StyleUrlResolver, "parameters", {get: function() {
          return [[UrlResolver]];
        }});
      Object.defineProperty(StyleUrlResolver.prototype.resolveUrls, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(StyleUrlResolver.prototype._replaceUrls, "parameters", {get: function() {
          return [[assert.type.string], [RegExp], [assert.type.string]];
        }});
      _cssUrlRe = RegExpWrapper.create('(url\\()([^)]*)(\\))');
      _cssImportRe = RegExpWrapper.create('(@import[\\s]+(?!url\\())[\'"]([^\'"]*)[\'"](.*;)');
      _quoteRe = RegExpWrapper.create('[\'"]');
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/shadow_css", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/shadow_css";
  var DOM,
      List,
      ListWrapper,
      StringWrapper,
      RegExp,
      RegExpWrapper,
      RegExpMatcherWrapper,
      isPresent,
      isBlank,
      BaseException,
      int,
      ShadowCss,
      _cssContentNextSelectorRe,
      _cssContentRuleRe,
      _cssContentUnscopedRuleRe,
      _polyfillHost,
      _polyfillHostContext,
      _parenSuffix,
      _cssColonHostRe,
      _cssColonHostContextRe,
      _polyfillHostNoCombinator,
      _shadowDOMSelectorsRe,
      _selectorReSuffix,
      _polyfillHostRe,
      _colonHostRe,
      _colonHostContextRe;
  function _cssToRules(cssText) {
    return DOM.cssToRules(cssText);
  }
  function _withCssRules(cssText, callback) {
    if (isBlank(callback))
      return ;
    var rules = _cssToRules(cssText);
    callback(rules);
  }
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      RegExp = $__m.RegExp;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      int = $__m.int;
    }],
    execute: function() {
      ShadowCss = (function() {
        function ShadowCss() {
          this.strictStyling = true;
        }
        return ($traceurRuntime.createClass)(ShadowCss, {
          shimStyle: function(style, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            var cssText = DOM.getText(style);
            return this.shimCssText(cssText, selector, hostSelector);
          },
          shimCssText: function(cssText, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            cssText = this._insertDirectives(cssText);
            return this._scopeCssText(cssText, selector, hostSelector);
          },
          _insertDirectives: function(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
          },
          _insertPolyfillDirectivesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function(m) {
              return m[1] + '{';
            });
          },
          _insertPolyfillRulesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function(m) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[1], '');
              rule = StringWrapper.replace(rule, m[2], '');
              return m[3] + rule;
            });
          },
          _scopeCssText: function(cssText, scopeSelector, hostSelector) {
            var $__0 = this;
            var unscoped = this._extractUnscopedRulesFromCssText(cssText);
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (isPresent(scopeSelector)) {
              _withCssRules(cssText, (function(rules) {
                cssText = $__0._scopeRules(rules, scopeSelector, hostSelector);
              }));
            }
            cssText = cssText + '\n' + unscoped;
            return cssText.trim();
          },
          _extractUnscopedRulesFromCssText: function(cssText) {
            var r = '',
                m;
            var matcher = RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
            while (isPresent(m = RegExpMatcherWrapper.next(matcher))) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[2], '');
              rule = StringWrapper.replace(rule, m[1], m[3]);
              r = rule + '\n\n';
            }
            return r;
          },
          _convertColonHost: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
          },
          _convertColonHostContext: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
          },
          _convertColonRule: function(cssText, regExp, partReplacer) {
            return StringWrapper.replaceAllMapped(cssText, regExp, function(m) {
              if (isPresent(m[2])) {
                var parts = m[2].split(','),
                    r = [];
                for (var i = 0; i < parts.length; i++) {
                  var p = parts[i];
                  if (isBlank(p))
                    break;
                  p = p.trim();
                  ListWrapper.push(r, partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
              } else {
                return _polyfillHostNoCombinator + m[3];
              }
            });
          },
          _colonHostContextPartReplacer: function(host, part, suffix) {
            if (StringWrapper.contains(part, _polyfillHost)) {
              return this._colonHostPartReplacer(host, part, suffix);
            } else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
            }
          },
          _colonHostPartReplacer: function(host, part, suffix) {
            return host + StringWrapper.replace(part, _polyfillHost, '') + suffix;
          },
          _convertShadowDOMSelectors: function(cssText) {
            for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
              cssText = StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
            }
            return cssText;
          },
          _scopeRules: function(cssRules, scopeSelector, hostSelector) {
            var cssText = '';
            if (isPresent(cssRules)) {
              for (var i = 0; i < cssRules.length; i++) {
                var rule = cssRules[i];
                if (DOM.isStyleRule(rule) || DOM.isPageRule(rule)) {
                  cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) + ' {\n';
                  cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                } else if (DOM.isMediaRule(rule)) {
                  cssText += '@media ' + rule.media.mediaText + ' {\n';
                  cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                  cssText += '\n}\n\n';
                } else {
                  try {
                    if (isPresent(rule.cssText)) {
                      cssText += rule.cssText + '\n\n';
                    }
                  } catch (x) {
                    if (DOM.isKeyframesRule(rule) && isPresent(rule.cssRules)) {
                      cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                    }
                  }
                }
              }
            }
            return cssText;
          },
          _ieSafeCssTextFromKeyFrameRule: function(rule) {
            var cssText = '@keyframes ' + rule.name + ' {';
            for (var i = 0; i < rule.cssRules.length; i++) {
              var r = rule.cssRules[i];
              cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
            }
            cssText += ' }';
            return cssText;
          },
          _scopeSelector: function(selector, scopeSelector, hostSelector, strict) {
            var r = [],
                parts = selector.split(',');
            for (var i = 0; i < parts.length; i++) {
              var p = parts[i];
              p = p.trim();
              if (this._selectorNeedsScoping(p, scopeSelector)) {
                p = strict && !StringWrapper.contains(p, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(p, scopeSelector) : this._applySelectorScope(p, scopeSelector, hostSelector);
              }
              ListWrapper.push(r, p);
            }
            return r.join(', ');
          },
          _selectorNeedsScoping: function(selector, scopeSelector) {
            var re = this._makeScopeMatcher(scopeSelector);
            return !isPresent(RegExpWrapper.firstMatch(re, selector));
          },
          _makeScopeMatcher: function(scopeSelector) {
            var lre = RegExpWrapper.create('\\[');
            var rre = RegExpWrapper.create('\\]');
            scopeSelector = StringWrapper.replaceAll(scopeSelector, lre, '\\[');
            scopeSelector = StringWrapper.replaceAll(scopeSelector, rre, '\\]');
            return RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
          },
          _applySelectorScope: function(selector, scopeSelector, hostSelector) {
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
          },
          _applySimpleSelectorScope: function(selector, scopeSelector, hostSelector) {
            if (isPresent(RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
              var replaceBy = this.strictStyling ? ("[" + hostSelector + "]") : scopeSelector;
              selector = StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
              return StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
            } else {
              return scopeSelector + ' ' + selector;
            }
          },
          _applyStrictSelectorScope: function(selector, scopeSelector) {
            var isRe = RegExpWrapper.create('\\[is=([^\\]]*)\\]');
            scopeSelector = StringWrapper.replaceAllMapped(scopeSelector, isRe, (function(m) {
              return m[1];
            }));
            var splits = [' ', '>', '+', '~'],
                scoped = selector,
                attrName = '[' + scopeSelector + ']';
            for (var i = 0; i < splits.length; i++) {
              var sep = splits[i];
              var parts = scoped.split(sep);
              scoped = ListWrapper.map(parts, function(p) {
                var t = StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !ListWrapper.contains(splits, t) && !StringWrapper.contains(t, attrName)) {
                  var re = RegExpWrapper.create('([^:]*)(:*)(.*)');
                  var m = RegExpWrapper.firstMatch(re, t);
                  if (isPresent(m)) {
                    p = m[1] + attrName + m[2] + m[3];
                  }
                }
                return p;
              }).join(sep);
            }
            return scoped;
          },
          _insertPolyfillHostInCssText: function(selector) {
            selector = StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
            selector = StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
            return selector;
          },
          _propertiesFromRule: function(rule) {
            var cssText = rule.style.cssText;
            var attrRe = RegExpWrapper.create('[\'"]+|attr');
            if (rule.style.content.length > 0 && !isPresent(RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
              var contentRe = RegExpWrapper.create('content:[^;]*;');
              cssText = StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
            }
            return cssText;
          }
        }, {});
      }());
      $__export("ShadowCss", ShadowCss);
      Object.defineProperty(ShadowCss.prototype.shimStyle, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype.shimCssText, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._insertDirectives, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._insertPolyfillDirectivesInCssText, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._insertPolyfillRulesInCssText, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._scopeCssText, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._extractUnscopedRulesFromCssText, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._convertColonHost, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._convertColonHostContext, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._convertColonRule, "parameters", {get: function() {
          return [[assert.type.string], [RegExp], [Function]];
        }});
      Object.defineProperty(ShadowCss.prototype._colonHostContextPartReplacer, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._colonHostPartReplacer, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._convertShadowDOMSelectors, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._scopeRules, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._scopeSelector, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string], [assert.type.boolean]];
        }});
      Object.defineProperty(ShadowCss.prototype._selectorNeedsScoping, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._makeScopeMatcher, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._applySelectorScope, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._applySimpleSelectorScope, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._applyStrictSelectorScope, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(ShadowCss.prototype._insertPolyfillHostInCssText, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      _cssContentNextSelectorRe = RegExpWrapper.create('polyfill-next-selector[^}]*content:[\\s]*?[\'"](.*?)[\'"][;\\s]*}([^{]*?){', 'im');
      _cssContentRuleRe = RegExpWrapper.create('(polyfill-rule)[^}]*(content:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}', 'im');
      _cssContentUnscopedRuleRe = RegExpWrapper.create('(polyfill-unscoped-rule)[^}]*(content:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}', 'im');
      _polyfillHost = '-shadowcsshost';
      _polyfillHostContext = '-shadowcsscontext';
      _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
      _cssColonHostRe = RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
      _cssColonHostContextRe = RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
      _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
      _shadowDOMSelectorsRe = [RegExpWrapper.create('>>>'), RegExpWrapper.create('::shadow'), RegExpWrapper.create('::content'), RegExpWrapper.create('/deep/'), RegExpWrapper.create('/shadow-deep/'), RegExpWrapper.create('/shadow/')];
      _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
      _polyfillHostRe = RegExpWrapper.create(_polyfillHost, 'im');
      _colonHostRe = RegExpWrapper.create(':host', 'im');
      _colonHostContextRe = RegExpWrapper.create(':host-context', 'im');
      Object.defineProperty(_cssToRules, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_withCssRules, "parameters", {get: function() {
          return [[assert.type.string], [Function]];
        }});
    }
  };
});

System.register("angular2/src/services/xhr_impl", ["angular2/di", "angular2/src/facade/async", "angular2/src/services/xhr"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/xhr_impl";
  var Injectable,
      Promise,
      PromiseWrapper,
      XHR,
      XHRImpl;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      XHR = $__m.XHR;
    }],
    execute: function() {
      XHRImpl = (function($__super) {
        function XHRImpl() {
          $traceurRuntime.superConstructor(XHRImpl).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(XHRImpl, {get: function(url) {
            var completer = PromiseWrapper.completer();
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'text';
            xhr.onload = function() {
              var status = xhr.status;
              if (200 <= status && status <= 300) {
                completer.resolve(xhr.responseText);
              } else {
                completer.reject(("Failed to load " + url));
              }
            };
            xhr.onerror = function() {
              completer.reject(("Failed to load " + url));
            };
            xhr.send();
            return completer.promise;
          }}, {}, $__super);
      }(XHR));
      $__export("XHRImpl", XHRImpl);
      Object.defineProperty(XHRImpl, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(XHRImpl.prototype.get, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/events/key_events", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/events/event_manager"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/key_events";
  var DOM,
      isPresent,
      isBlank,
      StringWrapper,
      RegExpWrapper,
      BaseException,
      NumberWrapper,
      StringMapWrapper,
      ListWrapper,
      EventManagerPlugin,
      modifierKeys,
      modifierKeyGetters,
      KeyEventsPlugin;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      BaseException = $__m.BaseException;
      NumberWrapper = $__m.NumberWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }],
    execute: function() {
      modifierKeys = ['alt', 'control', 'meta', 'shift'];
      modifierKeyGetters = {
        'alt': (function(event) {
          return event.altKey;
        }),
        'control': (function(event) {
          return event.ctrlKey;
        }),
        'meta': (function(event) {
          return event.metaKey;
        }),
        'shift': (function(event) {
          return event.shiftKey;
        })
      };
      KeyEventsPlugin = (function($__super) {
        function KeyEventsPlugin() {
          $traceurRuntime.superConstructor(KeyEventsPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(KeyEventsPlugin, {
          supports: function(eventName) {
            return isPresent(KeyEventsPlugin.parseEventName(eventName));
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
            var outsideHandler = KeyEventsPlugin.eventCallback(element, shouldSupportBubble, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
            this.manager.getZone().runOutsideAngular((function() {
              DOM.on(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
            }));
          }
        }, {
          parseEventName: function(eventName) {
            eventName = eventName.toLowerCase();
            var parts = eventName.split('.');
            var domEventName = ListWrapper.removeAt(parts, 0);
            if ((parts.length === 0) || !(StringWrapper.equals(domEventName, 'keydown') || StringWrapper.equals(domEventName, 'keyup'))) {
              return null;
            }
            var key = ListWrapper.removeLast(parts);
            var fullKey = '';
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (ListWrapper.contains(parts, modifierName)) {
                ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
              }
            }));
            fullKey += key;
            if (parts.length != 0 || key.length === 0) {
              return null;
            }
            return {
              'domEventName': domEventName,
              'fullKey': fullKey
            };
          },
          getEventFullKey: function(event) {
            var fullKey = '';
            var key = DOM.getEventKey(event);
            key = key.toLowerCase();
            if (StringWrapper.equals(key, ' ')) {
              key = 'space';
            } else if (StringWrapper.equals(key, '.')) {
              key = 'dot';
            }
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (modifierName != key) {
                var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                  fullKey += modifierName + '.';
                }
              }
            }));
            fullKey += key;
            return fullKey;
          },
          eventCallback: function(element, shouldSupportBubble, fullKey, handler, zone) {
            return (function(event) {
              var correctElement = shouldSupportBubble || event.target === element;
              if (correctElement && KeyEventsPlugin.getEventFullKey(event) === fullKey) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("KeyEventsPlugin", KeyEventsPlugin);
      Object.defineProperty(KeyEventsPlugin.prototype.supports, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(KeyEventsPlugin.prototype.addEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function], [assert.type.boolean]];
        }});
      Object.defineProperty(KeyEventsPlugin.parseEventName, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_common", ["angular2/src/render/dom/events/event_manager", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_common";
  var EventManagerPlugin,
      StringMapWrapper,
      _eventNames,
      HammerGesturesPluginCommon;
  return {
    setters: [function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      _eventNames = {
        'pan': true,
        'panstart': true,
        'panmove': true,
        'panend': true,
        'pancancel': true,
        'panleft': true,
        'panright': true,
        'panup': true,
        'pandown': true,
        'pinch': true,
        'pinchstart': true,
        'pinchmove': true,
        'pinchend': true,
        'pinchcancel': true,
        'pinchin': true,
        'pinchout': true,
        'press': true,
        'pressup': true,
        'rotate': true,
        'rotatestart': true,
        'rotatemove': true,
        'rotateend': true,
        'rotatecancel': true,
        'swipe': true,
        'swipeleft': true,
        'swiperight': true,
        'swipeup': true,
        'swipedown': true,
        'tap': true
      };
      HammerGesturesPluginCommon = (function($__super) {
        function HammerGesturesPluginCommon() {
          $traceurRuntime.superConstructor(HammerGesturesPluginCommon).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPluginCommon, {supports: function(eventName) {
            eventName = eventName.toLowerCase();
            return StringMapWrapper.contains(_eventNames, eventName);
          }}, {}, $__super);
      }(EventManagerPlugin));
      $__export("HammerGesturesPluginCommon", HammerGesturesPluginCommon);
      Object.defineProperty(HammerGesturesPluginCommon.prototype.supports, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/style_inliner", ["angular2/di", "angular2/src/services/xhr", "angular2/src/facade/collection", "angular2/src/services/url_resolver", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/facade/lang", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/style_inliner";
  var Injectable,
      XHR,
      ListWrapper,
      UrlResolver,
      StyleUrlResolver,
      isBlank,
      isPresent,
      RegExp,
      RegExpWrapper,
      StringWrapper,
      normalizeBlank,
      Promise,
      PromiseWrapper,
      StyleInliner,
      _importRe,
      _urlRe,
      _mediaQueryRe;
  function _extractUrl(importRule) {
    var match = RegExpWrapper.firstMatch(_urlRe, importRule);
    if (isBlank(match))
      return null;
    return isPresent(match[1]) ? match[1] : match[2];
  }
  function _extractMediaQuery(importRule) {
    var match = RegExpWrapper.firstMatch(_mediaQueryRe, importRule);
    if (isBlank(match))
      return null;
    var mediaQuery = match[1].trim();
    return (mediaQuery.length > 0) ? mediaQuery : null;
  }
  function _wrapInMediaRule(css, query) {
    return (isBlank(query)) ? css : ("@media " + query + " {\n" + css + "\n}");
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      RegExp = $__m.RegExp;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
      normalizeBlank = $__m.normalizeBlank;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      StyleInliner = (function() {
        function StyleInliner(xhr, styleUrlResolver, urlResolver) {
          this._xhr = xhr;
          this._urlResolver = urlResolver;
          this._styleUrlResolver = styleUrlResolver;
        }
        return ($traceurRuntime.createClass)(StyleInliner, {
          inlineImports: function(cssText, baseUrl) {
            return this._inlineImports(cssText, baseUrl, []);
          },
          _inlineImports: function(cssText, baseUrl, inlinedUrls) {
            var $__0 = this;
            var partIndex = 0;
            var parts = StringWrapper.split(cssText, _importRe);
            if (parts.length === 1) {
              return cssText;
            }
            var promises = [];
            while (partIndex < parts.length - 1) {
              var prefix = parts[partIndex];
              var rule = parts[partIndex + 1];
              var url = _extractUrl(rule);
              if (isPresent(url)) {
                url = this._urlResolver.resolve(baseUrl, url);
              }
              var mediaQuery = _extractMediaQuery(rule);
              var promise = void 0;
              if (isBlank(url)) {
                promise = PromiseWrapper.resolve(("/* Invalid import rule: \"@import " + rule + ";\" */"));
              } else if (ListWrapper.contains(inlinedUrls, url)) {
                promise = PromiseWrapper.resolve(prefix);
              } else {
                ListWrapper.push(inlinedUrls, url);
                promise = PromiseWrapper.then(this._xhr.get(url), (function(css) {
                  css = $__0._inlineImports(css, url, inlinedUrls);
                  if (PromiseWrapper.isPromise(css)) {
                    return css.then((function(css) {
                      return prefix + $__0._transformImportedCss(css, mediaQuery, url) + '\n';
                    }));
                  } else {
                    return prefix + $__0._transformImportedCss(css, mediaQuery, url) + '\n';
                  }
                }), (function(error) {
                  return ("/* failed to import " + url + " */\n");
                }));
              }
              ListWrapper.push(promises, promise);
              partIndex += 2;
            }
            return PromiseWrapper.all(promises).then(function(cssParts) {
              var cssText = cssParts.join('');
              if (partIndex < parts.length) {
                cssText += parts[partIndex];
              }
              return cssText;
            });
          },
          _transformImportedCss: function(css, mediaQuery, url) {
            css = this._styleUrlResolver.resolveUrls(css, url);
            return _wrapInMediaRule(css, mediaQuery);
          }
        }, {});
      }());
      $__export("StyleInliner", StyleInliner);
      Object.defineProperty(StyleInliner, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(StyleInliner, "parameters", {get: function() {
          return [[XHR], [StyleUrlResolver], [UrlResolver]];
        }});
      Object.defineProperty(StyleInliner.prototype.inlineImports, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(StyleInliner.prototype._inlineImports, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.genericType(List, assert.type.string)]];
        }});
      Object.defineProperty(StyleInliner.prototype._transformImportedCss, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(_extractUrl, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_extractMediaQuery, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_wrapInMediaRule, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
      _importRe = RegExpWrapper.create('@import\\s+([^;]+);');
      _urlRe = RegExpWrapper.create('url\\(\\s*?[\'"]?([^\'")]+)[\'"]?|' + '[\'"]([^\'")]+)[\'"]');
      _mediaQueryRe = RegExpWrapper.create('[\'"][^\'"]+[\'"]\\s*\\)?\\s*(.*)');
    }
  };
});

System.register("angular2/src/core/compiler/dynamic_component_loader", ["angular2/di", "angular2/src/core/compiler/compiler", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/element_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/dynamic_component_loader";
  var Key,
      Injector,
      Injectable,
      ResolvedBinding,
      Binding,
      bind,
      Compiler,
      Type,
      BaseException,
      stringify,
      isPresent,
      Promise,
      AppViewManager,
      ComponentCreateResult,
      ElementRef,
      ComponentRef,
      DynamicComponentLoader;
  return {
    setters: [function($__m) {
      Key = $__m.Key;
      Injector = $__m.Injector;
      Injectable = $__m.Injectable;
      ResolvedBinding = $__m.ResolvedBinding;
      Binding = $__m.Binding;
      bind = $__m.bind;
    }, function($__m) {
      Compiler = $__m.Compiler;
    }, function($__m) {
      Type = $__m.Type;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
      isPresent = $__m.isPresent;
    }, function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
      ComponentCreateResult = $__m.ComponentCreateResult;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }],
    execute: function() {
      ComponentRef = (function() {
        function ComponentRef(location, instance, dispose) {
          this.location = location;
          this.instance = instance;
          this._dispose = dispose;
        }
        return ($traceurRuntime.createClass)(ComponentRef, {
          get hostView() {
            return this.location.parentView;
          },
          dispose: function() {
            this._dispose();
          }
        }, {});
      }());
      $__export("ComponentRef", ComponentRef);
      Object.defineProperty(ComponentRef, "parameters", {get: function() {
          return [[ElementRef], [assert.type.any], [Function]];
        }});
      DynamicComponentLoader = (function() {
        function DynamicComponentLoader(compiler, viewManager) {
          this._compiler = compiler;
          this._viewManager = viewManager;
        }
        return ($traceurRuntime.createClass)(DynamicComponentLoader, {
          loadIntoExistingLocation: function(typeOrBinding, location) {
            var injector = arguments[2] !== (void 0) ? arguments[2] : null;
            var $__0 = this;
            var binding = this._getBinding(typeOrBinding);
            return this._compiler.compile(binding.token).then((function(componentProtoViewRef) {
              $__0._viewManager.createDynamicComponentView(location, componentProtoViewRef, binding, injector);
              var component = $__0._viewManager.getComponent(location);
              var dispose = (function() {
                throw new BaseException("Not implemented");
              });
              return new ComponentRef(location, component, dispose);
            }));
          },
          loadIntoNewLocation: function(typeOrBinding, parentComponentLocation, elementOrSelector) {
            var injector = arguments[3] !== (void 0) ? arguments[3] : null;
            var $__0 = this;
            return this._compiler.compileInHost(this._getBinding(typeOrBinding)).then((function(hostProtoViewRef) {
              var hostViewRef = $__0._viewManager.createInPlaceHostView(parentComponentLocation, elementOrSelector, hostProtoViewRef, injector);
              var newLocation = new ElementRef(hostViewRef, 0);
              var component = $__0._viewManager.getComponent(newLocation);
              var dispose = (function() {
                $__0._viewManager.destroyInPlaceHostView(parentComponentLocation, hostViewRef);
              });
              return new ComponentRef(newLocation, component, dispose);
            }));
          },
          loadNextToExistingLocation: function(typeOrBinding, location) {
            var injector = arguments[2] !== (void 0) ? arguments[2] : null;
            var $__0 = this;
            var binding = this._getBinding(typeOrBinding);
            return this._compiler.compileInHost(binding).then((function(hostProtoViewRef) {
              var viewContainer = $__0._viewManager.getViewContainer(location);
              var hostViewRef = viewContainer.create(hostProtoViewRef, viewContainer.length, injector);
              var newLocation = new ElementRef(hostViewRef, 0);
              var component = $__0._viewManager.getComponent(newLocation);
              var dispose = (function() {
                var index = viewContainer.indexOf(hostViewRef);
                viewContainer.remove(index);
              });
              return new ComponentRef(newLocation, component, dispose);
            }));
          },
          _getBinding: function(typeOrBinding) {
            var binding;
            if (typeOrBinding instanceof Binding) {
              binding = typeOrBinding;
            } else {
              binding = bind(typeOrBinding).toClass(typeOrBinding);
            }
            return binding;
          }
        }, {});
      }());
      $__export("DynamicComponentLoader", DynamicComponentLoader);
      Object.defineProperty(DynamicComponentLoader, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(DynamicComponentLoader, "parameters", {get: function() {
          return [[Compiler], [AppViewManager]];
        }});
      Object.defineProperty(DynamicComponentLoader.prototype.loadIntoExistingLocation, "parameters", {get: function() {
          return [[], [ElementRef], [Injector]];
        }});
      Object.defineProperty(DynamicComponentLoader.prototype.loadIntoNewLocation, "parameters", {get: function() {
          return [[], [ElementRef], [assert.type.any], [Injector]];
        }});
      Object.defineProperty(DynamicComponentLoader.prototype.loadNextToExistingLocation, "parameters", {get: function() {
          return [[], [ElementRef], [Injector]];
        }});
    }
  };
});

System.register("angular2/src/core/testability/get_testability", ["angular2/src/core/testability/testability", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/get_testability";
  var TestabilityRegistry,
      Testability,
      global,
      PublicTestability,
      GetTestability;
  return {
    setters: [function($__m) {
      TestabilityRegistry = $__m.TestabilityRegistry;
      Testability = $__m.Testability;
    }, function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      PublicTestability = (function() {
        function PublicTestability(testability) {
          this._testability = testability;
        }
        return ($traceurRuntime.createClass)(PublicTestability, {
          whenStable: function(callback) {
            this._testability.whenStable(callback);
          },
          findBindings: function(using, binding, exactMatch) {
            return this._testability.findBindings(using, binding, exactMatch);
          }
        }, {});
      }());
      Object.defineProperty(PublicTestability, "parameters", {get: function() {
          return [[Testability]];
        }});
      Object.defineProperty(PublicTestability.prototype.whenStable, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(PublicTestability.prototype.findBindings, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.boolean]];
        }});
      GetTestability = (function() {
        function GetTestability() {}
        return ($traceurRuntime.createClass)(GetTestability, {}, {addToWindow: function(registry) {
            global.getAngularTestability = function(elem) {
              var testability = registry.findTestabilityInTree(elem);
              if (testability == null) {
                throw new Error('Could not find testability for element.');
              }
              return new PublicTestability(testability);
            };
          }});
      }());
      $__export("GetTestability", GetTestability);
      Object.defineProperty(GetTestability.addToWindow, "parameters", {get: function() {
          return [[TestabilityRegistry]];
        }});
    }
  };
});

System.register("angular2/src/core/application_tokens", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_tokens";
  var OpaqueToken,
      appComponentRefToken,
      appElementToken,
      appComponentAnnotatedTypeToken,
      appDocumentToken;
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
    }],
    execute: function() {
      appComponentRefToken = new OpaqueToken('ComponentRef');
      $__export("appComponentRefToken", appComponentRefToken);
      appElementToken = new OpaqueToken('AppElement');
      $__export("appElementToken", appElementToken);
      appComponentAnnotatedTypeToken = new OpaqueToken('AppComponentAnnotatedType');
      $__export("appComponentAnnotatedTypeToken", appComponentAnnotatedTypeToken);
      appDocumentToken = new OpaqueToken('AppDocument');
      $__export("appDocumentToken", appDocumentToken);
    }
  };
});

System.register("angular2/src/core/annotations/di", ["angular2/src/core/annotations_impl/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/di";
  return {
    setters: [function($__m) {
      $__export("QueryAnnotation", $__m.Query);
      $__export("AttributeAnnotation", $__m.Attribute);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/render/dom/shadow_dom/native_shadow_dom_strategy", ["angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/view/view", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/native_shadow_dom_strategy";
  var Promise,
      DOM,
      viewModule,
      StyleUrlResolver,
      ShadowDomStrategy,
      moveViewNodesIntoParent,
      NativeShadowDomStrategy;
  return {
    setters: [function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }, function($__m) {
      moveViewNodesIntoParent = $__m.moveViewNodesIntoParent;
    }],
    execute: function() {
      NativeShadowDomStrategy = (function($__super) {
        function NativeShadowDomStrategy(styleUrlResolver) {
          $traceurRuntime.superConstructor(NativeShadowDomStrategy).call(this);
          this.styleUrlResolver = styleUrlResolver;
        }
        return ($traceurRuntime.createClass)(NativeShadowDomStrategy, {
          attachTemplate: function(el, view) {
            moveViewNodesIntoParent(DOM.createShadowRoot(el), view);
          },
          processStyleElement: function(hostComponentId, templateUrl, styleEl) {
            var cssText = DOM.getText(styleEl);
            cssText = this.styleUrlResolver.resolveUrls(cssText, templateUrl);
            DOM.setText(styleEl, cssText);
            return null;
          }
        }, {}, $__super);
      }(ShadowDomStrategy));
      $__export("NativeShadowDomStrategy", NativeShadowDomStrategy);
      Object.defineProperty(NativeShadowDomStrategy, "parameters", {get: function() {
          return [[StyleUrlResolver]];
        }});
      Object.defineProperty(NativeShadowDomStrategy.prototype.attachTemplate, "parameters", {get: function() {
          return [[], [viewModule.RenderView]];
        }});
      Object.defineProperty(NativeShadowDomStrategy.prototype.processStyleElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/emulated_scoped_shadow_dom_strategy", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/shadow_dom/style_inliner", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/emulated_scoped_shadow_dom_strategy";
  var isBlank,
      isPresent,
      PromiseWrapper,
      Promise,
      DOM,
      StyleInliner,
      StyleUrlResolver,
      EmulatedUnscopedShadowDomStrategy,
      getContentAttribute,
      getHostAttribute,
      getComponentId,
      shimCssForComponent,
      insertStyleElement,
      EmulatedScopedShadowDomStrategy;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      Promise = $__m.Promise;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      EmulatedUnscopedShadowDomStrategy = $__m.EmulatedUnscopedShadowDomStrategy;
    }, function($__m) {
      getContentAttribute = $__m.getContentAttribute;
      getHostAttribute = $__m.getHostAttribute;
      getComponentId = $__m.getComponentId;
      shimCssForComponent = $__m.shimCssForComponent;
      insertStyleElement = $__m.insertStyleElement;
    }],
    execute: function() {
      EmulatedScopedShadowDomStrategy = (function($__super) {
        function EmulatedScopedShadowDomStrategy(styleInliner, styleUrlResolver, styleHost) {
          $traceurRuntime.superConstructor(EmulatedScopedShadowDomStrategy).call(this, styleUrlResolver, styleHost);
          this.styleInliner = styleInliner;
        }
        return ($traceurRuntime.createClass)(EmulatedScopedShadowDomStrategy, {
          processStyleElement: function(hostComponentId, templateUrl, styleEl) {
            var cssText = DOM.getText(styleEl);
            cssText = this.styleUrlResolver.resolveUrls(cssText, templateUrl);
            var css = this.styleInliner.inlineImports(cssText, templateUrl);
            if (PromiseWrapper.isPromise(css)) {
              DOM.setText(styleEl, '');
              return css.then((function(css) {
                css = shimCssForComponent(css, hostComponentId);
                DOM.setText(styleEl, css);
              }));
            } else {
              css = shimCssForComponent(css, hostComponentId);
              DOM.setText(styleEl, css);
            }
            DOM.remove(styleEl);
            insertStyleElement(this.styleHost, styleEl);
            return null;
          },
          processElement: function(hostComponentId, elementComponentId, element) {
            if (isPresent(hostComponentId)) {
              var contentAttribute = getContentAttribute(getComponentId(hostComponentId));
              DOM.setAttribute(element, contentAttribute, '');
            }
            if (isPresent(elementComponentId)) {
              var hostAttribute = getHostAttribute(getComponentId(elementComponentId));
              DOM.setAttribute(element, hostAttribute, '');
            }
          }
        }, {}, $__super);
      }(EmulatedUnscopedShadowDomStrategy));
      $__export("EmulatedScopedShadowDomStrategy", EmulatedScopedShadowDomStrategy);
      Object.defineProperty(EmulatedScopedShadowDomStrategy, "parameters", {get: function() {
          return [[StyleInliner], [StyleUrlResolver], []];
        }});
      Object.defineProperty(EmulatedScopedShadowDomStrategy.prototype.processStyleElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
      Object.defineProperty(EmulatedScopedShadowDomStrategy.prototype.processElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/core/annotations/annotations", ["angular2/src/core/annotations_impl/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/annotations";
  return {
    setters: [function($__m) {
      $__export("ComponentAnnotation", $__m.Component);
      $__export("DirectiveAnnotation", $__m.Directive);
      $__export("onDestroy", $__m.onDestroy);
      $__export("onChange", $__m.onChange);
      $__export("onAllChangesDone", $__m.onAllChangesDone);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/decorators/decorators", ["angular2/src/core/annotations/annotations", "angular2/src/core/annotations/view", "angular2/src/core/annotations/visibility", "angular2/src/core/annotations/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/decorators/decorators";
  var ComponentAnnotation,
      DirectiveAnnotation,
      ViewAnnotation,
      AncestorAnnotation,
      ParentAnnotation,
      AttributeAnnotation,
      QueryAnnotation,
      global,
      Component,
      Decorator,
      View,
      Ancestor,
      Parent,
      Attribute,
      Query;
  function makeDecorator(annotationCls) {
    return function() {
      for (var args = [],
          $__0 = 0; $__0 < arguments.length; $__0++)
        args[$__0] = arguments[$__0];
      var Reflect = global.Reflect;
      if (!(Reflect && Reflect.getMetadata)) {
        throw 'reflect-metadata shim is required when using class decorators';
      }
      var annotationInstance = new (Function.prototype.bind.apply(annotationCls, $traceurRuntime.spread([null], args)))();
      return function(cls) {
        var annotations = Reflect.getMetadata('annotations', cls);
        annotations = annotations || [];
        annotations.push(annotationInstance);
        Reflect.defineMetadata('annotations', annotations, cls);
        return cls;
      };
    };
  }
  function makeParamDecorator(annotationCls) {
    return function() {
      for (var args = [],
          $__0 = 0; $__0 < arguments.length; $__0++)
        args[$__0] = arguments[$__0];
      var Reflect = global.Reflect;
      if (!(Reflect && Reflect.getMetadata)) {
        throw 'reflect-metadata shim is required when using parameter decorators';
      }
      var annotationInstance = new (Function.prototype.bind.apply(annotationCls, $traceurRuntime.spread([null], args)))();
      return function(cls, unusedKey, index) {
        var parameters = Reflect.getMetadata('parameters', cls);
        parameters = parameters || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = annotationInstance;
        Reflect.defineMetadata('parameters', parameters, cls);
        return cls;
      };
    };
  }
  return {
    setters: [function($__m) {
      ComponentAnnotation = $__m.ComponentAnnotation;
      DirectiveAnnotation = $__m.DirectiveAnnotation;
    }, function($__m) {
      ViewAnnotation = $__m.ViewAnnotation;
    }, function($__m) {
      AncestorAnnotation = $__m.AncestorAnnotation;
      ParentAnnotation = $__m.ParentAnnotation;
    }, function($__m) {
      AttributeAnnotation = $__m.AttributeAnnotation;
      QueryAnnotation = $__m.QueryAnnotation;
    }, function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      Component = makeDecorator(ComponentAnnotation);
      $__export("Component", Component);
      Decorator = makeDecorator(DirectiveAnnotation);
      $__export("Decorator", Decorator);
      View = makeDecorator(ViewAnnotation);
      $__export("View", View);
      Ancestor = makeParamDecorator(AncestorAnnotation);
      $__export("Ancestor", Ancestor);
      Parent = makeParamDecorator(ParentAnnotation);
      $__export("Parent", Parent);
      Attribute = makeParamDecorator(AttributeAnnotation);
      $__export("Attribute", Attribute);
      Query = makeParamDecorator(QueryAnnotation);
      $__export("Query", Query);
    }
  };
});

System.register("angular2/src/directives/class", ["angular2/src/core/annotations_impl/annotations", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/core/compiler/element_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/class";
  var Directive,
      isPresent,
      DOM,
      ElementRef,
      CSSClass;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }],
    execute: function() {
      CSSClass = (function() {
        function CSSClass(ngEl) {
          this._domEl = ngEl.domElement;
        }
        return ($traceurRuntime.createClass)(CSSClass, {
          _toggleClass: function(className, enabled) {
            if (enabled) {
              DOM.addClass(this._domEl, className);
            } else {
              DOM.removeClass(this._domEl, className);
            }
          },
          set iterableChanges(changes) {
            var $__0 = this;
            if (isPresent(changes)) {
              changes.forEachAddedItem((function(record) {
                $__0._toggleClass(record.key, record.currentValue);
              }));
              changes.forEachChangedItem((function(record) {
                $__0._toggleClass(record.key, record.currentValue);
              }));
              changes.forEachRemovedItem((function(record) {
                if (record.previousValue) {
                  DOM.removeClass($__0._domEl, record.key);
                }
              }));
            }
          }
        }, {});
      }());
      $__export("CSSClass", CSSClass);
      Object.defineProperty(CSSClass, "annotations", {get: function() {
          return [new Directive({
            selector: '[class]',
            properties: {'iterableChanges': 'class | keyValDiff'}
          })];
        }});
      Object.defineProperty(CSSClass, "parameters", {get: function() {
          return [[ElementRef]];
        }});
    }
  };
});

System.register("angular2/src/directives/for", ["angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/view_ref", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/for";
  var Directive,
      ViewContainerRef,
      ViewRef,
      ProtoViewRef,
      isPresent,
      isBlank,
      ListWrapper,
      For,
      RecordViewTuple;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ViewRef = $__m.ViewRef;
      ProtoViewRef = $__m.ProtoViewRef;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      For = (function() {
        function For(viewContainer, protoViewRef) {
          this.viewContainer = viewContainer;
          this.protoViewRef = protoViewRef;
        }
        return ($traceurRuntime.createClass)(For, {
          set iterableChanges(changes) {
            if (isBlank(changes)) {
              this.viewContainer.clear();
              return ;
            }
            var recordViewTuples = [];
            changes.forEachRemovedItem((function(removedRecord) {
              return ListWrapper.push(recordViewTuples, new RecordViewTuple(removedRecord, null));
            }));
            changes.forEachMovedItem((function(movedRecord) {
              return ListWrapper.push(recordViewTuples, new RecordViewTuple(movedRecord, null));
            }));
            var insertTuples = For.bulkRemove(recordViewTuples, this.viewContainer);
            changes.forEachAddedItem((function(addedRecord) {
              return ListWrapper.push(insertTuples, new RecordViewTuple(addedRecord, null));
            }));
            For.bulkInsert(insertTuples, this.viewContainer, this.protoViewRef);
            for (var i = 0; i < insertTuples.length; i++) {
              this.perViewChange(insertTuples[i].view, insertTuples[i].record);
            }
          },
          perViewChange: function(view, record) {
            view.setLocal('\$implicit', record.item);
            view.setLocal('index', record.currentIndex);
          }
        }, {
          bulkRemove: function(tuples, viewContainer) {
            tuples.sort((function(a, b) {
              return a.record.previousIndex - b.record.previousIndex;
            }));
            var movedTuples = [];
            for (var i = tuples.length - 1; i >= 0; i--) {
              var tuple = tuples[i];
              if (isPresent(tuple.record.currentIndex)) {
                tuple.view = viewContainer.detach(tuple.record.previousIndex);
                ListWrapper.push(movedTuples, tuple);
              } else {
                viewContainer.remove(tuple.record.previousIndex);
              }
            }
            return movedTuples;
          },
          bulkInsert: function(tuples, viewContainer, protoViewRef) {
            tuples.sort((function(a, b) {
              return a.record.currentIndex - b.record.currentIndex;
            }));
            for (var i = 0; i < tuples.length; i++) {
              var tuple = tuples[i];
              if (isPresent(tuple.view)) {
                viewContainer.insert(tuple.view, tuple.record.currentIndex);
              } else {
                tuple.view = viewContainer.create(protoViewRef, tuple.record.currentIndex);
              }
            }
            return tuples;
          }
        });
      }());
      $__export("For", For);
      Object.defineProperty(For, "annotations", {get: function() {
          return [new Directive({
            selector: '[for][of]',
            properties: {'iterableChanges': 'of | iterableDiff'}
          })];
        }});
      Object.defineProperty(For, "parameters", {get: function() {
          return [[ViewContainerRef], [ProtoViewRef]];
        }});
      RecordViewTuple = (function() {
        function RecordViewTuple(record, view) {
          this.record = record;
          this.view = view;
        }
        return ($traceurRuntime.createClass)(RecordViewTuple, {}, {});
      }());
    }
  };
});

System.register("angular2/src/directives/if", ["angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/view_ref", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/if";
  var Directive,
      ViewContainerRef,
      ProtoViewRef,
      isBlank,
      If;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ProtoViewRef = $__m.ProtoViewRef;
    }, function($__m) {
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      If = (function() {
        function If(viewContainer, protoViewRef) {
          this.viewContainer = viewContainer;
          this.prevCondition = null;
          this.protoViewRef = protoViewRef;
        }
        return ($traceurRuntime.createClass)(If, {set condition(newCondition) {
            if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
              this.prevCondition = true;
              this.viewContainer.create(this.protoViewRef);
            } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
              this.prevCondition = false;
              this.viewContainer.clear();
            }
          }}, {});
      }());
      $__export("If", If);
      Object.defineProperty(If, "annotations", {get: function() {
          return [new Directive({
            selector: '[if]',
            properties: {'condition': 'if'}
          })];
        }});
      Object.defineProperty(If, "parameters", {get: function() {
          return [[ViewContainerRef], [ProtoViewRef]];
        }});
    }
  };
});

System.register("angular2/src/directives/non_bindable", ["angular2/src/core/annotations_impl/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/non_bindable";
  var Directive,
      NonBindable;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }],
    execute: function() {
      NonBindable = (function() {
        function NonBindable() {}
        return ($traceurRuntime.createClass)(NonBindable, {}, {});
      }());
      $__export("NonBindable", NonBindable);
      Object.defineProperty(NonBindable, "annotations", {get: function() {
          return [new Directive({
            selector: '[non-bindable]',
            compileChildren: false
          })];
        }});
    }
  };
});

System.register("angular2/src/directives/switch", ["angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/view_ref", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/core/annotations_impl/visibility"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/switch";
  var Directive,
      ViewContainerRef,
      ProtoViewRef,
      isPresent,
      isBlank,
      normalizeBlank,
      ListWrapper,
      List,
      MapWrapper,
      Map,
      Parent,
      SwitchView,
      Switch,
      SwitchWhen,
      SwitchDefault,
      _whenDefault;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ProtoViewRef = $__m.ProtoViewRef;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      normalizeBlank = $__m.normalizeBlank;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
    }, function($__m) {
      Parent = $__m.Parent;
    }],
    execute: function() {
      SwitchView = (function() {
        function SwitchView(viewContainerRef, protoViewRef) {
          this._protoViewRef = protoViewRef;
          this._viewContainerRef = viewContainerRef;
        }
        return ($traceurRuntime.createClass)(SwitchView, {
          create: function() {
            this._viewContainerRef.create(this._protoViewRef);
          },
          destroy: function() {
            this._viewContainerRef.clear();
          }
        }, {});
      }());
      Object.defineProperty(SwitchView, "parameters", {get: function() {
          return [[ViewContainerRef], [ProtoViewRef]];
        }});
      Switch = (function() {
        function Switch() {
          this._valueViews = MapWrapper.create();
          this._activeViews = ListWrapper.create();
          this._useDefault = false;
        }
        return ($traceurRuntime.createClass)(Switch, {
          set value(value) {
            this._emptyAllActiveViews();
            this._useDefault = false;
            var views = MapWrapper.get(this._valueViews, value);
            if (isBlank(views)) {
              this._useDefault = true;
              views = normalizeBlank(MapWrapper.get(this._valueViews, _whenDefault));
            }
            this._activateViews(views);
            this._switchValue = value;
          },
          _onWhenValueChanged: function(oldWhen, newWhen, view) {
            this._deregisterView(oldWhen, view);
            this._registerView(newWhen, view);
            if (oldWhen === this._switchValue) {
              view.destroy();
              ListWrapper.remove(this._activeViews, view);
            } else if (newWhen === this._switchValue) {
              if (this._useDefault) {
                this._useDefault = false;
                this._emptyAllActiveViews();
              }
              view.create();
              ListWrapper.push(this._activeViews, view);
            }
            if (this._activeViews.length === 0 && !this._useDefault) {
              this._useDefault = true;
              this._activateViews(MapWrapper.get(this._valueViews, _whenDefault));
            }
          },
          _emptyAllActiveViews: function() {
            var activeContainers = this._activeViews;
            for (var i = 0; i < activeContainers.length; i++) {
              activeContainers[i].destroy();
            }
            this._activeViews = ListWrapper.create();
          },
          _activateViews: function(views) {
            if (isPresent(views)) {
              for (var i = 0; i < views.length; i++) {
                views[i].create();
              }
              this._activeViews = views;
            }
          },
          _registerView: function(value, view) {
            var views = MapWrapper.get(this._valueViews, value);
            if (isBlank(views)) {
              views = ListWrapper.create();
              MapWrapper.set(this._valueViews, value, views);
            }
            ListWrapper.push(views, view);
          },
          _deregisterView: function(value, view) {
            if (value == _whenDefault)
              return ;
            var views = MapWrapper.get(this._valueViews, value);
            if (views.length == 1) {
              MapWrapper.delete(this._valueViews, value);
            } else {
              ListWrapper.remove(views, view);
            }
          }
        }, {});
      }());
      $__export("Switch", Switch);
      Object.defineProperty(Switch, "annotations", {get: function() {
          return [new Directive({
            selector: '[switch]',
            properties: {'value': 'switch'}
          })];
        }});
      Object.defineProperty(Switch.prototype._onWhenValueChanged, "parameters", {get: function() {
          return [[], [], [SwitchView]];
        }});
      Object.defineProperty(Switch.prototype._activateViews, "parameters", {get: function() {
          return [[assert.genericType(List, SwitchView)]];
        }});
      Object.defineProperty(Switch.prototype._registerView, "parameters", {get: function() {
          return [[], [SwitchView]];
        }});
      Object.defineProperty(Switch.prototype._deregisterView, "parameters", {get: function() {
          return [[], [SwitchView]];
        }});
      SwitchWhen = (function() {
        function SwitchWhen(viewContainer, protoViewRef, sswitch) {
          this._value = _whenDefault;
          this._switch = sswitch;
          this._view = new SwitchView(viewContainer, protoViewRef);
        }
        return ($traceurRuntime.createClass)(SwitchWhen, {
          onDestroy: function() {
            this._switch;
          },
          set when(value) {
            this._switch._onWhenValueChanged(this._value, value, this._view);
            this._value = value;
          }
        }, {});
      }());
      $__export("SwitchWhen", SwitchWhen);
      Object.defineProperty(SwitchWhen, "annotations", {get: function() {
          return [new Directive({
            selector: '[switch-when]',
            properties: {'when': 'switch-when'}
          })];
        }});
      Object.defineProperty(SwitchWhen, "parameters", {get: function() {
          return [[ViewContainerRef], [ProtoViewRef], [Switch, new Parent()]];
        }});
      SwitchDefault = (function() {
        function SwitchDefault(viewContainer, protoViewRef, sswitch) {
          sswitch._registerView(_whenDefault, new SwitchView(viewContainer, protoViewRef));
        }
        return ($traceurRuntime.createClass)(SwitchDefault, {}, {});
      }());
      $__export("SwitchDefault", SwitchDefault);
      Object.defineProperty(SwitchDefault, "annotations", {get: function() {
          return [new Directive({selector: '[switch-default]'})];
        }});
      Object.defineProperty(SwitchDefault, "parameters", {get: function() {
          return [[ViewContainerRef], [ProtoViewRef], [Switch, new Parent()]];
        }});
      _whenDefault = new Object();
    }
  };
});

System.register("angular2/src/forms/validators", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/forms/model"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/validators";
  var isBlank,
      isPresent,
      List,
      ListWrapper,
      StringMapWrapper,
      modelModule,
      Validators;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      modelModule = $__m;
    }],
    execute: function() {
      Validators = (function() {
        function Validators() {}
        return ($traceurRuntime.createClass)(Validators, {}, {
          required: function(c) {
            return isBlank(c.value) || c.value == "" ? {"required": true} : null;
          },
          nullValidator: function(c) {
            return null;
          },
          compose: function(validators) {
            return function(c) {
              var res = ListWrapper.reduce(validators, (function(res, validator) {
                var errors = validator(c);
                return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
              }), {});
              return StringMapWrapper.isEmpty(res) ? null : res;
            };
          },
          group: function(c) {
            var res = {};
            StringMapWrapper.forEach(c.controls, (function(control, name) {
              if (c.contains(name) && isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          array: function(c) {
            var res = {};
            ListWrapper.forEach(c.controls, (function(control) {
              if (isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          _mergeErrors: function(control, res) {
            StringMapWrapper.forEach(control.errors, (function(value, error) {
              if (!StringMapWrapper.contains(res, error)) {
                res[error] = [];
              }
              ListWrapper.push(res[error], control);
            }));
          }
        });
      }());
      $__export("Validators", Validators);
      Object.defineProperty(Validators.required, "parameters", {get: function() {
          return [[modelModule.Control]];
        }});
      Object.defineProperty(Validators.nullValidator, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(Validators.compose, "parameters", {get: function() {
          return [[assert.genericType(List, Function)]];
        }});
      Object.defineProperty(Validators.group, "parameters", {get: function() {
          return [[modelModule.ControlGroup]];
        }});
      Object.defineProperty(Validators.array, "parameters", {get: function() {
          return [[modelModule.ControlArray]];
        }});
    }
  };
});

System.register("angular2/src/forms/directives", ["angular2/src/core/annotations_impl/annotations", "angular2/src/core/annotations_impl/visibility", "angular2/src/core/compiler/element_ref", "angular2/di", "angular2/src/render/api", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/forms/model", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives";
  var Directive,
      onChange,
      Ancestor,
      ElementRef,
      Optional,
      Renderer,
      isPresent,
      isString,
      ListWrapper,
      ControlGroup,
      Validators,
      DefaultValueAccessor,
      CheckboxControlValueAccessor,
      ControlDirective,
      ControlGroupDirective,
      FormDirectives;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      onChange = $__m.onChange;
    }, function($__m) {
      Ancestor = $__m.Ancestor;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Optional = $__m.Optional;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isString = $__m.isString;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ControlGroup = $__m.ControlGroup;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      DefaultValueAccessor = (function() {
        function DefaultValueAccessor() {
          this.onChange = (function(_) {});
        }
        return ($traceurRuntime.createClass)(DefaultValueAccessor, {writeValue: function(value) {
            this.value = value;
          }}, {});
      }());
      $__export("DefaultValueAccessor", DefaultValueAccessor);
      Object.defineProperty(DefaultValueAccessor, "annotations", {get: function() {
          return [new Directive({
            selector: '[control]',
            hostListeners: {
              'change': 'onChange($event.target.value)',
              'input': 'onChange($event.target.value)'
            },
            hostProperties: {'value': 'value'}
          })];
        }});
      CheckboxControlValueAccessor = (function() {
        function CheckboxControlValueAccessor(cd, elementRef, renderer) {
          this.onChange = (function(_) {});
          this._elementRef = elementRef;
          this._renderer = renderer;
          cd.valueAccessor = this;
        }
        return ($traceurRuntime.createClass)(CheckboxControlValueAccessor, {writeValue: function(value) {
            this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, 'checked', value);
          }}, {});
      }());
      $__export("CheckboxControlValueAccessor", CheckboxControlValueAccessor);
      Object.defineProperty(CheckboxControlValueAccessor, "annotations", {get: function() {
          return [new Directive({
            selector: 'input[type=checkbox][control]',
            hostListeners: {'change': 'onChange($event.target.checked)'},
            hostProperties: {'checked': 'checked'}
          })];
        }});
      Object.defineProperty(CheckboxControlValueAccessor, "parameters", {get: function() {
          return [[ControlDirective], [ElementRef], [Renderer]];
        }});
      ControlDirective = (function() {
        function ControlDirective(groupDirective, valueAccessor) {
          this._groupDirective = groupDirective;
          this.controlOrName = null;
          this.valueAccessor = valueAccessor;
          this.validator = Validators.nullValidator;
        }
        return ($traceurRuntime.createClass)(ControlDirective, {
          onChange: function(_) {
            this._initialize();
          },
          _initialize: function() {
            if (isPresent(this._groupDirective)) {
              this._groupDirective.addDirective(this);
            }
            var c = this._control();
            c.validator = Validators.compose([c.validator, this.validator]);
            this._updateDomValue();
            this._setUpUpdateControlValue();
          },
          _updateDomValue: function() {
            this.valueAccessor.writeValue(this._control().value);
          },
          _setUpUpdateControlValue: function() {
            var $__0 = this;
            this.valueAccessor.onChange = (function(newValue) {
              return $__0._control().updateValue(newValue);
            });
          },
          _control: function() {
            if (isString(this.controlOrName)) {
              return this._groupDirective.findControl(this.controlOrName);
            } else {
              return this.controlOrName;
            }
          }
        }, {});
      }());
      $__export("ControlDirective", ControlDirective);
      Object.defineProperty(ControlDirective, "annotations", {get: function() {
          return [new Directive({
            lifecycle: [onChange],
            selector: '[control]',
            properties: {'controlOrName': 'control'}
          })];
        }});
      Object.defineProperty(ControlDirective, "parameters", {get: function() {
          return [[ControlGroupDirective, new Optional(), new Ancestor()], [DefaultValueAccessor]];
        }});
      ControlGroupDirective = (function() {
        function ControlGroupDirective(groupDirective) {
          this._groupDirective = groupDirective;
          this._directives = ListWrapper.create();
        }
        return ($traceurRuntime.createClass)(ControlGroupDirective, {
          set controlGroup(controlGroup) {
            if (isString(controlGroup)) {
              this._controlGroupName = controlGroup;
            } else {
              this._controlGroup = controlGroup;
            }
            this._updateDomValue();
          },
          _updateDomValue: function() {
            ListWrapper.forEach(this._directives, (function(cd) {
              return cd._updateDomValue();
            }));
          },
          addDirective: function(c) {
            ListWrapper.push(this._directives, c);
          },
          findControl: function(name) {
            return this._getControlGroup().controls[name];
          },
          _getControlGroup: function() {
            if (isPresent(this._controlGroupName)) {
              return this._groupDirective.findControl(this._controlGroupName);
            } else {
              return this._controlGroup;
            }
          }
        }, {});
      }());
      $__export("ControlGroupDirective", ControlGroupDirective);
      Object.defineProperty(ControlGroupDirective, "annotations", {get: function() {
          return [new Directive({
            selector: '[control-group]',
            properties: {'controlGroup': 'control-group'}
          })];
        }});
      Object.defineProperty(ControlGroupDirective, "parameters", {get: function() {
          return [[ControlGroupDirective, new Optional(), new Ancestor()]];
        }});
      Object.defineProperty(ControlGroupDirective.prototype.addDirective, "parameters", {get: function() {
          return [[ControlDirective]];
        }});
      Object.defineProperty(ControlGroupDirective.prototype.findControl, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      FormDirectives = [ControlGroupDirective, ControlDirective, CheckboxControlValueAccessor, DefaultValueAccessor];
      $__export("FormDirectives", FormDirectives);
    }
  };
});

System.register("angular2/src/forms/validator_directives", ["angular2/src/core/annotations_impl/annotations", "angular2/src/forms/validators", "angular2/src/forms/directives"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/validator_directives";
  var Directive,
      Validators,
      ControlDirective,
      RequiredValidatorDirective;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Validators = $__m.Validators;
    }, function($__m) {
      ControlDirective = $__m.ControlDirective;
    }],
    execute: function() {
      RequiredValidatorDirective = (function() {
        function RequiredValidatorDirective(c) {
          c.validator = Validators.compose([c.validator, Validators.required]);
        }
        return ($traceurRuntime.createClass)(RequiredValidatorDirective, {}, {});
      }());
      $__export("RequiredValidatorDirective", RequiredValidatorDirective);
      Object.defineProperty(RequiredValidatorDirective, "annotations", {get: function() {
          return [new Directive({selector: '[required]'})];
        }});
      Object.defineProperty(RequiredValidatorDirective, "parameters", {get: function() {
          return [[ControlDirective]];
        }});
    }
  };
});

System.register("angular2/src/forms/form_builder", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/forms/model"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/form_builder";
  var StringMapWrapper,
      ListWrapper,
      List,
      isPresent,
      modelModule,
      FormBuilder;
  return {
    setters: [function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      modelModule = $__m;
    }],
    execute: function() {
      FormBuilder = (function() {
        function FormBuilder() {}
        return ($traceurRuntime.createClass)(FormBuilder, {
          group: function(controlsConfig) {
            var extra = arguments[1] !== (void 0) ? arguments[1] : null;
            var controls = this._reduceControls(controlsConfig);
            var optionals = isPresent(extra) ? StringMapWrapper.get(extra, "optionals") : null;
            var validator = isPresent(extra) ? StringMapWrapper.get(extra, "validator") : null;
            if (isPresent(validator)) {
              return new modelModule.ControlGroup(controls, optionals, validator);
            } else {
              return new modelModule.ControlGroup(controls, optionals);
            }
          },
          control: function(value) {
            var validator = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isPresent(validator)) {
              return new modelModule.Control(value, validator);
            } else {
              return new modelModule.Control(value);
            }
          },
          array: function(controlsConfig) {
            var validator = arguments[1] !== (void 0) ? arguments[1] : null;
            var $__0 = this;
            var controls = ListWrapper.map(controlsConfig, (function(c) {
              return $__0._createControl(c);
            }));
            if (isPresent(validator)) {
              return new modelModule.ControlArray(controls, validator);
            } else {
              return new modelModule.ControlArray(controls);
            }
          },
          _reduceControls: function(controlsConfig) {
            var $__0 = this;
            var controls = {};
            StringMapWrapper.forEach(controlsConfig, (function(controlConfig, controlName) {
              controls[controlName] = $__0._createControl(controlConfig);
            }));
            return controls;
          },
          _createControl: function(controlConfig) {
            if (controlConfig instanceof modelModule.Control || controlConfig instanceof modelModule.ControlGroup || controlConfig instanceof modelModule.ControlArray) {
              return controlConfig;
            } else if (ListWrapper.isList(controlConfig)) {
              var value = ListWrapper.get(controlConfig, 0);
              var validator = controlConfig.length > 1 ? controlConfig[1] : null;
              return this.control(value, validator);
            } else {
              return this.control(controlConfig);
            }
          }
        }, {});
      }());
      $__export("FormBuilder", FormBuilder);
      Object.defineProperty(FormBuilder.prototype.control, "parameters", {get: function() {
          return [[], [Function]];
        }});
      Object.defineProperty(FormBuilder.prototype.array, "parameters", {get: function() {
          return [[List], [Function]];
        }});
    }
  };
});

System.register("src/rules-engine/datamocks/rule.mocks.es6", ["npm:debug@2.2.0", "src/rules-engine/RuleEngine.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/datamocks/rule.mocks.es6";
  var XDebug,
      log,
      RuleEngine,
      clauses,
      rules,
      mocks;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      RuleEngine = $__m.default;
    }],
    execute: function() {
      log = XDebug('RulesEngine.mocks');
      clauses = {
        'rule01-group01-clause01': {
          type: 'IsAuthenticated',
          name: 'User is authenticated',
          owningGroup: 'rule01-group01',
          value: true,
          operator: 'AND'
        },
        'rule01-group01-clause02': {
          type: 'VisitorLocation',
          name: 'User is visiting from france',
          owningGroup: 'rule01-group01',
          value: 'FR',
          operator: 'AND'
        },
        'rule01-group02-clause01': {
          type: 'IsAuthenticated',
          name: 'User is authenticated',
          owningGroup: 'rule01-group02',
          value: true,
          operator: 'AND'
        },
        'rule01-group02-clause02': {
          type: 'VisitorLocation',
          name: 'User is visiting from france',
          owningGroup: 'rule01-group02',
          value: 'CA',
          operator: 'AND'
        }
      };
      rules = {
        'rule01': {
          'name': 'Rule 01 - Is from somewhere far away.',
          'enabled': true,
          'groups': {
            'rule01-group01': {'operator': 'AND'},
            'rule01-group02': {'operator': 'OR'}
          }
        },
        'rule02': {
          'name': 'Rule 02 - Is Mobile Device...',
          'enabled': true,
          'groups': {'rule02-group01': {'operator': 'AND'}}
        },
        'rule03': {
          'name': 'Rule 03 - Url is ...',
          'enabled': true,
          'groups': {
            'rule03-group01': {'operator': 'AND'},
            'rule03-group02': {'operator': 'AND'}
          }
        }
      };
      mocks = {
        rules: rules,
        clauses: clauses,
        init: function() {
          var rootPath = arguments[0] !== (void 0) ? arguments[0] : '/api';
          return new Promise((function(resolve, reject) {
            var rulePath = rootPath + '/rules-engine/rules/';
            var clausePath = rootPath + '/rules-engine/clauses/';
            Object.keys(rules).forEach((function(key) {
              localStorage.setItem(rulePath + key, JSON.stringify(rules[key]));
            }));
            Object.keys(clauses).forEach((function(key) {
              localStorage.setItem(clausePath + key, JSON.stringify(clauses[key]));
            }));
            resolve();
          }));
        }
      };
      $__export("mocks", mocks);
    }
  };
});

System.register("src/rules-engine/actions/RuleEngineActionCreators.es6", ["src/rules-engine/dispatcher/AppDispatcher.ts", "src/dc/index.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/actions/RuleEngineActionCreators.es6";
  var AppDispatcher,
      Core,
      actionTypes,
      actions;
  return {
    setters: [function($__m) {
      AppDispatcher = $__m.AppDispatcher;
    }, function($__m) {
      Core = $__m.Core;
    }],
    execute: function() {
      actionTypes = Core.Collections.asSymmetricObjectMap({
        ADD_RULE: null,
        REMOVE_RULE: null,
        UPDATE_RULE: null,
        ADD_CLAUSE: null,
        UPDATE_CLAUSE: null,
        REMOVE_CLAUSE: null
      }, 'RuleActions.');
      $__export("actionTypes", actionTypes);
      actions = {
        addRule: function(rule) {
          AppDispatcher.dispatch({
            key: actionTypes.ADD_RULE,
            rule: rule
          });
        },
        updateRule: function(rule) {
          AppDispatcher.dispatch({
            key: actionTypes.UPDATE_RULE,
            rule: rule
          });
        },
        removeRule: function(ruleKey) {
          AppDispatcher.dispatch({
            key: actionTypes.REMOVE_RULE,
            ruleKey: ruleKey
          });
        }
      };
      $__export("actions", actions);
    }
  };
});

System.register("src/entity-forge/Validation.es6", [], function($__export) {
  "use strict";
  var __moduleName = "src/entity-forge/Validation.es6";
  var ValidationError;
  return {
    setters: [],
    execute: function() {
      ValidationError = (function($__super) {
        function ValidationError(validationResult, target) {
          $traceurRuntime.superConstructor(ValidationError).call(this);
          this.target = target || '{unknown}';
          this.messages = validationResult.errors.map((function(error) {
            return error.fieldName + ': ' + error.validator.msg;
          }));
          this.message = "One or more failures occurred while validating '" + this.target + "': [[";
          this.message += this.messages.join("],     [") + "]]";
        }
        return ($traceurRuntime.createClass)(ValidationError, {}, {}, $__super);
      }(Error));
      $__export("ValidationError", ValidationError);
    }
  };
});

System.register("src/entity-forge/EntityBaseTypes.es6", ["src/entity-forge/Verify.es6", "src/entity-forge/Validation.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/entity-forge/EntityBaseTypes.es6";
  var LazyVerify,
      Verify,
      ValidationError,
      EntityBase;
  return {
    setters: [function($__m) {
      LazyVerify = $__m.LazyVerify;
      Verify = $__m.Verify;
    }, function($__m) {
      ValidationError = $__m.ValidationError;
    }],
    execute: function() {
      EntityBase = (function() {
        function EntityBase(typeDefinition) {
          this.typeDefinition = typeDefinition;
        }
        return ($traceurRuntime.createClass)(EntityBase, {
          validate: function() {
            var results = this.typeDefinition.validate(this, this.typeDefinition.fieldName);
            if (results.valid === false) {
              throw new ValidationError(results, this.typeDefinition.fieldName);
            }
            return this;
          },
          toJson: function() {
            var validate = arguments[0] !== (void 0) ? arguments[0] : true;
            if (validate !== false) {
              this.validate();
            }
            return JSON.stringify(this);
          }
        }, {});
      }());
      $__export("EntityBase", EntityBase);
    }
  };
});

System.register("src/rules-engine/stores/RuleEngineStore.ts", ["rtts_assert/rtts_assert", "github:jspm/nodelibs-events@0.1.1", "npm:debug@2.2.0", "src/dc/index.es6", "src/rules-engine/dispatcher/AppDispatcher.ts", "src/rules-engine/RuleEngine.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/stores/RuleEngineStore.ts";
  var assert,
      events,
      XDebug,
      log,
      Core,
      AppDispatcher,
      RuleEngine,
      CHANGE_EVENT,
      _RuleStore,
      _store,
      registrationFn,
      RuleStore;
  return {
    setters: [function($__m) {
      assert = $__m.assert;
    }, function($__m) {
      events = $__m.default;
    }, function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      Core = $__m.Core;
    }, function($__m) {
      AppDispatcher = $__m.AppDispatcher;
    }, function($__m) {
      RuleEngine = $__m;
    }],
    execute: function() {
      log = XDebug('RulesEngine.store');
      CHANGE_EVENT = 'change';
      _RuleStore = (function($__super) {
        function _RuleStore() {
          $traceurRuntime.superConstructor(_RuleStore).call(this);
          this.dispatchToken = AppDispatcher.register(registrationFn);
        }
        return ($traceurRuntime.createClass)(_RuleStore, {
          get dispatchToken() {
            return assert.returnType((this.$__0), $traceurRuntime.type.any);
          },
          set dispatchToken(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__0 = value;
          },
          emitChange: function(action) {
            this.emit(CHANGE_EVENT, action);
          },
          addChangeListener: function(callback) {
            this.on(CHANGE_EVENT, callback);
          },
          removeChangeListener: function(callback) {
            this.removeListener(CHANGE_EVENT, callback);
          },
          init: function() {
            RuleEngine.api.ruleRepo.init();
          },
          get: function(key) {
            var p;
            if (!key) {
              return new Promise((function(resolve, reject) {
                resolve(Array.from(_store.values()));
              }));
            } else if (key && _store.has(key)) {
              return new Promise((function(resolve, reject) {
                resolve(_store.get(key));
              }));
            } else {
              p = new Promise((function(resolve, reject) {
                RuleEngine.api.ruleRepo.get(key).then((function(rule) {
                  resolve(rule ? true : false);
                }), (function(e) {
                  return reject(e);
                }));
              }));
            }
            return p;
          }
        }, {}, $__super);
      }(events.EventEmitter));
      _store = assert.type(new Map(), $traceurRuntime.genericType(Map, $traceurRuntime.type.any, $traceurRuntime.type.any));
      registrationFn = function(action) {
        switch (action.key) {
          case RuleEngine.actionTypes.ADD_RULE:
            _store.set(action.rule.$key, action.rule);
            log(action.key, action.rule.$key, action.rule.name, 'count:' + _store.size);
            RuleStore.emitChange(action);
            break;
          case RuleEngine.actionTypes.REMOVE_RULE:
            _store.delete(action.ruleKey);
            log(action.key, action.rule.$key, action.ruleKey, 'count:  ' + _store.size);
            RuleStore.emitChange(action);
            break;
          default:
            log(action.key, "Unhandled");
        }
      };
      RuleStore = new _RuleStore();
      $__export("RuleStore", RuleStore);
    }
  };
});

System.register("src/rules-engine-ng2/log-config.es6", ["npm:debug@2.2.0"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine-ng2/log-config.es6";
  var XDebug;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }],
    execute: function() {
      XDebug.enable(["RulesEngineNg2.*"].join(', '));
    }
  };
});

System.register("rtts_assert/rtts_assert", ["rtts_assert/src/rtts_assert"], function($__export) {
  "use strict";
  var __moduleName = "rtts_assert/rtts_assert";
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("src/dc/api/Check.ts", ["src/dc/log-config.es6", "src/entity-forge/Verify.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/dc/api/Check.ts";
  var XDebug,
      log,
      Verify,
      createCheckError,
      Check;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      Verify = $__m.Verify;
    }],
    execute: function() {
      log = XDebug('DC.Check');
      createCheckError = function(validation, value, message) {
        var e = new Error('Check.' + validation + " failed: '" + message + "'.");
        e['validation'] = validation;
        e['validatedValue'] = value;
        return e;
      };
      Check = {
        exists: function(value) {
          var message = arguments[1] !== (void 0) ? arguments[1] : 'Value does not exist';
          if (!Verify.exists(value)) {
            throw createCheckError('exists', value, message);
          }
          return value;
        },
        isString: function(value) {
          var message = arguments[1] !== (void 0) ? arguments[1] : 'Value is not a string';
          if (!Verify.isString(value)) {
            throw createCheckError('isString', value, message);
          }
          return value;
        },
        notEmpty: function(value) {
          var message = arguments[1] !== (void 0) ? arguments[1] : 'The value is empty';
          if (!Verify.minLength(value, 1)) {
            throw createCheckError('notEmpty', value, message);
          }
          return value;
        }
      };
      $__export("Check", Check);
    }
  };
});

System.register("angular2/src/change_detection/parser/ast", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/ast";
  var autoConvertAdd,
      isBlank,
      isPresent,
      FunctionWrapper,
      BaseException,
      List,
      Map,
      ListWrapper,
      StringMapWrapper,
      AST,
      EmptyExpr,
      ImplicitReceiver,
      Chain,
      Conditional,
      AccessMember,
      KeyedAccess,
      Pipe,
      LiteralPrimitive,
      LiteralArray,
      LiteralMap,
      Interpolation,
      Binary,
      PrefixNot,
      Assignment,
      MethodCall,
      FunctionCall,
      ASTWithSource,
      TemplateBinding,
      AstVisitor,
      AstTransformer,
      _evalListCache;
  function evalList(context, locals, exps) {
    var length = exps.length;
    if (length > 10) {
      throw new BaseException("Cannot have more than 10 argument");
    }
    var result = _evalListCache[length];
    for (var i = 0; i < length; i++) {
      result[i] = exps[i].eval(context, locals);
    }
    return result;
  }
  return {
    setters: [function($__m) {
      autoConvertAdd = $__m.autoConvertAdd;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      FunctionWrapper = $__m.FunctionWrapper;
      BaseException = $__m.BaseException;
    }, function($__m) {
      List = $__m.List;
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      AST = (function() {
        function AST() {}
        return ($traceurRuntime.createClass)(AST, {
          eval: function(context, locals) {
            throw new BaseException("Not supported");
          },
          get isAssignable() {
            return false;
          },
          assign: function(context, locals, value) {
            throw new BaseException("Not supported");
          },
          visit: function(visitor) {},
          toString: function() {
            return "AST";
          }
        }, {});
      }());
      $__export("AST", AST);
      EmptyExpr = (function($__super) {
        function EmptyExpr() {
          $traceurRuntime.superConstructor(EmptyExpr).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(EmptyExpr, {
          eval: function(context, locals) {
            return null;
          },
          visit: function(visitor) {}
        }, {}, $__super);
      }(AST));
      $__export("EmptyExpr", EmptyExpr);
      ImplicitReceiver = (function($__super) {
        function ImplicitReceiver() {
          $traceurRuntime.superConstructor(ImplicitReceiver).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(ImplicitReceiver, {
          eval: function(context, locals) {
            return context;
          },
          visit: function(visitor) {
            return visitor.visitImplicitReceiver(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("ImplicitReceiver", ImplicitReceiver);
      Chain = (function($__super) {
        function Chain(expressions) {
          $traceurRuntime.superConstructor(Chain).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Chain, {
          eval: function(context, locals) {
            var result;
            for (var i = 0; i < this.expressions.length; i++) {
              var last = this.expressions[i].eval(context, locals);
              if (isPresent(last))
                result = last;
            }
            return result;
          },
          visit: function(visitor) {
            return visitor.visitChain(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Chain", Chain);
      Object.defineProperty(Chain, "parameters", {get: function() {
          return [[List]];
        }});
      Conditional = (function($__super) {
        function Conditional(condition, trueExp, falseExp) {
          $traceurRuntime.superConstructor(Conditional).call(this);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
        }
        return ($traceurRuntime.createClass)(Conditional, {
          eval: function(context, locals) {
            if (this.condition.eval(context, locals)) {
              return this.trueExp.eval(context, locals);
            } else {
              return this.falseExp.eval(context, locals);
            }
          },
          visit: function(visitor) {
            return visitor.visitConditional(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Conditional", Conditional);
      Object.defineProperty(Conditional, "parameters", {get: function() {
          return [[AST], [AST], [AST]];
        }});
      AccessMember = (function($__super) {
        function AccessMember(receiver, name, getter, setter) {
          $traceurRuntime.superConstructor(AccessMember).call(this);
          this.receiver = receiver;
          this.name = name;
          this.getter = getter;
          this.setter = setter;
        }
        return ($traceurRuntime.createClass)(AccessMember, {
          eval: function(context, locals) {
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              return locals.get(this.name);
            } else {
              var evaluatedReceiver = this.receiver.eval(context, locals);
              return this.getter(evaluatedReceiver);
            }
          },
          get isAssignable() {
            return true;
          },
          assign: function(context, locals, value) {
            var evaluatedContext = this.receiver.eval(context, locals);
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              throw new BaseException(("Cannot reassign a variable binding " + this.name));
            } else {
              return this.setter(evaluatedContext, value);
            }
          },
          visit: function(visitor) {
            return visitor.visitAccessMember(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("AccessMember", AccessMember);
      Object.defineProperty(AccessMember, "parameters", {get: function() {
          return [[AST], [assert.type.string], [Function], [Function]];
        }});
      KeyedAccess = (function($__super) {
        function KeyedAccess(obj, key) {
          $traceurRuntime.superConstructor(KeyedAccess).call(this);
          this.obj = obj;
          this.key = key;
        }
        return ($traceurRuntime.createClass)(KeyedAccess, {
          eval: function(context, locals) {
            var obj = this.obj.eval(context, locals);
            var key = this.key.eval(context, locals);
            return obj[key];
          },
          get isAssignable() {
            return true;
          },
          assign: function(context, locals, value) {
            var obj = this.obj.eval(context, locals);
            var key = this.key.eval(context, locals);
            obj[key] = value;
            return value;
          },
          visit: function(visitor) {
            return visitor.visitKeyedAccess(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("KeyedAccess", KeyedAccess);
      Object.defineProperty(KeyedAccess, "parameters", {get: function() {
          return [[AST], [AST]];
        }});
      Pipe = (function($__super) {
        function Pipe(exp, name, args, inBinding) {
          $traceurRuntime.superConstructor(Pipe).call(this);
          this.exp = exp;
          this.name = name;
          this.args = args;
          this.inBinding = inBinding;
        }
        return ($traceurRuntime.createClass)(Pipe, {visit: function(visitor) {
            return visitor.visitPipe(this);
          }}, {}, $__super);
      }(AST));
      $__export("Pipe", Pipe);
      Object.defineProperty(Pipe, "parameters", {get: function() {
          return [[AST], [assert.type.string], [List], [assert.type.boolean]];
        }});
      LiteralPrimitive = (function($__super) {
        function LiteralPrimitive(value) {
          $traceurRuntime.superConstructor(LiteralPrimitive).call(this);
          this.value = value;
        }
        return ($traceurRuntime.createClass)(LiteralPrimitive, {
          eval: function(context, locals) {
            return this.value;
          },
          visit: function(visitor) {
            return visitor.visitLiteralPrimitive(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralPrimitive", LiteralPrimitive);
      LiteralArray = (function($__super) {
        function LiteralArray(expressions) {
          $traceurRuntime.superConstructor(LiteralArray).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(LiteralArray, {
          eval: function(context, locals) {
            return ListWrapper.map(this.expressions, (function(e) {
              return e.eval(context, locals);
            }));
          },
          visit: function(visitor) {
            return visitor.visitLiteralArray(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralArray", LiteralArray);
      Object.defineProperty(LiteralArray, "parameters", {get: function() {
          return [[List]];
        }});
      LiteralMap = (function($__super) {
        function LiteralMap(keys, values) {
          $traceurRuntime.superConstructor(LiteralMap).call(this);
          this.keys = keys;
          this.values = values;
        }
        return ($traceurRuntime.createClass)(LiteralMap, {
          eval: function(context, locals) {
            var res = StringMapWrapper.create();
            for (var i = 0; i < this.keys.length; ++i) {
              StringMapWrapper.set(res, this.keys[i], this.values[i].eval(context, locals));
            }
            return res;
          },
          visit: function(visitor) {
            return visitor.visitLiteralMap(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralMap", LiteralMap);
      Object.defineProperty(LiteralMap, "parameters", {get: function() {
          return [[List], [List]];
        }});
      Interpolation = (function($__super) {
        function Interpolation(strings, expressions) {
          $traceurRuntime.superConstructor(Interpolation).call(this);
          this.strings = strings;
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Interpolation, {
          eval: function(context, locals) {
            throw new BaseException("evaluating an Interpolation is not supported");
          },
          visit: function(visitor) {
            visitor.visitInterpolation(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Interpolation", Interpolation);
      Object.defineProperty(Interpolation, "parameters", {get: function() {
          return [[List], [List]];
        }});
      Binary = (function($__super) {
        function Binary(operation, left, right) {
          $traceurRuntime.superConstructor(Binary).call(this);
          this.operation = operation;
          this.left = left;
          this.right = right;
        }
        return ($traceurRuntime.createClass)(Binary, {
          eval: function(context, locals) {
            var left = this.left.eval(context, locals);
            switch (this.operation) {
              case '&&':
                return left && this.right.eval(context, locals);
              case '||':
                return left || this.right.eval(context, locals);
            }
            var right = this.right.eval(context, locals);
            switch (this.operation) {
              case '+':
                return left + right;
              case '-':
                return left - right;
              case '*':
                return left * right;
              case '/':
                return left / right;
              case '%':
                return left % right;
              case '==':
                return left == right;
              case '!=':
                return left != right;
              case '===':
                return left === right;
              case '!==':
                return left !== right;
              case '<':
                return left < right;
              case '>':
                return left > right;
              case '<=':
                return left <= right;
              case '>=':
                return left >= right;
              case '^':
                return left ^ right;
              case '&':
                return left & right;
            }
            throw 'Internal error [$operation] not handled';
          },
          visit: function(visitor) {
            return visitor.visitBinary(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Binary", Binary);
      Object.defineProperty(Binary, "parameters", {get: function() {
          return [[assert.type.string], [AST], [AST]];
        }});
      PrefixNot = (function($__super) {
        function PrefixNot(expression) {
          $traceurRuntime.superConstructor(PrefixNot).call(this);
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(PrefixNot, {
          eval: function(context, locals) {
            return !this.expression.eval(context, locals);
          },
          visit: function(visitor) {
            return visitor.visitPrefixNot(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("PrefixNot", PrefixNot);
      Object.defineProperty(PrefixNot, "parameters", {get: function() {
          return [[AST]];
        }});
      Assignment = (function($__super) {
        function Assignment(target, value) {
          $traceurRuntime.superConstructor(Assignment).call(this);
          this.target = target;
          this.value = value;
        }
        return ($traceurRuntime.createClass)(Assignment, {
          eval: function(context, locals) {
            return this.target.assign(context, locals, this.value.eval(context, locals));
          },
          visit: function(visitor) {
            return visitor.visitAssignment(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Assignment", Assignment);
      Object.defineProperty(Assignment, "parameters", {get: function() {
          return [[AST], [AST]];
        }});
      MethodCall = (function($__super) {
        function MethodCall(receiver, name, fn, args) {
          $traceurRuntime.superConstructor(MethodCall).call(this);
          this.receiver = receiver;
          this.fn = fn;
          this.args = args;
          this.name = name;
        }
        return ($traceurRuntime.createClass)(MethodCall, {
          eval: function(context, locals) {
            var evaluatedArgs = evalList(context, locals, this.args);
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              var fn = locals.get(this.name);
              return FunctionWrapper.apply(fn, evaluatedArgs);
            } else {
              var evaluatedReceiver = this.receiver.eval(context, locals);
              return this.fn(evaluatedReceiver, evaluatedArgs);
            }
          },
          visit: function(visitor) {
            return visitor.visitMethodCall(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("MethodCall", MethodCall);
      Object.defineProperty(MethodCall, "parameters", {get: function() {
          return [[AST], [assert.type.string], [Function], [List]];
        }});
      FunctionCall = (function($__super) {
        function FunctionCall(target, args) {
          $traceurRuntime.superConstructor(FunctionCall).call(this);
          this.target = target;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(FunctionCall, {
          eval: function(context, locals) {
            var obj = this.target.eval(context, locals);
            if (!(obj instanceof Function)) {
              throw new BaseException((obj + " is not a function"));
            }
            return FunctionWrapper.apply(obj, evalList(context, locals, this.args));
          },
          visit: function(visitor) {
            return visitor.visitFunctionCall(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("FunctionCall", FunctionCall);
      Object.defineProperty(FunctionCall, "parameters", {get: function() {
          return [[AST], [List]];
        }});
      ASTWithSource = (function($__super) {
        function ASTWithSource(ast, source, location) {
          $traceurRuntime.superConstructor(ASTWithSource).call(this);
          this.source = source;
          this.location = location;
          this.ast = ast;
        }
        return ($traceurRuntime.createClass)(ASTWithSource, {
          eval: function(context, locals) {
            return this.ast.eval(context, locals);
          },
          get isAssignable() {
            return this.ast.isAssignable;
          },
          assign: function(context, locals, value) {
            return this.ast.assign(context, locals, value);
          },
          visit: function(visitor) {
            return this.ast.visit(visitor);
          },
          toString: function() {
            return (this.source + " in " + this.location);
          }
        }, {}, $__super);
      }(AST));
      $__export("ASTWithSource", ASTWithSource);
      Object.defineProperty(ASTWithSource, "parameters", {get: function() {
          return [[AST], [assert.type.string], [assert.type.string]];
        }});
      TemplateBinding = (function() {
        function TemplateBinding(key, keyIsVar, name, expression) {
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(TemplateBinding, {}, {});
      }());
      $__export("TemplateBinding", TemplateBinding);
      Object.defineProperty(TemplateBinding, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.boolean], [assert.type.string], [ASTWithSource]];
        }});
      AstVisitor = (function() {
        function AstVisitor() {}
        return ($traceurRuntime.createClass)(AstVisitor, {
          visitAccessMember: function(ast) {},
          visitAssignment: function(ast) {},
          visitBinary: function(ast) {},
          visitChain: function(ast) {},
          visitConditional: function(ast) {},
          visitPipe: function(ast) {},
          visitFunctionCall: function(ast) {},
          visitImplicitReceiver: function(ast) {},
          visitKeyedAccess: function(ast) {},
          visitLiteralArray: function(ast) {},
          visitLiteralMap: function(ast) {},
          visitLiteralPrimitive: function(ast) {},
          visitMethodCall: function(ast) {},
          visitPrefixNot: function(ast) {}
        }, {});
      }());
      $__export("AstVisitor", AstVisitor);
      Object.defineProperty(AstVisitor.prototype.visitAccessMember, "parameters", {get: function() {
          return [[AccessMember]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitAssignment, "parameters", {get: function() {
          return [[Assignment]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitBinary, "parameters", {get: function() {
          return [[Binary]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitChain, "parameters", {get: function() {
          return [[Chain]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitConditional, "parameters", {get: function() {
          return [[Conditional]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitPipe, "parameters", {get: function() {
          return [[Pipe]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitFunctionCall, "parameters", {get: function() {
          return [[FunctionCall]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitImplicitReceiver, "parameters", {get: function() {
          return [[ImplicitReceiver]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitKeyedAccess, "parameters", {get: function() {
          return [[KeyedAccess]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitLiteralArray, "parameters", {get: function() {
          return [[LiteralArray]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitLiteralMap, "parameters", {get: function() {
          return [[LiteralMap]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitLiteralPrimitive, "parameters", {get: function() {
          return [[LiteralPrimitive]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitMethodCall, "parameters", {get: function() {
          return [[MethodCall]];
        }});
      Object.defineProperty(AstVisitor.prototype.visitPrefixNot, "parameters", {get: function() {
          return [[PrefixNot]];
        }});
      AstTransformer = (function() {
        function AstTransformer() {}
        return ($traceurRuntime.createClass)(AstTransformer, {
          visitImplicitReceiver: function(ast) {
            return ast;
          },
          visitInterpolation: function(ast) {
            return new Interpolation(ast.strings, this.visitAll(ast.expressions));
          },
          visitLiteralPrimitive: function(ast) {
            return new LiteralPrimitive(ast.value);
          },
          visitAccessMember: function(ast) {
            return new AccessMember(ast.receiver.visit(this), ast.name, ast.getter, ast.setter);
          },
          visitMethodCall: function(ast) {
            return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
          },
          visitFunctionCall: function(ast) {
            return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
          },
          visitLiteralArray: function(ast) {
            return new LiteralArray(this.visitAll(ast.expressions));
          },
          visitLiteralMap: function(ast) {
            return new LiteralMap(ast.keys, this.visitAll(ast.values));
          },
          visitBinary: function(ast) {
            return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
          },
          visitPrefixNot: function(ast) {
            return new PrefixNot(ast.expression.visit(this));
          },
          visitConditional: function(ast) {
            return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
          },
          visitPipe: function(ast) {
            return new Pipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.inBinding);
          },
          visitKeyedAccess: function(ast) {
            return new KeyedAccess(ast.obj.visit(this), ast.key.visit(this));
          },
          visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          }
        }, {});
      }());
      $__export("AstTransformer", AstTransformer);
      Object.defineProperty(AstTransformer.prototype.visitImplicitReceiver, "parameters", {get: function() {
          return [[ImplicitReceiver]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitInterpolation, "parameters", {get: function() {
          return [[Interpolation]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitLiteralPrimitive, "parameters", {get: function() {
          return [[LiteralPrimitive]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitAccessMember, "parameters", {get: function() {
          return [[AccessMember]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitMethodCall, "parameters", {get: function() {
          return [[MethodCall]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitFunctionCall, "parameters", {get: function() {
          return [[FunctionCall]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitLiteralArray, "parameters", {get: function() {
          return [[LiteralArray]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitLiteralMap, "parameters", {get: function() {
          return [[LiteralMap]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitBinary, "parameters", {get: function() {
          return [[Binary]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitPrefixNot, "parameters", {get: function() {
          return [[PrefixNot]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitConditional, "parameters", {get: function() {
          return [[Conditional]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitPipe, "parameters", {get: function() {
          return [[Pipe]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitKeyedAccess, "parameters", {get: function() {
          return [[KeyedAccess]];
        }});
      Object.defineProperty(AstTransformer.prototype.visitAll, "parameters", {get: function() {
          return [[List]];
        }});
      _evalListCache = [[], [0], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];
      Object.defineProperty(evalList, "parameters", {get: function() {
          return [[], [], [List]];
        }});
    }
  };
});

System.register("angular2/src/reflection/reflector", ["angular2/src/facade/collection", "angular2/src/reflection/types"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflector";
  var MapWrapper,
      StringMapWrapper,
      __esModule,
      Reflector;
  function _mergeMaps(target, config) {
    StringMapWrapper.forEach(config, (function(v, k) {
      return MapWrapper.set(target, k, v);
    }));
  }
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      $__export("SetterFn", $__m.SetterFn);
      $__export("GetterFn", $__m.GetterFn);
      $__export("MethodFn", $__m.MethodFn);
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      Reflector = (function() {
        function Reflector(reflectionCapabilities) {
          this._typeInfo = MapWrapper.create();
          this._getters = MapWrapper.create();
          this._setters = MapWrapper.create();
          this._methods = MapWrapper.create();
          this.reflectionCapabilities = reflectionCapabilities;
        }
        return ($traceurRuntime.createClass)(Reflector, {
          registerType: function(type, typeInfo) {
            MapWrapper.set(this._typeInfo, type, typeInfo);
          },
          registerGetters: function(getters) {
            _mergeMaps(this._getters, getters);
          },
          registerSetters: function(setters) {
            _mergeMaps(this._setters, setters);
          },
          registerMethods: function(methods) {
            _mergeMaps(this._methods, methods);
          },
          factory: function(type) {
            if (MapWrapper.contains(this._typeInfo, type)) {
              return MapWrapper.get(this._typeInfo, type)["factory"];
            } else {
              return this.reflectionCapabilities.factory(type);
            }
          },
          parameters: function(typeOfFunc) {
            if (MapWrapper.contains(this._typeInfo, typeOfFunc)) {
              return MapWrapper.get(this._typeInfo, typeOfFunc)["parameters"];
            } else {
              return this.reflectionCapabilities.parameters(typeOfFunc);
            }
          },
          annotations: function(typeOfFunc) {
            if (MapWrapper.contains(this._typeInfo, typeOfFunc)) {
              return MapWrapper.get(this._typeInfo, typeOfFunc)["annotations"];
            } else {
              return this.reflectionCapabilities.annotations(typeOfFunc);
            }
          },
          getter: function(name) {
            if (MapWrapper.contains(this._getters, name)) {
              return MapWrapper.get(this._getters, name);
            } else {
              return this.reflectionCapabilities.getter(name);
            }
          },
          setter: function(name) {
            if (MapWrapper.contains(this._setters, name)) {
              return MapWrapper.get(this._setters, name);
            } else {
              return this.reflectionCapabilities.setter(name);
            }
          },
          method: function(name) {
            if (MapWrapper.contains(this._methods, name)) {
              return MapWrapper.get(this._methods, name);
            } else {
              return this.reflectionCapabilities.method(name);
            }
          }
        }, {});
      }());
      $__export("Reflector", Reflector);
    }
  };
});

System.register("angular2/src/change_detection/directive_record", ["angular2/src/change_detection/constants", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/directive_record";
  var ON_PUSH,
      StringWrapper,
      DirectiveIndex,
      DirectiveRecord;
  return {
    setters: [function($__m) {
      ON_PUSH = $__m.ON_PUSH;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
    }],
    execute: function() {
      DirectiveIndex = (function() {
        function DirectiveIndex(elementIndex, directiveIndex) {
          this.elementIndex = elementIndex;
          this.directiveIndex = directiveIndex;
        }
        return ($traceurRuntime.createClass)(DirectiveIndex, {get name() {
            return (this.elementIndex + "_" + this.directiveIndex);
          }}, {});
      }());
      $__export("DirectiveIndex", DirectiveIndex);
      Object.defineProperty(DirectiveIndex, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.number]];
        }});
      DirectiveRecord = (function() {
        function DirectiveRecord(directiveIndex, callOnAllChangesDone, callOnChange, changeDetection) {
          this.directiveIndex = directiveIndex;
          this.callOnAllChangesDone = callOnAllChangesDone;
          this.callOnChange = callOnChange;
          this.changeDetection = changeDetection;
        }
        return ($traceurRuntime.createClass)(DirectiveRecord, {isOnPushChangeDetection: function() {
            return StringWrapper.equals(this.changeDetection, ON_PUSH);
          }}, {});
      }());
      $__export("DirectiveRecord", DirectiveRecord);
      Object.defineProperty(DirectiveRecord, "parameters", {get: function() {
          return [[DirectiveIndex], [assert.type.boolean], [assert.type.boolean], [assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/change_detection_util", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/proto_record", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/pipes/pipe", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_util";
  var isPresent,
      isBlank,
      BaseException,
      Type,
      List,
      ListWrapper,
      MapWrapper,
      StringMapWrapper,
      ProtoRecord,
      ExpressionChangedAfterItHasBeenChecked,
      WrappedValue,
      CHECK_ALWAYS,
      CHECK_ONCE,
      CHECKED,
      DETACHED,
      ON_PUSH,
      uninitialized,
      SimpleChange,
      _simpleChangesIndex,
      _simpleChanges,
      ChangeDetectionUtil;
  function _simpleChange(previousValue, currentValue) {
    var index = _simpleChangesIndex++ % 20;
    var s = _simpleChanges[index];
    s.previousValue = previousValue;
    s.currentValue = currentValue;
    return s;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      Type = $__m.Type;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
    }, function($__m) {
      ExpressionChangedAfterItHasBeenChecked = $__m.ExpressionChangedAfterItHasBeenChecked;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
    }, function($__m) {
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
      CHECK_ONCE = $__m.CHECK_ONCE;
      CHECKED = $__m.CHECKED;
      DETACHED = $__m.DETACHED;
      ON_PUSH = $__m.ON_PUSH;
    }],
    execute: function() {
      uninitialized = new Object();
      $__export("uninitialized", uninitialized);
      SimpleChange = (function() {
        function SimpleChange(previousValue, currentValue) {
          this.previousValue = previousValue;
          this.currentValue = currentValue;
        }
        return ($traceurRuntime.createClass)(SimpleChange, {}, {});
      }());
      $__export("SimpleChange", SimpleChange);
      Object.defineProperty(SimpleChange, "parameters", {get: function() {
          return [[assert.type.any], [assert.type.any]];
        }});
      _simpleChangesIndex = 0;
      _simpleChanges = [new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null)];
      ChangeDetectionUtil = (function() {
        function ChangeDetectionUtil() {}
        return ($traceurRuntime.createClass)(ChangeDetectionUtil, {}, {
          unitialized: function() {
            return uninitialized;
          },
          arrayFn0: function() {
            return [];
          },
          arrayFn1: function(a1) {
            return [a1];
          },
          arrayFn2: function(a1, a2) {
            return [a1, a2];
          },
          arrayFn3: function(a1, a2, a3) {
            return [a1, a2, a3];
          },
          arrayFn4: function(a1, a2, a3, a4) {
            return [a1, a2, a3, a4];
          },
          arrayFn5: function(a1, a2, a3, a4, a5) {
            return [a1, a2, a3, a4, a5];
          },
          arrayFn6: function(a1, a2, a3, a4, a5, a6) {
            return [a1, a2, a3, a4, a5, a6];
          },
          arrayFn7: function(a1, a2, a3, a4, a5, a6, a7) {
            return [a1, a2, a3, a4, a5, a6, a7];
          },
          arrayFn8: function(a1, a2, a3, a4, a5, a6, a7, a8) {
            return [a1, a2, a3, a4, a5, a6, a7, a8];
          },
          arrayFn9: function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
          },
          operation_negate: function(value) {
            return !value;
          },
          operation_add: function(left, right) {
            return left + right;
          },
          operation_subtract: function(left, right) {
            return left - right;
          },
          operation_multiply: function(left, right) {
            return left * right;
          },
          operation_divide: function(left, right) {
            return left / right;
          },
          operation_remainder: function(left, right) {
            return left % right;
          },
          operation_equals: function(left, right) {
            return left == right;
          },
          operation_not_equals: function(left, right) {
            return left != right;
          },
          operation_less_then: function(left, right) {
            return left < right;
          },
          operation_greater_then: function(left, right) {
            return left > right;
          },
          operation_less_or_equals_then: function(left, right) {
            return left <= right;
          },
          operation_greater_or_equals_then: function(left, right) {
            return left >= right;
          },
          operation_logical_and: function(left, right) {
            return left && right;
          },
          operation_logical_or: function(left, right) {
            return left || right;
          },
          cond: function(cond, trueVal, falseVal) {
            return cond ? trueVal : falseVal;
          },
          mapFn: function(keys) {
            function buildMap(values) {
              var res = StringMapWrapper.create();
              for (var i = 0; i < keys.length; ++i) {
                StringMapWrapper.set(res, keys[i], values[i]);
              }
              return res;
            }
            switch (keys.length) {
              case 0:
                return (function() {
                  return [];
                });
              case 1:
                return (function(a1) {
                  return buildMap([a1]);
                });
              case 2:
                return (function(a1, a2) {
                  return buildMap([a1, a2]);
                });
              case 3:
                return (function(a1, a2, a3) {
                  return buildMap([a1, a2, a3]);
                });
              case 4:
                return (function(a1, a2, a3, a4) {
                  return buildMap([a1, a2, a3, a4]);
                });
              case 5:
                return (function(a1, a2, a3, a4, a5) {
                  return buildMap([a1, a2, a3, a4, a5]);
                });
              case 6:
                return (function(a1, a2, a3, a4, a5, a6) {
                  return buildMap([a1, a2, a3, a4, a5, a6]);
                });
              case 7:
                return (function(a1, a2, a3, a4, a5, a6, a7) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7]);
                });
              case 8:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]);
                });
              case 9:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                });
              default:
                throw new BaseException("Does not support literal maps with more than 9 elements");
            }
          },
          keyedAccess: function(obj, args) {
            return obj[args[0]];
          },
          unwrapValue: function(value) {
            if (value instanceof WrappedValue) {
              return value.wrapped;
            } else {
              return value;
            }
          },
          throwOnChange: function(proto, change) {
            throw new ExpressionChangedAfterItHasBeenChecked(proto, change);
          },
          changeDetectionMode: function(strategy) {
            return strategy == ON_PUSH ? CHECK_ONCE : CHECK_ALWAYS;
          },
          simpleChange: function(previousValue, currentValue) {
            return _simpleChange(previousValue, currentValue);
          },
          addChange: function(changes, propertyName, change) {
            if (isBlank(changes)) {
              changes = {};
            }
            changes[propertyName] = change;
            return changes;
          }
        });
      }());
      $__export("ChangeDetectionUtil", ChangeDetectionUtil);
      Object.defineProperty(ChangeDetectionUtil.mapFn, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(ChangeDetectionUtil.unwrapValue, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(ChangeDetectionUtil.throwOnChange, "parameters", {get: function() {
          return [[ProtoRecord], []];
        }});
      Object.defineProperty(ChangeDetectionUtil.changeDetectionMode, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ChangeDetectionUtil.simpleChange, "parameters", {get: function() {
          return [[assert.type.any], [assert.type.any]];
        }});
      Object.defineProperty(ChangeDetectionUtil.addChange, "parameters", {get: function() {
          return [[], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/change_detection/abstract_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/interfaces", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/abstract_change_detector";
  var isPresent,
      List,
      ListWrapper,
      ChangeDetectorRef,
      ChangeDetector,
      CHECK_ALWAYS,
      CHECK_ONCE,
      CHECKED,
      DETACHED,
      ON_PUSH,
      AbstractChangeDetector;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      ChangeDetector = $__m.ChangeDetector;
    }, function($__m) {
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
      CHECK_ONCE = $__m.CHECK_ONCE;
      CHECKED = $__m.CHECKED;
      DETACHED = $__m.DETACHED;
      ON_PUSH = $__m.ON_PUSH;
    }],
    execute: function() {
      AbstractChangeDetector = (function($__super) {
        function AbstractChangeDetector() {
          $traceurRuntime.superConstructor(AbstractChangeDetector).call(this);
          this.lightDomChildren = [];
          this.shadowDomChildren = [];
          this.ref = new ChangeDetectorRef(this);
          this.mode = null;
        }
        return ($traceurRuntime.createClass)(AbstractChangeDetector, {
          addChild: function(cd) {
            ListWrapper.push(this.lightDomChildren, cd);
            cd.parent = this;
          },
          removeChild: function(cd) {
            ListWrapper.remove(this.lightDomChildren, cd);
          },
          addShadowDomChild: function(cd) {
            ListWrapper.push(this.shadowDomChildren, cd);
            cd.parent = this;
          },
          removeShadowDomChild: function(cd) {
            ListWrapper.remove(this.shadowDomChildren, cd);
          },
          remove: function() {
            this.parent.removeChild(this);
          },
          detectChanges: function() {
            this._detectChanges(false);
          },
          checkNoChanges: function() {
            this._detectChanges(true);
          },
          _detectChanges: function(throwOnChange) {
            if (this.mode === DETACHED || this.mode === CHECKED)
              return ;
            this.detectChangesInRecords(throwOnChange);
            this._detectChangesInLightDomChildren(throwOnChange);
            this.callOnAllChangesDone();
            this._detectChangesInShadowDomChildren(throwOnChange);
            if (this.mode === CHECK_ONCE)
              this.mode = CHECKED;
          },
          detectChangesInRecords: function(throwOnChange) {},
          callOnAllChangesDone: function() {},
          _detectChangesInLightDomChildren: function(throwOnChange) {
            var c = this.lightDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i]._detectChanges(throwOnChange);
            }
          },
          _detectChangesInShadowDomChildren: function(throwOnChange) {
            var c = this.shadowDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i]._detectChanges(throwOnChange);
            }
          },
          markAsCheckOnce: function() {
            this.mode = CHECK_ONCE;
          },
          markPathToRootAsCheckOnce: function() {
            var c = this;
            while (isPresent(c) && c.mode != DETACHED) {
              if (c.mode === CHECKED)
                c.mode = CHECK_ONCE;
              c = c.parent;
            }
          }
        }, {}, $__super);
      }(ChangeDetector));
      $__export("AbstractChangeDetector", AbstractChangeDetector);
      Object.defineProperty(AbstractChangeDetector.prototype.addChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype.removeChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype.addShadowDomChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype.removeShadowDomChild, "parameters", {get: function() {
          return [[ChangeDetector]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype._detectChanges, "parameters", {get: function() {
          return [[assert.type.boolean]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype.detectChangesInRecords, "parameters", {get: function() {
          return [[assert.type.boolean]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype._detectChangesInLightDomChildren, "parameters", {get: function() {
          return [[assert.type.boolean]];
        }});
      Object.defineProperty(AbstractChangeDetector.prototype._detectChangesInShadowDomChildren, "parameters", {get: function() {
          return [[assert.type.boolean]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/change_detection", ["angular2/src/change_detection/proto_change_detector", "angular2/src/change_detection/pipes/pipe_registry", "angular2/src/change_detection/pipes/iterable_changes", "angular2/src/change_detection/pipes/keyvalue_changes", "angular2/src/change_detection/pipes/async_pipe", "angular2/src/change_detection/pipes/null_pipe", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/constants", "angular2/src/change_detection/interfaces", "angular2/di", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection";
  var DynamicProtoChangeDetector,
      JitProtoChangeDetector,
      PipeRegistry,
      IterableChangesFactory,
      KeyValueChangesFactory,
      AsyncPipeFactory,
      NullPipeFactory,
      BindingRecord,
      DirectiveRecord,
      DEFAULT,
      ChangeDetection,
      ProtoChangeDetector,
      Injectable,
      List,
      keyValDiff,
      iterableDiff,
      async,
      defaultPipes,
      DynamicChangeDetection,
      JitChangeDetection,
      defaultPipeRegistry;
  return {
    setters: [function($__m) {
      DynamicProtoChangeDetector = $__m.DynamicProtoChangeDetector;
      JitProtoChangeDetector = $__m.JitProtoChangeDetector;
    }, function($__m) {
      PipeRegistry = $__m.PipeRegistry;
    }, function($__m) {
      IterableChangesFactory = $__m.IterableChangesFactory;
    }, function($__m) {
      KeyValueChangesFactory = $__m.KeyValueChangesFactory;
    }, function($__m) {
      AsyncPipeFactory = $__m.AsyncPipeFactory;
    }, function($__m) {
      NullPipeFactory = $__m.NullPipeFactory;
    }, function($__m) {
      BindingRecord = $__m.BindingRecord;
    }, function($__m) {
      DirectiveRecord = $__m.DirectiveRecord;
    }, function($__m) {
      DEFAULT = $__m.DEFAULT;
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      ProtoChangeDetector = $__m.ProtoChangeDetector;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      List = $__m.List;
    }],
    execute: function() {
      keyValDiff = [new KeyValueChangesFactory(), new NullPipeFactory()];
      $__export("keyValDiff", keyValDiff);
      iterableDiff = [new IterableChangesFactory(), new NullPipeFactory()];
      $__export("iterableDiff", iterableDiff);
      async = [new AsyncPipeFactory(), new NullPipeFactory()];
      $__export("async", async);
      defaultPipes = {
        "iterableDiff": iterableDiff,
        "keyValDiff": keyValDiff,
        "async": async
      };
      $__export("defaultPipes", defaultPipes);
      DynamicChangeDetection = (function($__super) {
        function DynamicChangeDetection(registry) {
          $traceurRuntime.superConstructor(DynamicChangeDetection).call(this);
          this.registry = registry;
        }
        return ($traceurRuntime.createClass)(DynamicChangeDetection, {createProtoChangeDetector: function(name, bindingRecords, variableBindings, directiveRecords) {
            var changeControlStrategy = arguments[4] !== (void 0) ? arguments[4] : DEFAULT;
            return new DynamicProtoChangeDetector(this.registry, bindingRecords, variableBindings, directiveRecords, changeControlStrategy);
          }}, {}, $__super);
      }(ChangeDetection));
      $__export("DynamicChangeDetection", DynamicChangeDetection);
      Object.defineProperty(DynamicChangeDetection, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(DynamicChangeDetection, "parameters", {get: function() {
          return [[PipeRegistry]];
        }});
      Object.defineProperty(DynamicChangeDetection.prototype.createProtoChangeDetector, "parameters", {get: function() {
          return [[assert.type.string], [assert.genericType(List, BindingRecord)], [assert.genericType(List, assert.type.string)], [assert.genericType(List, DirectiveRecord)], [assert.type.string]];
        }});
      JitChangeDetection = (function($__super) {
        function JitChangeDetection(registry) {
          $traceurRuntime.superConstructor(JitChangeDetection).call(this);
          this.registry = registry;
        }
        return ($traceurRuntime.createClass)(JitChangeDetection, {createProtoChangeDetector: function(name, bindingRecords, variableBindings, directiveRecords) {
            var changeControlStrategy = arguments[4] !== (void 0) ? arguments[4] : DEFAULT;
            return new JitProtoChangeDetector(this.registry, bindingRecords, variableBindings, directiveRecords, changeControlStrategy);
          }}, {}, $__super);
      }(ChangeDetection));
      $__export("JitChangeDetection", JitChangeDetection);
      Object.defineProperty(JitChangeDetection, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(JitChangeDetection, "parameters", {get: function() {
          return [[PipeRegistry]];
        }});
      Object.defineProperty(JitChangeDetection.prototype.createProtoChangeDetector, "parameters", {get: function() {
          return [[assert.type.string], [assert.genericType(List, BindingRecord)], [assert.genericType(List, assert.type.string)], [assert.genericType(List, DirectiveRecord)], [assert.type.string]];
        }});
      defaultPipeRegistry = new PipeRegistry(defaultPipes);
      $__export("defaultPipeRegistry", defaultPipeRegistry);
    }
  };
});

System.register("angular2/src/core/annotations/visibility", ["angular2/src/core/annotations_impl/visibility"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/visibility";
  return {
    setters: [function($__m) {
      $__export("AncestorAnnotation", $__m.Ancestor);
      $__export("ParentAnnotation", $__m.Parent);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/annotations/view", ["angular2/src/core/annotations_impl/view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/view";
  return {
    setters: [function($__m) {
      $__export("ViewAnnotation", $__m.View);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/dom/browser_adapter", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/dom/generic_browser_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/browser_adapter";
  var List,
      MapWrapper,
      ListWrapper,
      isBlank,
      isPresent,
      setRootDomAdapter,
      GenericBrowserDomAdapter,
      _attrToPropMap,
      DOM_KEY_LOCATION_NUMPAD,
      _keyMap,
      _chromeNumKeyPadMap,
      BrowserDomAdapter;
  return {
    setters: [function($__m) {
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      setRootDomAdapter = $__m.setRootDomAdapter;
    }, function($__m) {
      GenericBrowserDomAdapter = $__m.GenericBrowserDomAdapter;
    }],
    execute: function() {
      _attrToPropMap = {
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex'
      };
      DOM_KEY_LOCATION_NUMPAD = 3;
      _keyMap = {
        '\b': 'Backspace',
        '\t': 'Tab',
        '\x7F': 'Delete',
        '\x1B': 'Escape',
        'Del': 'Delete',
        'Esc': 'Escape',
        'Left': 'ArrowLeft',
        'Right': 'ArrowRight',
        'Up': 'ArrowUp',
        'Down': 'ArrowDown',
        'Menu': 'ContextMenu',
        'Scroll': 'ScrollLock',
        'Win': 'OS'
      };
      _chromeNumKeyPadMap = {
        'A': '1',
        'B': '2',
        'C': '3',
        'D': '4',
        'E': '5',
        'F': '6',
        'G': '7',
        'H': '8',
        'I': '9',
        'J': '*',
        'K': '+',
        'M': '-',
        'N': '.',
        'O': '/',
        '\x60': '0',
        '\x90': 'NumLock'
      };
      BrowserDomAdapter = (function($__super) {
        function BrowserDomAdapter() {
          $traceurRuntime.superConstructor(BrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(BrowserDomAdapter, {
          logError: function(error) {
            window.console.error(error);
          },
          get attrToPropMap() {
            return _attrToPropMap;
          },
          query: function(selector) {
            return document.querySelector(selector);
          },
          querySelector: function(el, selector) {
            return el.querySelector(selector);
          },
          querySelectorAll: function(el, selector) {
            return el.querySelectorAll(selector);
          },
          on: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
          },
          onAndCancel: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
            return (function() {
              el.removeEventListener(evt, listener, false);
            });
          },
          dispatchEvent: function(el, evt) {
            el.dispatchEvent(evt);
          },
          createMouseEvent: function(eventType) {
            var evt = new MouseEvent(eventType);
            evt.initEvent(eventType, true, true);
            return evt;
          },
          createEvent: function(eventType) {
            return new Event(eventType, true);
          },
          getInnerHTML: function(el) {
            return el.innerHTML;
          },
          getOuterHTML: function(el) {
            return el.outerHTML;
          },
          nodeName: function(node) {
            return node.nodeName;
          },
          nodeValue: function(node) {
            return node.nodeValue;
          },
          type: function(node) {
            return node.type;
          },
          content: function(node) {
            if (this.hasProperty(node, "content")) {
              return node.content;
            } else {
              return node;
            }
          },
          firstChild: function(el) {
            return el.firstChild;
          },
          nextSibling: function(el) {
            return el.nextSibling;
          },
          parentElement: function(el) {
            return el.parentElement;
          },
          childNodes: function(el) {
            return el.childNodes;
          },
          childNodesAsList: function(el) {
            var childNodes = el.childNodes;
            var res = ListWrapper.createFixedSize(childNodes.length);
            for (var i = 0; i < childNodes.length; i++) {
              res[i] = childNodes[i];
            }
            return res;
          },
          clearNodes: function(el) {
            for (var i = 0; i < el.childNodes.length; i++) {
              this.remove(el.childNodes[i]);
            }
          },
          appendChild: function(el, node) {
            el.appendChild(node);
          },
          removeChild: function(el, node) {
            el.removeChild(node);
          },
          replaceChild: function(el, newChild, oldChild) {
            el.replaceChild(newChild, oldChild);
          },
          remove: function(el) {
            var parent = el.parentNode;
            parent.removeChild(el);
            return el;
          },
          insertBefore: function(el, node) {
            el.parentNode.insertBefore(node, el);
          },
          insertAllBefore: function(el, nodes) {
            ListWrapper.forEach(nodes, (function(n) {
              el.parentNode.insertBefore(n, el);
            }));
          },
          insertAfter: function(el, node) {
            el.parentNode.insertBefore(node, el.nextSibling);
          },
          setInnerHTML: function(el, value) {
            el.innerHTML = value;
          },
          getText: function(el) {
            return el.textContent;
          },
          setText: function(el, value) {
            el.textContent = value;
          },
          getValue: function(el) {
            return el.value;
          },
          setValue: function(el, value) {
            el.value = value;
          },
          getChecked: function(el) {
            return el.checked;
          },
          setChecked: function(el, value) {
            el.checked = value;
          },
          createTemplate: function(html) {
            var t = document.createElement('template');
            t.innerHTML = html;
            return t;
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createElement(tagName);
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createTextNode(text);
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : document;
            var el = doc.createElement('SCRIPT');
            el.setAttribute(attrName, attrValue);
            return el;
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            var style = doc.createElement('STYLE');
            style.innerText = css;
            return style;
          },
          createShadowRoot: function(el) {
            return el.createShadowRoot();
          },
          getShadowRoot: function(el) {
            return el.shadowRoot;
          },
          getHost: function(el) {
            return el.host;
          },
          clone: function(node) {
            return node.cloneNode(true);
          },
          hasProperty: function(element, name) {
            return name in element;
          },
          getElementsByClassName: function(element, name) {
            return element.getElementsByClassName(name);
          },
          getElementsByTagName: function(element, name) {
            return element.getElementsByTagName(name);
          },
          classList: function(element) {
            return Array.prototype.slice.call(element.classList, 0);
          },
          addClass: function(element, classname) {
            element.classList.add(classname);
          },
          removeClass: function(element, classname) {
            element.classList.remove(classname);
          },
          hasClass: function(element, classname) {
            return element.classList.contains(classname);
          },
          setStyle: function(element, stylename, stylevalue) {
            element.style[stylename] = stylevalue;
          },
          removeStyle: function(element, stylename) {
            element.style[stylename] = null;
          },
          getStyle: function(element, stylename) {
            return element.style[stylename];
          },
          tagName: function(element) {
            return element.tagName;
          },
          attributeMap: function(element) {
            var res = MapWrapper.create();
            var elAttrs = element.attributes;
            for (var i = 0; i < elAttrs.length; i++) {
              var attrib = elAttrs[i];
              MapWrapper.set(res, attrib.name, attrib.value);
            }
            return res;
          },
          getAttribute: function(element, attribute) {
            return element.getAttribute(attribute);
          },
          setAttribute: function(element, name, value) {
            element.setAttribute(name, value);
          },
          removeAttribute: function(element, attribute) {
            return element.removeAttribute(attribute);
          },
          templateAwareRoot: function(el) {
            return this.isTemplateElement(el) ? this.content(el) : el;
          },
          createHtmlDocument: function() {
            return document.implementation.createHTMLDocument('fakeTitle');
          },
          defaultDoc: function() {
            return document;
          },
          getBoundingClientRect: function(el) {
            return el.getBoundingClientRect();
          },
          getTitle: function() {
            return document.title;
          },
          setTitle: function(newTitle) {
            document.title = newTitle;
          },
          elementMatches: function(n, selector) {
            return n instanceof HTMLElement && n.matches(selector);
          },
          isTemplateElement: function(el) {
            return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
          },
          isTextNode: function(node) {
            return node.nodeType === Node.TEXT_NODE;
          },
          isCommentNode: function(node) {
            return node.nodeType === Node.COMMENT_NODE;
          },
          isElementNode: function(node) {
            return node.nodeType === Node.ELEMENT_NODE;
          },
          hasShadowRoot: function(node) {
            return node instanceof HTMLElement && isPresent(node.shadowRoot);
          },
          isShadowRoot: function(node) {
            return node instanceof ShadowRoot;
          },
          importIntoDoc: function(node) {
            var result = document.importNode(node, true);
            if (this.isTemplateElement(result) && !this.content(result).childNodes.length && this.content(node).childNodes.length) {
              var childNodes = this.content(node).childNodes;
              for (var i = 0; i < childNodes.length; ++i) {
                this.content(result).appendChild(this.importIntoDoc(childNodes[i]));
              }
            }
            return result;
          },
          isPageRule: function(rule) {
            return rule.type === CSSRule.PAGE_RULE;
          },
          isStyleRule: function(rule) {
            return rule.type === CSSRule.STYLE_RULE;
          },
          isMediaRule: function(rule) {
            return rule.type === CSSRule.MEDIA_RULE;
          },
          isKeyframesRule: function(rule) {
            return rule.type === CSSRule.KEYFRAMES_RULE;
          },
          getHref: function(el) {
            return el.href;
          },
          getEventKey: function(event) {
            var key = event.key;
            if (isBlank(key)) {
              key = event.keyIdentifier;
              if (isBlank(key)) {
                return 'Unidentified';
              }
              if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                  key = _chromeNumKeyPadMap[key];
                }
              }
            }
            if (_keyMap.hasOwnProperty(key)) {
              key = _keyMap[key];
            }
            return key;
          },
          getGlobalEventTarget: function(target) {
            if (target == "window") {
              return window;
            } else if (target == "document") {
              return document;
            } else if (target == "body") {
              return document.body;
            }
          }
        }, {makeCurrent: function() {
            setRootDomAdapter(new BrowserDomAdapter());
          }}, $__super);
      }(GenericBrowserDomAdapter));
      $__export("BrowserDomAdapter", BrowserDomAdapter);
      Object.defineProperty(BrowserDomAdapter.prototype.query, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.querySelector, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.querySelectorAll, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.nodeName, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.nodeValue, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.type, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.content, "parameters", {get: function() {
          return [[HTMLElement]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.replaceChild, "parameters", {get: function() {
          return [[Node], [], []];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setText, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setValue, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setChecked, "parameters", {get: function() {
          return [[], [assert.type.boolean]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.createTextNode, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.createScriptTag, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.createStyleElement, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.createShadowRoot, "parameters", {get: function() {
          return [[HTMLElement]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getShadowRoot, "parameters", {get: function() {
          return [[HTMLElement]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getHost, "parameters", {get: function() {
          return [[HTMLElement]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.clone, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.hasProperty, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getElementsByClassName, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getElementsByTagName, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.addClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.removeClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.hasClass, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setStyle, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.removeStyle, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getStyle, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getAttribute, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setAttribute, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.removeAttribute, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.setTitle, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.elementMatches, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.isTemplateElement, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.isTextNode, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.isCommentNode, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.isElementNode, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.importIntoDoc, "parameters", {get: function() {
          return [[Node]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getHref, "parameters", {get: function() {
          return [[Element]];
        }});
      Object.defineProperty(BrowserDomAdapter.prototype.getGlobalEventTarget, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/directive_metadata_reader", ["angular2/di", "angular2/src/facade/lang", "angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/directive_metadata", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_metadata_reader";
  var Injectable,
      Injector,
      Type,
      isPresent,
      BaseException,
      stringify,
      Directive,
      Component,
      DirectiveMetadata,
      reflector,
      DirectiveMetadataReader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
      Injector = $__m.Injector;
    }, function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      Directive = $__m.Directive;
      Component = $__m.Component;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      DirectiveMetadataReader = (function() {
        function DirectiveMetadataReader() {}
        return ($traceurRuntime.createClass)(DirectiveMetadataReader, {read: function(type) {
            var annotations = reflector.annotations(type);
            if (isPresent(annotations)) {
              for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                if (annotation instanceof Directive) {
                  var resolvedInjectables = null;
                  if (annotation instanceof Component && isPresent(annotation.injectables)) {
                    resolvedInjectables = Injector.resolve(annotation.injectables);
                  }
                  return new DirectiveMetadata(type, annotation, resolvedInjectables);
                }
              }
            }
            throw new BaseException(("No Directive annotation found on " + stringify(type)));
          }}, {});
      }());
      $__export("DirectiveMetadataReader", DirectiveMetadataReader);
      Object.defineProperty(DirectiveMetadataReader, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(DirectiveMetadataReader.prototype.read, "parameters", {get: function() {
          return [[Type]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/view_ref", ["angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_ref";
  var isPresent,
      viewModule,
      RenderViewRef,
      ViewRef,
      ProtoViewRef;
  function internalView(viewRef) {
    return viewRef._view;
  }
  function internalProtoView(protoViewRef) {
    return isPresent(protoViewRef) ? protoViewRef._protoView : null;
  }
  $__export("internalView", internalView);
  $__export("internalProtoView", internalProtoView);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      RenderViewRef = $__m.RenderViewRef;
    }],
    execute: function() {
      Object.defineProperty(internalView, "parameters", {get: function() {
          return [[ViewRef]];
        }});
      Object.defineProperty(internalProtoView, "parameters", {get: function() {
          return [[ProtoViewRef]];
        }});
      ViewRef = (function() {
        function ViewRef(view) {
          this._view = view;
        }
        return ($traceurRuntime.createClass)(ViewRef, {
          get render() {
            return this._view.render;
          },
          setLocal: function(contextName, value) {
            this._view.setLocal(contextName, value);
          }
        }, {});
      }());
      $__export("ViewRef", ViewRef);
      Object.defineProperty(ViewRef, "parameters", {get: function() {
          return [[viewModule.AppView]];
        }});
      Object.defineProperty(ViewRef.prototype.setLocal, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any]];
        }});
      ProtoViewRef = (function() {
        function ProtoViewRef(protoView) {
          this._protoView = protoView;
        }
        return ($traceurRuntime.createClass)(ProtoViewRef, {}, {});
      }());
      $__export("ProtoViewRef", ProtoViewRef);
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/render/dom/view/element_binder", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view";
  var isPresent,
      DOM,
      List,
      Map,
      ListWrapper,
      MapWrapper,
      ElementBinder,
      NG_BINDING_CLASS,
      RenderProtoView;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      List = $__m.List;
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      ElementBinder = $__m.ElementBinder;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
    }],
    execute: function() {
      RenderProtoView = (function() {
        function RenderProtoView($__1) {
          var $__2 = $__1,
              elementBinders = $__2.elementBinders,
              element = $__2.element,
              imperativeRendererId = $__2.imperativeRendererId;
          this.element = element;
          this.elementBinders = elementBinders;
          this.imperativeRendererId = imperativeRendererId;
          if (isPresent(imperativeRendererId)) {
            this.rootBindingOffset = 0;
            this.isTemplateElement = false;
          } else {
            this.isTemplateElement = DOM.isTemplateElement(this.element);
            this.rootBindingOffset = (isPresent(this.element) && DOM.hasClass(this.element, NG_BINDING_CLASS)) ? 1 : 0;
          }
        }
        return ($traceurRuntime.createClass)(RenderProtoView, {mergeChildComponentProtoViews: function(componentProtoViews) {
            var componentProtoViewIndex = 0;
            for (var i = 0; i < this.elementBinders.length; i++) {
              var eb = this.elementBinders[i];
              if (isPresent(eb.componentId)) {
                eb.nestedProtoView = componentProtoViews[componentProtoViewIndex];
                componentProtoViewIndex++;
              }
            }
          }}, {});
      }());
      $__export("RenderProtoView", RenderProtoView);
      Object.defineProperty(RenderProtoView.prototype.mergeChildComponentProtoViews, "parameters", {get: function() {
          return [[assert.genericType(List, RenderProtoView)]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/light_dom", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/render/dom/view/view", "angular2/src/render/dom/shadow_dom/content_tag"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/light_dom";
  var DOM,
      List,
      ListWrapper,
      isBlank,
      isPresent,
      viewModule,
      Content,
      DestinationLightDom,
      _Root,
      LightDom;
  function redistributeNodes(contents, nodes) {
    for (var i = 0; i < contents.length; ++i) {
      var content = contents[i];
      var select = content.select;
      if (select.length === 0) {
        content.insert(ListWrapper.clone(nodes));
        ListWrapper.clear(nodes);
      } else {
        var matchSelector = (function(n) {
          return DOM.elementMatches(n, select);
        });
        var matchingNodes = ListWrapper.filter(nodes, matchSelector);
        content.insert(matchingNodes);
        ListWrapper.removeAll(nodes, matchingNodes);
      }
    }
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (isPresent(node.parentNode)) {
        DOM.remove(nodes[i]);
      }
    }
  }
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      Content = $__m.Content;
    }],
    execute: function() {
      DestinationLightDom = (function() {
        function DestinationLightDom() {}
        return ($traceurRuntime.createClass)(DestinationLightDom, {}, {});
      }());
      $__export("DestinationLightDom", DestinationLightDom);
      _Root = (function() {
        function _Root(node, boundElementIndex) {
          this.node = node;
          this.boundElementIndex = boundElementIndex;
        }
        return ($traceurRuntime.createClass)(_Root, {}, {});
      }());
      LightDom = (function() {
        function LightDom(lightDomView, shadowDomView, element) {
          this.lightDomView = lightDomView;
          this.shadowDomView = shadowDomView;
          this.nodes = DOM.childNodesAsList(element);
          this.roots = null;
        }
        return ($traceurRuntime.createClass)(LightDom, {
          redistribute: function() {
            redistributeNodes(this.contentTags(), this.expandedDomNodes());
          },
          contentTags: function() {
            return this._collectAllContentTags(this.shadowDomView, []);
          },
          _collectAllContentTags: function(view, acc) {
            var $__0 = this;
            var contentTags = view.contentTags;
            var vcs = view.viewContainers;
            for (var i = 0; i < vcs.length; i++) {
              var vc = vcs[i];
              var contentTag = contentTags[i];
              if (isPresent(contentTag)) {
                ListWrapper.push(acc, contentTag);
              }
              if (isPresent(vc)) {
                ListWrapper.forEach(vc.contentTagContainers(), (function(view) {
                  $__0._collectAllContentTags(view, acc);
                }));
              }
            }
            return acc;
          },
          expandedDomNodes: function() {
            var res = [];
            var roots = this._roots();
            for (var i = 0; i < roots.length; ++i) {
              var root = roots[i];
              if (isPresent(root.boundElementIndex)) {
                var vc = this.lightDomView.viewContainers[root.boundElementIndex];
                var content = this.lightDomView.contentTags[root.boundElementIndex];
                if (isPresent(vc)) {
                  res = ListWrapper.concat(res, vc.nodes());
                } else if (isPresent(content)) {
                  res = ListWrapper.concat(res, content.nodes());
                } else {
                  ListWrapper.push(res, root.node);
                }
              } else {
                ListWrapper.push(res, root.node);
              }
            }
            return res;
          },
          _roots: function() {
            if (isPresent(this.roots))
              return this.roots;
            var boundElements = this.lightDomView.boundElements;
            this.roots = ListWrapper.map(this.nodes, (function(n) {
              var boundElementIndex = null;
              for (var i = 0; i < boundElements.length; i++) {
                var boundEl = boundElements[i];
                if (isPresent(boundEl) && boundEl === n) {
                  boundElementIndex = i;
                  break;
                }
              }
              return new _Root(n, boundElementIndex);
            }));
            return this.roots;
          }
        }, {});
      }());
      $__export("LightDom", LightDom);
      Object.defineProperty(LightDom, "parameters", {get: function() {
          return [[viewModule.RenderView], [viewModule.RenderView], []];
        }});
      Object.defineProperty(LightDom.prototype._collectAllContentTags, "parameters", {get: function() {
          return [[viewModule.RenderView], [assert.genericType(List, Content)]];
        }});
      Object.defineProperty(redistributeNodes, "parameters", {get: function() {
          return [[assert.genericType(List, Content)], [List]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/events/event_manager", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/core/zone/vm_turn_zone"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/event_manager";
  var isBlank,
      BaseException,
      isPresent,
      StringWrapper,
      DOM,
      List,
      ListWrapper,
      MapWrapper,
      VmTurnZone,
      BUBBLE_SYMBOL,
      EventManager,
      EventManagerPlugin,
      DomEventsPlugin;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      VmTurnZone = $__m.VmTurnZone;
    }],
    execute: function() {
      BUBBLE_SYMBOL = '^';
      EventManager = (function() {
        function EventManager(plugins, zone) {
          this._zone = zone;
          this._plugins = plugins;
          for (var i = 0; i < plugins.length; i++) {
            plugins[i].manager = this;
          }
        }
        return ($traceurRuntime.createClass)(EventManager, {
          addEventListener: function(element, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            plugin.addEventListener(element, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          addGlobalEventListener: function(target, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            return plugin.addGlobalEventListener(target, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          getZone: function() {
            return this._zone;
          },
          _findPluginFor: function(eventName) {
            var plugins = this._plugins;
            for (var i = 0; i < plugins.length; i++) {
              var plugin = plugins[i];
              if (plugin.supports(eventName)) {
                return plugin;
              }
            }
            throw new BaseException(("No event manager plugin found for event " + eventName));
          },
          _removeBubbleSymbol: function(eventName) {
            return eventName[0] == BUBBLE_SYMBOL ? StringWrapper.substring(eventName, 1) : eventName;
          }
        }, {});
      }());
      $__export("EventManager", EventManager);
      Object.defineProperty(EventManager, "parameters", {get: function() {
          return [[assert.genericType(List, EventManagerPlugin)], [VmTurnZone]];
        }});
      Object.defineProperty(EventManager.prototype.addEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function]];
        }});
      Object.defineProperty(EventManager.prototype.addGlobalEventListener, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [Function]];
        }});
      Object.defineProperty(EventManager.prototype._findPluginFor, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(EventManager.prototype._removeBubbleSymbol, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      EventManagerPlugin = (function() {
        function EventManagerPlugin() {}
        return ($traceurRuntime.createClass)(EventManagerPlugin, {
          supports: function(eventName) {
            return false;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          },
          addGlobalEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          }
        }, {});
      }());
      $__export("EventManagerPlugin", EventManagerPlugin);
      Object.defineProperty(EventManagerPlugin.prototype.supports, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(EventManagerPlugin.prototype.addEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function], [assert.type.boolean]];
        }});
      Object.defineProperty(EventManagerPlugin.prototype.addGlobalEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function], [assert.type.boolean]];
        }});
      DomEventsPlugin = (function($__super) {
        function DomEventsPlugin() {
          $traceurRuntime.superConstructor(DomEventsPlugin).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(DomEventsPlugin, {
          supports: function(eventName) {
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            this.manager._zone.runOutsideAngular((function() {
              DOM.on(element, eventName, outsideHandler);
            }));
          },
          addGlobalEventListener: function(target, eventName, handler, shouldSupportBubble) {
            var element = DOM.getGlobalEventTarget(target);
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            return this.manager._zone.runOutsideAngular((function() {
              return DOM.onAndCancel(element, eventName, outsideHandler);
            }));
          },
          _getOutsideHandler: function(shouldSupportBubble, element, handler, zone) {
            return shouldSupportBubble ? DomEventsPlugin.bubbleCallback(element, handler, zone) : DomEventsPlugin.sameElementCallback(element, handler, zone);
          }
        }, {
          sameElementCallback: function(element, handler, zone) {
            return (function(event) {
              if (event.target === element) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          },
          bubbleCallback: function(element, handler, zone) {
            return (function(event) {
              return zone.run((function() {
                return handler(event);
              }));
            });
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("DomEventsPlugin", DomEventsPlugin);
      Object.defineProperty(DomEventsPlugin.prototype.supports, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(DomEventsPlugin.prototype.addEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function], [assert.type.boolean]];
        }});
      Object.defineProperty(DomEventsPlugin.prototype.addGlobalEventListener, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], [Function], [assert.type.boolean]];
        }});
      Object.defineProperty(DomEventsPlugin.prototype._getOutsideHandler, "parameters", {get: function() {
          return [[assert.type.boolean], [], [Function], [VmTurnZone]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view_builder", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/change_detection", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/element_binder", "angular2/src/render/dom/view/property_setter_factory", "angular2/src/render/api", "angular2/src/render/dom/direct_dom_renderer", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view_builder";
  var isPresent,
      isBlank,
      BaseException,
      ListWrapper,
      MapWrapper,
      Set,
      SetWrapper,
      List,
      DOM,
      ASTWithSource,
      AST,
      AstTransformer,
      AccessMember,
      LiteralArray,
      ImplicitReceiver,
      RenderProtoView,
      ElementBinder,
      Event,
      setterFactory,
      api,
      directDomRenderer,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      ProtoViewBuilder,
      ElementBinderBuilder,
      DirectiveBuilder,
      EventBuilder;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Set = $__m.Set;
      SetWrapper = $__m.SetWrapper;
      List = $__m.List;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ASTWithSource = $__m.ASTWithSource;
      AST = $__m.AST;
      AstTransformer = $__m.AstTransformer;
      AccessMember = $__m.AccessMember;
      LiteralArray = $__m.LiteralArray;
      ImplicitReceiver = $__m.ImplicitReceiver;
    }, function($__m) {
      RenderProtoView = $__m.RenderProtoView;
    }, function($__m) {
      ElementBinder = $__m.ElementBinder;
      Event = $__m.Event;
    }, function($__m) {
      setterFactory = $__m.setterFactory;
    }, function($__m) {
      api = $__m;
    }, function($__m) {
      directDomRenderer = $__m;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
      EVENT_TARGET_SEPARATOR = $__m.EVENT_TARGET_SEPARATOR;
    }],
    execute: function() {
      ProtoViewBuilder = (function() {
        function ProtoViewBuilder(rootElement) {
          this.rootElement = rootElement;
          this.elements = [];
          this.variableBindings = MapWrapper.create();
          this.imperativeRendererId = null;
        }
        return ($traceurRuntime.createClass)(ProtoViewBuilder, {
          setImperativeRendererId: function(id) {
            this.imperativeRendererId = id;
            return this;
          },
          bindElement: function(element) {
            var description = arguments[1] !== (void 0) ? arguments[1] : null;
            var builder = new ElementBinderBuilder(this.elements.length, element, description);
            ListWrapper.push(this.elements, builder);
            DOM.addClass(element, NG_BINDING_CLASS);
            return builder;
          },
          bindVariable: function(name, value) {
            MapWrapper.set(this.variableBindings, value, name);
          },
          build: function() {
            var renderElementBinders = [];
            var apiElementBinders = [];
            ListWrapper.forEach(this.elements, (function(ebb) {
              var propertySetters = MapWrapper.create();
              var apiDirectiveBinders = ListWrapper.map(ebb.directives, (function(dbb) {
                ebb.eventBuilder.merge(dbb.eventBuilder);
                MapWrapper.forEach(dbb.hostPropertyBindings, (function(_, hostPropertyName) {
                  MapWrapper.set(propertySetters, hostPropertyName, setterFactory(hostPropertyName));
                }));
                return new api.DirectiveBinder({
                  directiveIndex: dbb.directiveIndex,
                  propertyBindings: dbb.propertyBindings,
                  eventBindings: dbb.eventBindings,
                  hostPropertyBindings: dbb.hostPropertyBindings
                });
              }));
              MapWrapper.forEach(ebb.propertyBindings, (function(_, propertyName) {
                MapWrapper.set(propertySetters, propertyName, setterFactory(propertyName));
              }));
              var nestedProtoView = isPresent(ebb.nestedProtoView) ? ebb.nestedProtoView.build() : null;
              var parentIndex = isPresent(ebb.parent) ? ebb.parent.index : -1;
              ListWrapper.push(apiElementBinders, new api.ElementBinder({
                index: ebb.index,
                parentIndex: parentIndex,
                distanceToParent: ebb.distanceToParent,
                directives: apiDirectiveBinders,
                nestedProtoView: nestedProtoView,
                propertyBindings: ebb.propertyBindings,
                variableBindings: ebb.variableBindings,
                eventBindings: ebb.eventBindings,
                textBindings: ebb.textBindings,
                readAttributes: ebb.readAttributes
              }));
              ListWrapper.push(renderElementBinders, new ElementBinder({
                textNodeIndices: ebb.textBindingIndices,
                contentTagSelector: ebb.contentTagSelector,
                parentIndex: parentIndex,
                distanceToParent: ebb.distanceToParent,
                nestedProtoView: isPresent(nestedProtoView) ? nestedProtoView.render.delegate : null,
                componentId: ebb.componentId,
                eventLocals: new LiteralArray(ebb.eventBuilder.buildEventLocals()),
                localEvents: ebb.eventBuilder.buildLocalEvents(),
                globalEvents: ebb.eventBuilder.buildGlobalEvents(),
                propertySetters: propertySetters
              }));
            }));
            return new api.ProtoViewDto({
              render: new directDomRenderer.DirectDomProtoViewRef(new RenderProtoView({
                element: this.rootElement,
                elementBinders: renderElementBinders,
                imperativeRendererId: this.imperativeRendererId
              })),
              elementBinders: apiElementBinders,
              variableBindings: this.variableBindings
            });
          }
        }, {});
      }());
      $__export("ProtoViewBuilder", ProtoViewBuilder);
      Object.defineProperty(ProtoViewBuilder.prototype.setImperativeRendererId, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      ElementBinderBuilder = (function() {
        function ElementBinderBuilder(index, element, description) {
          this.element = element;
          this.index = index;
          this.parent = null;
          this.distanceToParent = 0;
          this.directives = [];
          this.nestedProtoView = null;
          this.propertyBindings = MapWrapper.create();
          this.variableBindings = MapWrapper.create();
          this.eventBindings = ListWrapper.create();
          this.eventBuilder = new EventBuilder();
          this.textBindings = [];
          this.textBindingIndices = [];
          this.contentTagSelector = null;
          this.componentId = null;
          this.readAttributes = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(ElementBinderBuilder, {
          setParent: function(parent, distanceToParent) {
            this.parent = parent;
            if (isPresent(parent)) {
              this.distanceToParent = distanceToParent;
            }
            return this;
          },
          readAttribute: function(attrName) {
            if (isBlank(MapWrapper.get(this.readAttributes, attrName))) {
              MapWrapper.set(this.readAttributes, attrName, DOM.getAttribute(this.element, attrName));
            }
          },
          bindDirective: function(directiveIndex) {
            var directive = new DirectiveBuilder(directiveIndex);
            ListWrapper.push(this.directives, directive);
            return directive;
          },
          bindNestedProtoView: function(rootElement) {
            if (isPresent(this.nestedProtoView)) {
              throw new BaseException('Only one nested view per element is allowed');
            }
            this.nestedProtoView = new ProtoViewBuilder(rootElement);
            return this.nestedProtoView;
          },
          bindProperty: function(name, expression) {
            MapWrapper.set(this.propertyBindings, name, expression);
            setterFactory(name);
          },
          bindVariable: function(name, value) {
            if (isPresent(this.nestedProtoView)) {
              this.nestedProtoView.bindVariable(name, value);
            } else {
              MapWrapper.set(this.variableBindings, value, name);
            }
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            ListWrapper.push(this.eventBindings, this.eventBuilder.add(name, expression, target));
          },
          bindText: function(index, expression) {
            ListWrapper.push(this.textBindingIndices, index);
            ListWrapper.push(this.textBindings, expression);
          },
          setContentTagSelector: function(value) {
            this.contentTagSelector = value;
          },
          setComponentId: function(componentId) {
            this.componentId = componentId;
          }
        }, {});
      }());
      $__export("ElementBinderBuilder", ElementBinderBuilder);
      Object.defineProperty(ElementBinderBuilder.prototype.setParent, "parameters", {get: function() {
          return [[ElementBinderBuilder], []];
        }});
      Object.defineProperty(ElementBinderBuilder.prototype.readAttribute, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ElementBinderBuilder.prototype.bindDirective, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ElementBinderBuilder.prototype.setContentTagSelector, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ElementBinderBuilder.prototype.setComponentId, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      DirectiveBuilder = (function() {
        function DirectiveBuilder(directiveIndex) {
          this.directiveIndex = directiveIndex;
          this.propertyBindings = MapWrapper.create();
          this.hostPropertyBindings = MapWrapper.create();
          this.eventBindings = ListWrapper.create();
          this.eventBuilder = new EventBuilder();
        }
        return ($traceurRuntime.createClass)(DirectiveBuilder, {
          bindProperty: function(name, expression) {
            MapWrapper.set(this.propertyBindings, name, expression);
          },
          bindHostProperty: function(name, expression) {
            MapWrapper.set(this.hostPropertyBindings, name, expression);
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            ListWrapper.push(this.eventBindings, this.eventBuilder.add(name, expression, target));
          }
        }, {});
      }());
      $__export("DirectiveBuilder", DirectiveBuilder);
      EventBuilder = (function($__super) {
        function EventBuilder() {
          $traceurRuntime.superConstructor(EventBuilder).call(this);
          this.locals = [];
          this.localEvents = [];
          this.globalEvents = [];
          this._implicitReceiver = new ImplicitReceiver();
        }
        return ($traceurRuntime.createClass)(EventBuilder, {
          add: function(name, source, target) {
            var adjustedAst = source.ast;
            var fullName = isPresent(target) ? target + EVENT_TARGET_SEPARATOR + name : name;
            var result = new api.EventBinding(fullName, new ASTWithSource(adjustedAst, source.source, source.location));
            var event = new Event(name, target, fullName);
            if (isBlank(target)) {
              ListWrapper.push(this.localEvents, event);
            } else {
              ListWrapper.push(this.globalEvents, event);
            }
            return result;
          },
          visitAccessMember: function(ast) {
            var isEventAccess = false;
            var current = ast;
            while (!isEventAccess && (current instanceof AccessMember)) {
              if (current.name == '$event') {
                isEventAccess = true;
              }
              current = current.receiver;
            }
            if (isEventAccess) {
              ListWrapper.push(this.locals, ast);
              var index = this.locals.length - 1;
              return new AccessMember(this._implicitReceiver, ("" + index), (function(arr) {
                return arr[index];
              }), null);
            } else {
              return ast;
            }
          },
          buildEventLocals: function() {
            return this.locals;
          },
          buildLocalEvents: function() {
            return this.localEvents;
          },
          buildGlobalEvents: function() {
            return this.globalEvents;
          },
          merge: function(eventBuilder) {
            this._merge(this.localEvents, eventBuilder.localEvents);
            this._merge(this.globalEvents, eventBuilder.globalEvents);
            ListWrapper.concat(this.locals, eventBuilder.locals);
          },
          _merge: function(host, tobeAdded) {
            var names = ListWrapper.create();
            for (var i = 0; i < host.length; i++) {
              ListWrapper.push(names, host[i].fullName);
            }
            for (var j = 0; j < tobeAdded.length; j++) {
              if (!ListWrapper.contains(names, tobeAdded[j].fullName)) {
                ListWrapper.push(host, tobeAdded[j]);
              }
            }
          }
        }, {}, $__super);
      }(AstTransformer));
      $__export("EventBuilder", EventBuilder);
      Object.defineProperty(EventBuilder.prototype.add, "parameters", {get: function() {
          return [[assert.type.string], [ASTWithSource], [assert.type.string]];
        }});
      Object.defineProperty(EventBuilder.prototype.visitAccessMember, "parameters", {get: function() {
          return [[AccessMember]];
        }});
      Object.defineProperty(EventBuilder.prototype.merge, "parameters", {get: function() {
          return [[EventBuilder]];
        }});
      Object.defineProperty(EventBuilder.prototype._merge, "parameters", {get: function() {
          return [[assert.genericType(List, Event)], [assert.genericType(List, Event)]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_control", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_step"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_control";
  var isBlank,
      List,
      ListWrapper,
      CompileElement,
      CompileStep,
      CompileControl;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }],
    execute: function() {
      CompileControl = (function() {
        function CompileControl(steps) {
          this._steps = steps;
          this._currentStepIndex = 0;
          this._parent = null;
          this._results = null;
          this._additionalChildren = null;
        }
        return ($traceurRuntime.createClass)(CompileControl, {
          internalProcess: function(results, startStepIndex, parent, current) {
            this._results = results;
            var previousStepIndex = this._currentStepIndex;
            var previousParent = this._parent;
            this._ignoreCurrentElement = false;
            for (var i = startStepIndex; i < this._steps.length && !this._ignoreCurrentElement; i++) {
              var step = this._steps[i];
              this._parent = parent;
              this._currentStepIndex = i;
              step.process(parent, current, this);
              parent = this._parent;
            }
            if (!this._ignoreCurrentElement) {
              ListWrapper.push(results, current);
            }
            this._currentStepIndex = previousStepIndex;
            this._parent = previousParent;
            var localAdditionalChildren = this._additionalChildren;
            this._additionalChildren = null;
            return localAdditionalChildren;
          },
          addParent: function(newElement) {
            this.internalProcess(this._results, this._currentStepIndex + 1, this._parent, newElement);
            this._parent = newElement;
          },
          addChild: function(element) {
            if (isBlank(this._additionalChildren)) {
              this._additionalChildren = ListWrapper.create();
            }
            ListWrapper.push(this._additionalChildren, element);
          },
          ignoreCurrentElement: function() {
            this._ignoreCurrentElement = true;
          }
        }, {});
      }());
      $__export("CompileControl", CompileControl);
      Object.defineProperty(CompileControl.prototype.internalProcess, "parameters", {get: function() {
          return [[], [], [CompileElement], [CompileElement]];
        }});
      Object.defineProperty(CompileControl.prototype.addParent, "parameters", {get: function() {
          return [[CompileElement]];
        }});
      Object.defineProperty(CompileControl.prototype.addChild, "parameters", {get: function() {
          return [[CompileElement]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/template_loader", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/services/xhr", "angular2/src/render/api", "angular2/src/services/url_resolver"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/template_loader";
  var Injectable,
      isBlank,
      isPresent,
      BaseException,
      stringify,
      Map,
      MapWrapper,
      StringMapWrapper,
      StringMap,
      PromiseWrapper,
      Promise,
      DOM,
      XHR,
      ViewDefinition,
      UrlResolver,
      TemplateLoader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
      StringMap = $__m.StringMap;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      Promise = $__m.Promise;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }],
    execute: function() {
      TemplateLoader = (function() {
        function TemplateLoader(xhr, urlResolver) {
          this._xhr = xhr;
          this._htmlCache = StringMapWrapper.create();
        }
        return ($traceurRuntime.createClass)(TemplateLoader, {load: function(template) {
            if (isPresent(template.template)) {
              return PromiseWrapper.resolve(DOM.createTemplate(template.template));
            }
            var url = template.absUrl;
            if (isPresent(url)) {
              var promise = StringMapWrapper.get(this._htmlCache, url);
              if (isBlank(promise)) {
                promise = this._xhr.get(url).then(function(html) {
                  var template = DOM.createTemplate(html);
                  return template;
                });
                StringMapWrapper.set(this._htmlCache, url, promise);
              }
              return promise.then((function(tplElement) {
                return DOM.clone(tplElement);
              }));
            }
            throw new BaseException('View should have either the url or template property set');
          }}, {});
      }());
      $__export("TemplateLoader", TemplateLoader);
      Object.defineProperty(TemplateLoader, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(TemplateLoader, "parameters", {get: function() {
          return [[XHR], [UrlResolver]];
        }});
      Object.defineProperty(TemplateLoader.prototype.load, "parameters", {get: function() {
          return [[ViewDefinition]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/directive_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/change_detection", "angular2/src/render/dom/compiler/selector", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/directive_parser";
  var isPresent,
      isBlank,
      BaseException,
      assertionsEnabled,
      RegExpWrapper,
      StringWrapper,
      List,
      MapWrapper,
      ListWrapper,
      DOM,
      Parser,
      SelectorMatcher,
      CssSelector,
      CompileStep,
      CompileElement,
      CompileControl,
      DirectiveMetadata,
      dashCaseToCamelCase,
      camelCaseToDashCase,
      EVENT_TARGET_SEPARATOR,
      DirectiveParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      assertionsEnabled = $__m.assertionsEnabled;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      SelectorMatcher = $__m.SelectorMatcher;
      CssSelector = $__m.CssSelector;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
      EVENT_TARGET_SEPARATOR = $__m.EVENT_TARGET_SEPARATOR;
    }],
    execute: function() {
      DirectiveParser = (function($__super) {
        function DirectiveParser(parser, directives) {
          $traceurRuntime.superConstructor(DirectiveParser).call(this);
          this._parser = parser;
          this._selectorMatcher = new SelectorMatcher();
          this._directives = directives;
          for (var i = 0; i < directives.length; i++) {
            var directive = directives[i];
            var selector = CssSelector.parse(directive.selector);
            this._ensureComponentOnlyHasElementSelector(selector, directive);
            this._selectorMatcher.addSelectables(selector, i);
          }
        }
        return ($traceurRuntime.createClass)(DirectiveParser, {
          _ensureComponentOnlyHasElementSelector: function(selector, directive) {
            var isElementSelector = selector.length === 1 && selector[0].isElementSelector();
            if (!isElementSelector && directive.type === DirectiveMetadata.COMPONENT_TYPE) {
              throw new BaseException(("Component '" + directive.id + "' can only have an element selector, but had '" + directive.selector + "'"));
            }
          },
          process: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var classList = current.classList();
            var cssSelector = new CssSelector();
            var nodeName = DOM.nodeName(current.element);
            cssSelector.setElement(nodeName);
            for (var i = 0; i < classList.length; i++) {
              cssSelector.addClassName(classList[i]);
            }
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              cssSelector.addAttribute(attrName, attrValue);
            }));
            var componentDirective;
            this._selectorMatcher.match(cssSelector, (function(selector, directiveIndex) {
              var elementBinder = current.bindElement();
              var directive = $__0._directives[directiveIndex];
              var directiveBinderBuilder = elementBinder.bindDirective(directiveIndex);
              current.compileChildren = current.compileChildren && directive.compileChildren;
              if (isPresent(directive.properties)) {
                MapWrapper.forEach(directive.properties, (function(bindConfig, dirProperty) {
                  $__0._bindDirectiveProperty(dirProperty, bindConfig, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(directive.hostListeners)) {
                MapWrapper.forEach(directive.hostListeners, (function(action, eventName) {
                  $__0._bindDirectiveEvent(eventName, action, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(directive.hostProperties)) {
                MapWrapper.forEach(directive.hostProperties, (function(hostPropertyName, directivePropertyName) {
                  $__0._bindHostProperty(hostPropertyName, directivePropertyName, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(directive.readAttributes)) {
                ListWrapper.forEach(directive.readAttributes, (function(attrName) {
                  elementBinder.readAttribute(attrName);
                }));
              }
              if (directive.type === DirectiveMetadata.COMPONENT_TYPE) {
                if (isPresent(componentDirective)) {
                  throw new BaseException(("Only one component directive is allowed per element - check " + current.elementDescription));
                }
                componentDirective = directive;
                elementBinder.setComponentId(directive.id);
              }
            }));
          },
          _bindDirectiveProperty: function(dirProperty, bindConfig, compileElement, directiveBinderBuilder) {
            var pipes = this._splitBindConfig(bindConfig);
            var elProp = ListWrapper.removeAt(pipes, 0);
            var bindingAst = MapWrapper.get(compileElement.bindElement().propertyBindings, dashCaseToCamelCase(elProp));
            if (isBlank(bindingAst)) {
              var attributeValue = MapWrapper.get(compileElement.attrs(), camelCaseToDashCase(elProp));
              if (isPresent(attributeValue)) {
                bindingAst = this._parser.wrapLiteralPrimitive(attributeValue, compileElement.elementDescription);
              }
            }
            if (isPresent(bindingAst)) {
              var fullExpAstWithBindPipes = this._parser.addPipes(bindingAst, pipes);
              directiveBinderBuilder.bindProperty(dirProperty, fullExpAstWithBindPipes);
            }
          },
          _bindDirectiveEvent: function(eventName, action, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseAction(action, compileElement.elementDescription);
            if (StringWrapper.contains(eventName, EVENT_TARGET_SEPARATOR)) {
              var parts = eventName.split(EVENT_TARGET_SEPARATOR);
              directiveBinderBuilder.bindEvent(parts[1], ast, parts[0]);
            } else {
              directiveBinderBuilder.bindEvent(eventName, ast);
            }
          },
          _bindHostProperty: function(hostPropertyName, directivePropertyName, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseBinding(directivePropertyName, ("hostProperties of " + compileElement.elementDescription));
            directiveBinderBuilder.bindHostProperty(hostPropertyName, ast);
          },
          _splitBindConfig: function(bindConfig) {
            return ListWrapper.map(bindConfig.split('|'), (function(s) {
              return s.trim();
            }));
          }
        }, {}, $__super);
      }(CompileStep));
      $__export("DirectiveParser", DirectiveParser);
      Object.defineProperty(DirectiveParser, "parameters", {get: function() {
          return [[Parser], [assert.genericType(List, DirectiveMetadata)]];
        }});
      Object.defineProperty(DirectiveParser.prototype.process, "parameters", {get: function() {
          return [[CompileElement], [CompileElement], [CompileControl]];
        }});
      Object.defineProperty(DirectiveParser.prototype._splitBindConfig, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/query_list", ["angular2/src/core/compiler/base_query_list"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/query_list";
  var BaseQueryList,
      QueryList;
  return {
    setters: [function($__m) {
      BaseQueryList = $__m.BaseQueryList;
    }],
    execute: function() {
      QueryList = (function($__super) {
        function QueryList() {
          $traceurRuntime.superConstructor(QueryList).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(QueryList, {
          onChange: function(callback) {
            return $traceurRuntime.superGet(this, QueryList.prototype, "onChange").call(this, callback);
          },
          removeCallback: function(callback) {
            return $traceurRuntime.superGet(this, QueryList.prototype, "removeCallback").call(this, callback);
          }
        }, {}, $__super);
      }(BaseQueryList));
      $__export("QueryList", QueryList);
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/util", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/shadow_dom/shadow_css"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/util";
  var isBlank,
      isPresent,
      int,
      MapWrapper,
      Map,
      DOM,
      ShadowCss,
      _componentUIDs,
      _nextComponentUID,
      _sharedStyleTexts,
      _lastInsertedStyleEl;
  function moveViewNodesIntoParent(parent, view) {
    for (var i = 0; i < view.rootNodes.length; ++i) {
      DOM.appendChild(parent, view.rootNodes[i]);
    }
  }
  function getComponentId(componentStringId) {
    var id = MapWrapper.get(_componentUIDs, componentStringId);
    if (isBlank(id)) {
      id = _nextComponentUID++;
      MapWrapper.set(_componentUIDs, componentStringId, id);
    }
    return id;
  }
  function insertSharedStyleText(cssText, styleHost, styleEl) {
    if (!MapWrapper.contains(_sharedStyleTexts, cssText)) {
      MapWrapper.set(_sharedStyleTexts, cssText, true);
      insertStyleElement(styleHost, styleEl);
    }
  }
  function insertStyleElement(host, styleEl) {
    if (isBlank(_lastInsertedStyleEl)) {
      var firstChild = DOM.firstChild(host);
      if (isPresent(firstChild)) {
        DOM.insertBefore(firstChild, styleEl);
      } else {
        DOM.appendChild(host, styleEl);
      }
    } else {
      DOM.insertAfter(_lastInsertedStyleEl, styleEl);
    }
    _lastInsertedStyleEl = styleEl;
  }
  function getHostAttribute(id) {
    return ("_nghost-" + id);
  }
  function getContentAttribute(id) {
    return ("_ngcontent-" + id);
  }
  function shimCssForComponent(cssText, componentId) {
    var id = getComponentId(componentId);
    var shadowCss = new ShadowCss();
    return shadowCss.shimCssText(cssText, getContentAttribute(id), getHostAttribute(id));
  }
  function resetShadowDomCache() {
    MapWrapper.clear(_componentUIDs);
    _nextComponentUID = 0;
    MapWrapper.clear(_sharedStyleTexts);
    _lastInsertedStyleEl = null;
  }
  $__export("moveViewNodesIntoParent", moveViewNodesIntoParent);
  $__export("getComponentId", getComponentId);
  $__export("insertSharedStyleText", insertSharedStyleText);
  $__export("insertStyleElement", insertStyleElement);
  $__export("getHostAttribute", getHostAttribute);
  $__export("getContentAttribute", getContentAttribute);
  $__export("shimCssForComponent", shimCssForComponent);
  $__export("resetShadowDomCache", resetShadowDomCache);
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      int = $__m.int;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ShadowCss = $__m.ShadowCss;
    }],
    execute: function() {
      _componentUIDs = MapWrapper.create();
      _nextComponentUID = 0;
      _sharedStyleTexts = MapWrapper.create();
      Object.defineProperty(getComponentId, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(getHostAttribute, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(getContentAttribute, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(shimCssForComponent, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_gestures", ["angular2/src/render/dom/events/hammer_common", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_gestures";
  var HammerGesturesPluginCommon,
      isPresent,
      BaseException,
      HammerGesturesPlugin;
  return {
    setters: [function($__m) {
      HammerGesturesPluginCommon = $__m.HammerGesturesPluginCommon;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      HammerGesturesPlugin = (function($__super) {
        function HammerGesturesPlugin() {
          $traceurRuntime.superConstructor(HammerGesturesPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPlugin, {
          supports: function(eventName) {
            if (!$traceurRuntime.superGet(this, HammerGesturesPlugin.prototype, "supports").call(this, eventName))
              return false;
            if (!isPresent(window.Hammer)) {
              throw new BaseException(("Hammer.js is not loaded, can not bind " + eventName + " event"));
            }
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            if (shouldSupportBubble)
              throw new BaseException('Hammer.js plugin does not support bubbling gestures.');
            var zone = this.manager.getZone();
            eventName = eventName.toLowerCase();
            zone.runOutsideAngular(function() {
              var mc = new Hammer(element);
              mc.get('pinch').set({enable: true});
              mc.get('rotate').set({enable: true});
              mc.on(eventName, function(eventObj) {
                zone.run(function() {
                  handler(eventObj);
                });
              });
            });
          }
        }, {}, $__super);
      }(HammerGesturesPluginCommon));
      $__export("HammerGesturesPlugin", HammerGesturesPlugin);
      Object.defineProperty(HammerGesturesPlugin.prototype.supports, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(HammerGesturesPlugin.prototype.addEventListener, "parameters", {get: function() {
          return [[], [assert.type.string], [Function], [assert.type.boolean]];
        }});
    }
  };
});

System.register("angular2/src/core/testability/testability", ["angular2/di", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/testability/get_testability"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/testability";
  var Injectable,
      DOM,
      Map,
      MapWrapper,
      List,
      ListWrapper,
      StringWrapper,
      isBlank,
      BaseException,
      getTestabilityModule,
      Testability,
      TestabilityRegistry;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      getTestabilityModule = $__m;
    }],
    execute: function() {
      Testability = (function() {
        function Testability() {
          this._pendingCount = 0;
          this._callbacks = ListWrapper.create();
        }
        return ($traceurRuntime.createClass)(Testability, {
          increaseCount: function() {
            var delta = arguments[0] !== (void 0) ? arguments[0] : 1;
            this._pendingCount += delta;
            if (this._pendingCount < 0) {
              throw new BaseException('pending async requests below zero');
            } else if (this._pendingCount == 0) {
              this._runCallbacks();
            }
            return this._pendingCount;
          },
          _runCallbacks: function() {
            while (this._callbacks.length !== 0) {
              ListWrapper.removeLast(this._callbacks)();
            }
          },
          whenStable: function(callback) {
            ListWrapper.push(this._callbacks, callback);
            if (this._pendingCount === 0) {
              this._runCallbacks();
            }
          },
          getPendingCount: function() {
            return this._pendingCount;
          },
          findBindings: function(using, binding, exactMatch) {
            return [];
          }
        }, {});
      }());
      $__export("Testability", Testability);
      Object.defineProperty(Testability, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(Testability.prototype.increaseCount, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(Testability.prototype.whenStable, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(Testability.prototype.findBindings, "parameters", {get: function() {
          return [[], [assert.type.string], [assert.type.boolean]];
        }});
      TestabilityRegistry = (function() {
        function TestabilityRegistry() {
          this._applications = MapWrapper.create();
          getTestabilityModule.GetTestability.addToWindow(this);
        }
        return ($traceurRuntime.createClass)(TestabilityRegistry, {
          registerApplication: function(token, testability) {
            MapWrapper.set(this._applications, token, testability);
          },
          findTestabilityInTree: function(elem) {
            if (elem == null) {
              return null;
            }
            if (MapWrapper.contains(this._applications, elem)) {
              return MapWrapper.get(this._applications, elem);
            }
            if (DOM.isShadowRoot(elem)) {
              return this.findTestabilityInTree(DOM.getHost(elem));
            }
            return this.findTestabilityInTree(DOM.parentElement(elem));
          }
        }, {});
      }());
      $__export("TestabilityRegistry", TestabilityRegistry);
      Object.defineProperty(TestabilityRegistry, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(TestabilityRegistry.prototype.registerApplication, "parameters", {get: function() {
          return [[], [Testability]];
        }});
    }
  };
});

System.register("angular2/annotations", ["angular2/src/core/annotations/annotations", "angular2/src/core/decorators/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/annotations";
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("angular2/directives", ["angular2/src/directives/class", "angular2/src/directives/for", "angular2/src/directives/if", "angular2/src/directives/non_bindable", "angular2/src/directives/switch"], function($__export) {
  "use strict";
  var __moduleName = "angular2/directives";
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("angular2/src/forms/model", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/model";
  var isPresent,
      Observable,
      EventEmitter,
      ObservableWrapper,
      StringMap,
      StringMapWrapper,
      ListWrapper,
      List,
      Validators,
      VALID,
      INVALID,
      AbstractControl,
      Control,
      ControlGroup,
      ControlArray;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Observable = $__m.Observable;
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      StringMap = $__m.StringMap;
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      VALID = "VALID";
      $__export("VALID", VALID);
      INVALID = "INVALID";
      $__export("INVALID", INVALID);
      AbstractControl = (function() {
        function AbstractControl(validator) {
          this.validator = validator;
          this._pristine = true;
        }
        return ($traceurRuntime.createClass)(AbstractControl, {
          get value() {
            return this._value;
          },
          get status() {
            return this._status;
          },
          get valid() {
            return this._status === VALID;
          },
          get errors() {
            return this._errors;
          },
          get pristine() {
            return this._pristine;
          },
          get dirty() {
            return !this.pristine;
          },
          get valueChanges() {
            return this._valueChanges;
          },
          setParent: function(parent) {
            this._parent = parent;
          },
          _updateParent: function() {
            if (isPresent(this._parent)) {
              this._parent._updateValue();
            }
          }
        }, {});
      }());
      Object.defineProperty(AbstractControl, "parameters", {get: function() {
          return [[Function]];
        }});
      Control = (function($__super) {
        function Control(value) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.nullValidator;
          $traceurRuntime.superConstructor(Control).call(this, validator);
          this._setValueErrorsStatus(value);
          this._valueChanges = new EventEmitter();
        }
        return ($traceurRuntime.createClass)(Control, {
          updateValue: function(value) {
            this._setValueErrorsStatus(value);
            this._pristine = false;
            ObservableWrapper.callNext(this._valueChanges, this._value);
            this._updateParent();
          },
          _setValueErrorsStatus: function(value) {
            this._value = value;
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("Control", Control);
      Object.defineProperty(Control, "parameters", {get: function() {
          return [[assert.type.any], [Function]];
        }});
      Object.defineProperty(Control.prototype.updateValue, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      ControlGroup = (function($__super) {
        function ControlGroup(controls) {
          var optionals = arguments[1] !== (void 0) ? arguments[1] : null;
          var validator = arguments[2] !== (void 0) ? arguments[2] : Validators.group;
          $traceurRuntime.superConstructor(ControlGroup).call(this, validator);
          this.controls = controls;
          this._optionals = isPresent(optionals) ? optionals : {};
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._setValueErrorsStatus();
        }
        return ($traceurRuntime.createClass)(ControlGroup, {
          include: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, true);
            this._updateValue();
          },
          exclude: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, false);
            this._updateValue();
          },
          contains: function(controlName) {
            var c = StringMapWrapper.contains(this.controls, controlName);
            return c && this._included(controlName);
          },
          _setParentForControls: function() {
            var $__0 = this;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              control.setParent($__0);
            }));
          },
          _updateValue: function() {
            this._setValueErrorsStatus();
            this._pristine = false;
            ObservableWrapper.callNext(this._valueChanges, this._value);
            this._updateParent();
          },
          _setValueErrorsStatus: function() {
            this._value = this._reduceValue();
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
          },
          _reduceValue: function() {
            return this._reduceChildren({}, (function(acc, control, name) {
              acc[name] = control.value;
              return acc;
            }));
          },
          _reduceChildren: function(initValue, fn) {
            var $__0 = this;
            var res = initValue;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              if ($__0._included(name)) {
                res = fn(res, control, name);
              }
            }));
            return res;
          },
          _included: function(controlName) {
            var isOptional = StringMapWrapper.contains(this._optionals, controlName);
            return !isOptional || StringMapWrapper.get(this._optionals, controlName);
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlGroup", ControlGroup);
      Object.defineProperty(ControlGroup, "parameters", {get: function() {
          return [[StringMap], [StringMap], [Function]];
        }});
      Object.defineProperty(ControlGroup.prototype.include, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ControlGroup.prototype.exclude, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ControlGroup.prototype.contains, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(ControlGroup.prototype._reduceChildren, "parameters", {get: function() {
          return [[assert.type.any], [Function]];
        }});
      Object.defineProperty(ControlGroup.prototype._included, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      ControlArray = (function($__super) {
        function ControlArray(controls) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.array;
          $traceurRuntime.superConstructor(ControlArray).call(this, validator);
          this.controls = controls;
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._setValueErrorsStatus();
        }
        return ($traceurRuntime.createClass)(ControlArray, {
          at: function(index) {
            return this.controls[index];
          },
          push: function(control) {
            ListWrapper.push(this.controls, control);
            control.setParent(this);
            this._updateValue();
          },
          insert: function(index, control) {
            ListWrapper.insert(this.controls, index, control);
            control.setParent(this);
            this._updateValue();
          },
          removeAt: function(index) {
            ListWrapper.removeAt(this.controls, index);
            this._updateValue();
          },
          get length() {
            return this.controls.length;
          },
          _updateValue: function() {
            this._setValueErrorsStatus();
            this._pristine = false;
            ObservableWrapper.callNext(this._valueChanges, this._value);
            this._updateParent();
          },
          _setParentForControls: function() {
            var $__0 = this;
            ListWrapper.forEach(this.controls, (function(control) {
              control.setParent($__0);
            }));
          },
          _setValueErrorsStatus: function() {
            this._value = ListWrapper.map(this.controls, (function(c) {
              return c.value;
            }));
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlArray", ControlArray);
      Object.defineProperty(ControlArray, "parameters", {get: function() {
          return [[assert.genericType(List, AbstractControl)], [Function]];
        }});
      Object.defineProperty(ControlArray.prototype.at, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(ControlArray.prototype.push, "parameters", {get: function() {
          return [[AbstractControl]];
        }});
      Object.defineProperty(ControlArray.prototype.insert, "parameters", {get: function() {
          return [[assert.type.number], [AbstractControl]];
        }});
      Object.defineProperty(ControlArray.prototype.removeAt, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
    }
  };
});

System.register("src/entity-forge/EntityForge.es6", ["src/entity-forge/Verify.es6", "src/entity-forge/Validation.es6", "src/entity-forge/EntityBaseTypes.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/entity-forge/EntityForge.es6";
  var LazyVerify,
      Verify,
      ValidationError,
      EntityBase,
      propertyErrorsToString,
      BaseForge,
      ObjectForge,
      StringForge,
      NumberForge,
      BooleanForge,
      EnumForge,
      EntityForge;
  return {
    setters: [function($__m) {
      LazyVerify = $__m.LazyVerify;
      Verify = $__m.Verify;
    }, function($__m) {
      ValidationError = $__m.ValidationError;
    }, function($__m) {
      EntityBase = $__m.EntityBase;
    }],
    execute: function() {
      propertyErrorsToString = function() {
        return '[' + this.errors.map((function(error) {
          return error.validator.msg;
        })).join("],    [") + ']';
      };
      BaseForge = (function() {
        function BaseForge() {
          this._defaultValue = null;
          this._v = {};
          this._vAry = [];
        }
        return ($traceurRuntime.createClass)(BaseForge, {
          _applyValidation: function(cfg) {
            if (!this._v[cfg.name]) {
              this._vAry.push(cfg);
              this._v[cfg.name] = cfg;
            }
            return this;
          },
          newInstance: function() {
            var cfg = arguments[0] !== (void 0) ? arguments[0] : null;
            if (cfg === null) {
              cfg = this.defaultValue;
            }
            return this.transform(cfg);
          },
          transform: function(value) {
            return value;
          },
          get defaultValue() {
            return Verify.isFunction(this._defaultValue) ? this._defaultValue() : this._defaultValue;
          },
          validate: function(value) {
            var fieldName = arguments[1] !== (void 0) ? arguments[1] : '';
            var aborted = false;
            var valid = true;
            var errors = [];
            this._vAry.forEach((function(validator) {
              if (!aborted) {
                var vResult = validator.fn.apply(null, [value].concat(validator.args || []));
                if (vResult === true || (vResult && vResult.valid === true)) {
                  return ;
                }
                if (vResult === false) {
                  valid = false;
                  aborted = validator.abortOnFail === true;
                  errors.push({
                    value: value,
                    fieldName: fieldName,
                    validator: validator,
                    aborted: aborted
                  });
                } else if (vResult && Verify.isArray(vResult.errors)) {
                  Array.prototype.push.apply(errors, vResult.errors);
                }
              }
            }));
            return {
              valid: errors.length === 0,
              errors: errors,
              toString: propertyErrorsToString
            };
          },
          _createPropertyDefinition: function(entityInstance, fieldName) {
            var defaultValue = arguments[2] !== (void 0) ? arguments[2] : null;
            var wrapper = {value: defaultValue !== null ? this.transform(defaultValue) : this.newInstance()};
            Object.defineProperty(entityInstance, fieldName, {
              configurable: false,
              enumerable: true,
              set: this._createSetter(wrapper),
              get: function() {
                return wrapper.value;
              }
            });
          },
          _createSetter: function(wrapper) {
            var fieldDef = this;
            return function(value) {
              var transformed = fieldDef.transform(value);
              var r = fieldDef.validate(transformed);
              if (r.valid) {
                wrapper.value = transformed;
              } else {
                throw new ValidationError(r);
              }
            };
          },
          initTo: function(defaultValue) {
            this._defaultValue = defaultValue;
            return this;
          },
          exists: function() {
            var msg = arguments[0] !== (void 0) ? arguments[0] : "@validations.exists.doesNotExist";
            return this._applyValidation({
              name: 'exists',
              fn: LazyVerify.exists,
              msg: msg,
              abortOnFail: true
            });
          },
          notNull: function() {
            var msg = arguments[0] !== (void 0) ? arguments[0] : "@validations.obj.objectIsNull";
            return this._applyValidation({
              name: 'notNull',
              fn: LazyVerify.exists,
              msg: msg,
              abortOnFail: true
            });
          }
        }, {});
      }());
      ObjectForge = (function($__super) {
        function ObjectForge() {
          $traceurRuntime.superConstructor(ObjectForge).call(this);
        }
        return ($traceurRuntime.createClass)(ObjectForge, {
          asNewable: function() {
            var ctor = this.newInstance;
            ctor.prototype = this;
            return ctor;
          },
          newInstance: function() {
            var cfg = arguments[0] !== (void 0) ? arguments[0] : null;
            cfg = cfg || this.defaultValue || {};
            var theInstance = new EntityBase(this);
            if (this._v.obj.allowEmptyAtInit !== true) {
              this._initMemberProperties(theInstance, cfg);
            }
            return theInstance;
          },
          _initMemberProperties: function(theInstance, cfg) {
            var fieldDefs = this.fieldDefinitions;
            Object.keys(fieldDefs).forEach((function(key) {
              var field = fieldDefs[key];
              field._createPropertyDefinition(theInstance, key, cfg[key]);
            }));
            Object.freeze(theInstance);
          },
          transform: function(entity) {
            return entity || (this._v.notNull ? {} : null);
          },
          _createSetter: function(wrapper) {
            var fieldDef = this;
            var fn;
            if (!fieldDef._v.obj.allowEmptyAtInit) {
              fn = $traceurRuntime.superGet(this, ObjectForge.prototype, "_createSetter").call(this, wrapper);
            } else {
              fn = function(value) {
                var transformed = fieldDef.transform(value);
                if (LazyVerify.hasOnly(transformed, ['validate'], true)) {
                  wrapper.value = transformed;
                } else {
                  var r = fieldDef.validate(transformed, fieldDef.fieldName);
                  if (r.valid) {
                    wrapper.value = transformed;
                  } else {
                    throw new ValidationError(r, fieldDef.fieldName);
                  }
                }
              };
            }
            return fn;
          },
          notEmpty: function() {
            var msg = arguments[0] !== (void 0) ? arguments[0] : "@validations.obj.objectIsEmpty";
            return this._applyValidation({
              name: 'notEmpty',
              fn: function(value) {
                return !LazyVerify.emptyObject(value);
              },
              msg: msg,
              abortOnFail: true
            });
          },
          allowEmptyAtInit: function() {
            var allowEmptyAtInit = arguments[0] !== (void 0) ? arguments[0] : true;
            this._v.obj.allowEmptyAtInit = allowEmptyAtInit;
            return this;
          }
        }, {
          memberPropertiesValid: function(entity, objFieldDef) {
            var errors = [];
            if (Verify.exists(entity) && !LazyVerify.hasOnly(entity, ['validate'], true)) {
              Object.keys(objFieldDef.fieldDefinitions).forEach((function(key) {
                var fieldDef = objFieldDef.fieldDefinitions[key];
                var result = fieldDef.validate(entity[key], key);
                if (!result.valid) {
                  Array.prototype.push.apply(errors, result.errors);
                }
              }));
            }
            return {
              valid: errors.length === 0,
              errors: errors
            };
          },
          obj: function(fieldName) {
            var fields = arguments[1] !== (void 0) ? arguments[1] : {};
            var defaultValue = arguments[2] !== (void 0) ? arguments[2] : null;
            var msg = arguments[3] !== (void 0) ? arguments[3] : "@validations.obj.invalidChildMember";
            var forge = new ObjectForge();
            forge._defaultValue = defaultValue;
            forge.fieldDefinitions = fields;
            forge.fieldName = fieldName;
            return forge._applyValidation({
              name: 'obj',
              fn: ObjectForge.memberPropertiesValid,
              args: [forge],
              msg: msg,
              abortOnFail: true
            });
          }
        }, $__super);
      }(BaseForge));
      StringForge = (function($__super) {
        function StringForge() {
          $traceurRuntime.superConstructor(StringForge).call(this);
        }
        return ($traceurRuntime.createClass)(StringForge, {
          minLength: function(min) {
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.string.minLength.tooShort";
            return this.exists()._applyValidation({
              name: 'minLength',
              fn: LazyVerify.minLength,
              args: [min],
              msg: msg
            });
          },
          maxLength: function(max) {
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.string.maxLength.tooLong";
            return this.exists()._applyValidation({
              name: 'maxLength',
              fn: LazyVerify.maxLength,
              args: [max],
              msg: msg
            });
          }
        }, {string: function() {
            var defaultValue = arguments[0] !== (void 0) ? arguments[0] : null;
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.string.notStringValue";
            var forge = new StringForge();
            forge._defaultValue = defaultValue;
            return forge._applyValidation({
              name: 'string',
              fn: Verify.isString,
              args: [true],
              msg: msg,
              abortOnFail: true
            });
          }}, $__super);
      }(BaseForge));
      NumberForge = (function($__super) {
        function NumberForge() {
          $traceurRuntime.superConstructor(NumberForge).call(this);
        }
        return ($traceurRuntime.createClass)(NumberForge, {
          min: function(min) {
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.number.min.tooSmall";
            return this._applyValidation({
              name: "min",
              fn: LazyVerify.min,
              args: [min],
              msg: msg,
              abortOnFail: true
            });
          },
          max: function(max) {
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.number.max.tooLarge";
            return this._applyValidation({
              name: "max",
              fn: LazyVerify.max,
              args: [max],
              msg: msg,
              abortOnFail: true
            });
          }
        }, {
          number: function() {
            var defaultValue = arguments[0] !== (void 0) ? arguments[0] : 0;
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.number.notNumber";
            var forge = new NumberForge();
            forge._defaultValue = defaultValue;
            return forge._applyValidation({
              name: 'number',
              fn: LazyVerify.isNumber,
              msg: msg,
              abortOnFail: true
            });
          },
          int: function() {
            var defaultValue = arguments[0] !== (void 0) ? arguments[0] : 0;
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.number.int.notInteger";
            var forge = new NumberForge();
            forge._defaultValue = defaultValue;
            return forge._applyValidation({
              name: 'int',
              fn: LazyVerify.isInteger,
              msg: msg,
              abortOnFail: true
            });
          }
        }, $__super);
      }(BaseForge));
      BooleanForge = (function($__super) {
        function BooleanForge() {
          $traceurRuntime.superConstructor(BooleanForge).call(this);
        }
        return ($traceurRuntime.createClass)(BooleanForge, {}, {bool: function() {
            var defaultValue = arguments[0] !== (void 0) ? arguments[0] : false;
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.boolean.notBoolean";
            var forge = new BooleanForge();
            forge._defaultValue = defaultValue;
            return forge._applyValidation({
              name: 'bool',
              fn: LazyVerify.isBoolean,
              msg: msg,
              abortOnFail: true
            });
          }}, $__super);
      }(BaseForge));
      EnumForge = (function($__super) {
        function EnumForge() {
          $traceurRuntime.superConstructor(EnumForge).call(this);
          this.allowedValues = [];
        }
        return ($traceurRuntime.createClass)(EnumForge, {
          values: function(values) {
            if (values && values.length > 0) {
              Array.prototype.push.apply(this.allowedValues, values);
            }
            return this;
          },
          initTo: function(value) {
            var def = value;
            if (Verify.isNumber(value)) {
              def = this.allowedValues[value];
            }
            return $traceurRuntime.superGet(this, EnumForge.prototype, "initTo").call(this, def);
          }
        }, {
          enum: function() {
            var defaultValue = arguments[0] !== (void 0) ? arguments[0] : null;
            var msg = arguments[1] !== (void 0) ? arguments[1] : "@validations.enum.notMember";
            var forge = new EnumForge();
            forge._defaultValue = defaultValue;
            return forge._applyValidation({
              name: 'enum',
              fn: function(value) {
                return EnumForge.isMember(forge.allowedValues, value);
              },
              msg: msg,
              abortOnFail: true
            });
          },
          isMember: function(allowedValues, value) {
            return allowedValues.some((function(allowedValue) {
              return allowedValue === value;
            }));
          }
        }, $__super);
      }(BaseForge));
      EntityForge = {
        any: function() {
          return new BaseForge();
        },
        string: StringForge.string,
        number: NumberForge.number,
        int: NumberForge.int,
        bool: BooleanForge.bool,
        enum: EnumForge.enum,
        obj: ObjectForge.obj
      };
      $__export("EntityForge", EntityForge), $__export("ValidationError", ValidationError);
    }
  };
});

System.register("src/dc/api/Core.ts", ["rtts_assert/rtts_assert", "npm:debug@2.2.0"], function($__export) {
  "use strict";
  var __moduleName = "src/dc/api/Core.ts";
  var assert,
      XDebug,
      log,
      KEY_CHARS,
      prevGenTime,
      prevRandChars,
      Core;
  return {
    setters: [function($__m) {
      assert = $__m.assert;
    }, function($__m) {
      XDebug = $__m.default;
    }],
    execute: function() {
      log = XDebug('RulesEngine.Core');
      KEY_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
      prevGenTime = 0;
      prevRandChars = [];
      Core = {
        Key: {next: function() {
            var now = Date.now();
            var duplicateTime = now === prevGenTime;
            prevGenTime = now;
            var timeStampChars = new Array(8);
            for (var i = 7; i >= 0; i--) {
              timeStampChars[i] = KEY_CHARS.charAt(now % 64);
              now = Math.floor(now / 64);
            }
            var key = timeStampChars.join("");
            if (!duplicateTime) {
              for (i = 0; i < 12; i++) {
                prevRandChars[i] = Math.floor(Math.random() * 64);
              }
            } else {
              for (i = 11; i >= 0 && prevRandChars[i] === 63; i--) {
                prevRandChars[i] = 0;
              }
              prevRandChars[i]++;
            }
            for (i = 0; i < 12; i++) {
              key += KEY_CHARS.charAt(prevRandChars[i]);
            }
            log("Generated Key:", key);
            return key;
          }},
        filters: {without: function(value) {
            return function(entry, idx) {
              return entry !== value;
            };
          }},
        Collections: {
          asSymmetricObjectMap: function(keyMap) {
            var prefix = arguments[1] !== (void 0) ? arguments[1] : '';
            assert.argumentTypes(keyMap, $traceurRuntime.type.any, prefix, $traceurRuntime.type.string);
            var x = {};
            Object.keys(keyMap).forEach((function(key) {
              x[key] = prefix + key;
            }));
            return x;
          },
          asArray: function(mapObject) {
            var transformFn = arguments[1] !== (void 0) ? arguments[1] : null;
            assert.argumentTypes(mapObject, $traceurRuntime.type.any, transformFn, Function);
            var a = [];
            Object.keys(mapObject).forEach((function(key) {
              a.push(transformFn ? transformFn(mapObject[key], key) : mapObject[key]);
            }));
            return a;
          },
          asMapObject: function(map) {
            var transformFn = arguments[1] !== (void 0) ? arguments[1] : null;
            assert.argumentTypes(map, $traceurRuntime.genericType(Map, $traceurRuntime.type.string, $traceurRuntime.type.any), transformFn, Function);
            var objectMap = {};
            map.forEach((function(value, key) {
              objectMap[key] = transformFn ? transformFn(value) : value;
            }));
            return objectMap;
          },
          newMap: function(objectMap) {
            var transformFn = arguments[1] !== (void 0) ? arguments[1] : null;
            assert.argumentTypes(objectMap, $traceurRuntime.type.any, transformFn, Function);
            var map = new Map();
            Object.keys(objectMap).forEach((function(key) {
              map.set(key, transformFn ? transformFn(objectMap[key], key) : objectMap[key]);
            }));
            return assert.returnType((map), $traceurRuntime.genericType(Map, $traceurRuntime.type.string, $traceurRuntime.type.any));
          },
          newSet: function(objectMap) {
            var theSet = new Set();
            Object.keys(objectMap).forEach((function(key) {
              objectMap[key]['$key'] = key;
              theSet.add(objectMap[key]);
            }));
            return assert.returnType((theSet), Set);
          }
        }
      };
      $__export("Core", Core);
    }
  };
});

System.register("angular2/src/reflection/reflection", ["angular2/src/reflection/reflector", "angular2/src/reflection/reflection_capabilities"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection";
  var Reflector,
      ReflectionCapabilities,
      __esModule,
      reflector;
  return {
    setters: [function($__m) {
      Reflector = $__m.Reflector;
      $__export("Reflector", $__m.Reflector);
    }, function($__m) {
      ReflectionCapabilities = $__m.ReflectionCapabilities;
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      reflector = new Reflector(new ReflectionCapabilities());
      $__export("reflector", reflector);
    }
  };
});

System.register("angular2/src/change_detection/binding_record", ["angular2/src/facade/lang", "angular2/src/reflection/types", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/directive_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/binding_record";
  var isPresent,
      isBlank,
      SetterFn,
      AST,
      DirectiveIndex,
      DirectiveRecord,
      DIRECTIVE,
      ELEMENT,
      TEXT_NODE,
      BindingRecord;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      SetterFn = $__m.SetterFn;
    }, function($__m) {
      AST = $__m.AST;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
      DirectiveRecord = $__m.DirectiveRecord;
    }],
    execute: function() {
      DIRECTIVE = "directive";
      ELEMENT = "element";
      TEXT_NODE = "textNode";
      BindingRecord = (function() {
        function BindingRecord(mode, implicitReceiver, ast, elementIndex, propertyName, setter, directiveRecord) {
          this.mode = mode;
          this.implicitReceiver = implicitReceiver;
          this.ast = ast;
          this.elementIndex = elementIndex;
          this.propertyName = propertyName;
          this.setter = setter;
          this.directiveRecord = directiveRecord;
        }
        return ($traceurRuntime.createClass)(BindingRecord, {
          callOnChange: function() {
            return isPresent(this.directiveRecord) && this.directiveRecord.callOnChange;
          },
          isOnPushChangeDetection: function() {
            return isPresent(this.directiveRecord) && this.directiveRecord.isOnPushChangeDetection();
          },
          isDirective: function() {
            return this.mode === DIRECTIVE;
          },
          isElement: function() {
            return this.mode === ELEMENT;
          },
          isTextNode: function() {
            return this.mode === TEXT_NODE;
          }
        }, {
          createForDirective: function(ast, propertyName, setter, directiveRecord) {
            return new BindingRecord(DIRECTIVE, 0, ast, 0, propertyName, setter, directiveRecord);
          },
          createForElement: function(ast, elementIndex, propertyName) {
            return new BindingRecord(ELEMENT, 0, ast, elementIndex, propertyName, null, null);
          },
          createForHostProperty: function(directiveIndex, ast, propertyName) {
            return new BindingRecord(ELEMENT, directiveIndex, ast, directiveIndex.elementIndex, propertyName, null, null);
          },
          createForTextNode: function(ast, elementIndex) {
            return new BindingRecord(TEXT_NODE, 0, ast, elementIndex, null, null, null);
          }
        });
      }());
      $__export("BindingRecord", BindingRecord);
      Object.defineProperty(BindingRecord, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any], [AST], [assert.type.number], [assert.type.string], [SetterFn], [DirectiveRecord]];
        }});
      Object.defineProperty(BindingRecord.createForDirective, "parameters", {get: function() {
          return [[AST], [assert.type.string], [SetterFn], [DirectiveRecord]];
        }});
      Object.defineProperty(BindingRecord.createForElement, "parameters", {get: function() {
          return [[AST], [assert.type.number], [assert.type.string]];
        }});
      Object.defineProperty(BindingRecord.createForHostProperty, "parameters", {get: function() {
          return [[DirectiveIndex], [AST], [assert.type.string]];
        }});
      Object.defineProperty(BindingRecord.createForTextNode, "parameters", {get: function() {
          return [[AST], [assert.type.number]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/dynamic_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/pipes/pipe_registry", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/proto_record", "angular2/src/change_detection/exceptions"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/dynamic_change_detector";
  var isPresent,
      isBlank,
      BaseException,
      FunctionWrapper,
      List,
      ListWrapper,
      MapWrapper,
      StringMapWrapper,
      AbstractChangeDetector,
      BindingRecord,
      PipeRegistry,
      ChangeDetectionUtil,
      uninitialized,
      ProtoRecord,
      RECORD_TYPE_SELF,
      RECORD_TYPE_PROPERTY,
      RECORD_TYPE_LOCAL,
      RECORD_TYPE_INVOKE_METHOD,
      RECORD_TYPE_CONST,
      RECORD_TYPE_INVOKE_CLOSURE,
      RECORD_TYPE_PRIMITIVE_OP,
      RECORD_TYPE_KEYED_ACCESS,
      RECORD_TYPE_PIPE,
      RECORD_TYPE_BINDING_PIPE,
      RECORD_TYPE_INTERPOLATE,
      ExpressionChangedAfterItHasBeenChecked,
      ChangeDetectionError,
      DynamicChangeDetector;
  function isSame(a, b) {
    if (a === b)
      return true;
    if (a instanceof String && b instanceof String && a == b)
      return true;
    if ((a !== a) && (b !== b))
      return true;
    return false;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      FunctionWrapper = $__m.FunctionWrapper;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      BindingRecord = $__m.BindingRecord;
    }, function($__m) {
      PipeRegistry = $__m.PipeRegistry;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
      uninitialized = $__m.uninitialized;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
      RECORD_TYPE_SELF = $__m.RECORD_TYPE_SELF;
      RECORD_TYPE_PROPERTY = $__m.RECORD_TYPE_PROPERTY;
      RECORD_TYPE_LOCAL = $__m.RECORD_TYPE_LOCAL;
      RECORD_TYPE_INVOKE_METHOD = $__m.RECORD_TYPE_INVOKE_METHOD;
      RECORD_TYPE_CONST = $__m.RECORD_TYPE_CONST;
      RECORD_TYPE_INVOKE_CLOSURE = $__m.RECORD_TYPE_INVOKE_CLOSURE;
      RECORD_TYPE_PRIMITIVE_OP = $__m.RECORD_TYPE_PRIMITIVE_OP;
      RECORD_TYPE_KEYED_ACCESS = $__m.RECORD_TYPE_KEYED_ACCESS;
      RECORD_TYPE_PIPE = $__m.RECORD_TYPE_PIPE;
      RECORD_TYPE_BINDING_PIPE = $__m.RECORD_TYPE_BINDING_PIPE;
      RECORD_TYPE_INTERPOLATE = $__m.RECORD_TYPE_INTERPOLATE;
    }, function($__m) {
      ExpressionChangedAfterItHasBeenChecked = $__m.ExpressionChangedAfterItHasBeenChecked;
      ChangeDetectionError = $__m.ChangeDetectionError;
    }],
    execute: function() {
      DynamicChangeDetector = (function($__super) {
        function DynamicChangeDetector(changeControlStrategy, dispatcher, pipeRegistry, protoRecords, directiveRecords) {
          $traceurRuntime.superConstructor(DynamicChangeDetector).call(this);
          this.dispatcher = dispatcher;
          this.pipeRegistry = pipeRegistry;
          this.values = ListWrapper.createFixedSize(protoRecords.length + 1);
          this.pipes = ListWrapper.createFixedSize(protoRecords.length + 1);
          this.prevContexts = ListWrapper.createFixedSize(protoRecords.length + 1);
          this.changes = ListWrapper.createFixedSize(protoRecords.length + 1);
          ListWrapper.fill(this.values, uninitialized);
          ListWrapper.fill(this.pipes, null);
          ListWrapper.fill(this.prevContexts, uninitialized);
          ListWrapper.fill(this.changes, false);
          this.locals = null;
          this.directives = null;
          this.protos = protoRecords;
          this.directiveRecords = directiveRecords;
          this.changeControlStrategy = changeControlStrategy;
        }
        return ($traceurRuntime.createClass)(DynamicChangeDetector, {
          hydrate: function(context, locals, directives) {
            this.mode = ChangeDetectionUtil.changeDetectionMode(this.changeControlStrategy);
            this.values[0] = context;
            this.locals = locals;
            this.directives = directives;
          },
          dehydrate: function() {
            this._destroyPipes();
            ListWrapper.fill(this.values, uninitialized);
            ListWrapper.fill(this.changes, false);
            ListWrapper.fill(this.pipes, null);
            ListWrapper.fill(this.prevContexts, uninitialized);
            this.locals = null;
          },
          _destroyPipes: function() {
            for (var i = 0; i < this.pipes.length; ++i) {
              if (isPresent(this.pipes[i])) {
                this.pipes[i].onDestroy();
              }
            }
          },
          hydrated: function() {
            return this.values[0] !== uninitialized;
          },
          detectChangesInRecords: function(throwOnChange) {
            var protos = this.protos;
            var changes = null;
            var isChanged = false;
            for (var i = 0; i < protos.length; ++i) {
              var proto = protos[i];
              var bindingRecord = proto.bindingRecord;
              var directiveRecord = bindingRecord.directiveRecord;
              var change = this._check(proto);
              if (isPresent(change)) {
                if (throwOnChange)
                  ChangeDetectionUtil.throwOnChange(proto, change);
                this._updateDirectiveOrElement(change, bindingRecord);
                isChanged = true;
                changes = this._addChange(bindingRecord, change, changes);
              }
              if (proto.lastInDirective) {
                if (isPresent(changes)) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onChange(changes);
                  changes = null;
                }
                if (isChanged && bindingRecord.isOnPushChangeDetection()) {
                  this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                }
                isChanged = false;
              }
            }
          },
          callOnAllChangesDone: function() {
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                this._getDirectiveFor(dir.directiveIndex).onAllChangesDone();
              }
            }
          },
          _updateDirectiveOrElement: function(change, bindingRecord) {
            if (isBlank(bindingRecord.directiveRecord)) {
              this.dispatcher.notifyOnBinding(bindingRecord, change.currentValue);
            } else {
              var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
              bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
            }
          },
          _addChange: function(bindingRecord, change, changes) {
            if (bindingRecord.callOnChange()) {
              return ChangeDetectionUtil.addChange(changes, bindingRecord.propertyName, change);
            } else {
              return changes;
            }
          },
          _getDirectiveFor: function(directiveIndex) {
            return this.directives.getDirectiveFor(directiveIndex);
          },
          _getDetectorFor: function(directiveIndex) {
            return this.directives.getDetectorFor(directiveIndex);
          },
          _check: function(proto) {
            try {
              if (proto.mode === RECORD_TYPE_PIPE || proto.mode === RECORD_TYPE_BINDING_PIPE) {
                return this._pipeCheck(proto);
              } else {
                return this._referenceCheck(proto);
              }
            } catch (e) {
              throw new ChangeDetectionError(proto, e);
            }
          },
          _referenceCheck: function(proto) {
            if (this._pureFuncAndArgsDidNotChange(proto)) {
              this._setChanged(proto, false);
              return null;
            }
            var prevValue = this._readSelf(proto);
            var currValue = this._calculateCurrValue(proto);
            if (!isSame(prevValue, currValue)) {
              this._writeSelf(proto, currValue);
              this._setChanged(proto, true);
              if (proto.lastInBinding) {
                return ChangeDetectionUtil.simpleChange(prevValue, currValue);
              } else {
                return null;
              }
            } else {
              this._setChanged(proto, false);
              return null;
            }
          },
          _calculateCurrValue: function(proto) {
            switch (proto.mode) {
              case RECORD_TYPE_SELF:
                return this._readContext(proto);
              case RECORD_TYPE_CONST:
                return proto.funcOrValue;
              case RECORD_TYPE_PROPERTY:
                var context = this._readContext(proto);
                return proto.funcOrValue(context);
              case RECORD_TYPE_LOCAL:
                return this.locals.get(proto.name);
              case RECORD_TYPE_INVOKE_METHOD:
                var context = this._readContext(proto);
                var args = this._readArgs(proto);
                return proto.funcOrValue(context, args);
              case RECORD_TYPE_KEYED_ACCESS:
                var arg = this._readArgs(proto)[0];
                return this._readContext(proto)[arg];
              case RECORD_TYPE_INVOKE_CLOSURE:
                return FunctionWrapper.apply(this._readContext(proto), this._readArgs(proto));
              case RECORD_TYPE_INTERPOLATE:
              case RECORD_TYPE_PRIMITIVE_OP:
                return FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto));
              default:
                throw new BaseException(("Unknown operation " + proto.mode));
            }
          },
          _pipeCheck: function(proto) {
            var context = this._readContext(proto);
            var pipe = this._pipeFor(proto, context);
            var prevValue = this._readSelf(proto);
            var newValue = pipe.transform(context);
            if (!isSame(prevValue, newValue)) {
              newValue = ChangeDetectionUtil.unwrapValue(newValue);
              this._writeSelf(proto, newValue);
              this._setChanged(proto, true);
              if (proto.lastInBinding) {
                return ChangeDetectionUtil.simpleChange(prevValue, newValue);
              } else {
                return null;
              }
            } else {
              this._setChanged(proto, false);
              return null;
            }
          },
          _pipeFor: function(proto, context) {
            var storedPipe = this._readPipe(proto);
            if (isPresent(storedPipe) && storedPipe.supports(context)) {
              return storedPipe;
            }
            if (isPresent(storedPipe)) {
              storedPipe.onDestroy();
            }
            var cdr = proto.mode === RECORD_TYPE_BINDING_PIPE ? this.ref : null;
            var pipe = this.pipeRegistry.get(proto.name, context, cdr);
            this._writePipe(proto, pipe);
            return pipe;
          },
          _readContext: function(proto) {
            if (proto.contextIndex == -1) {
              return this._getDirectiveFor(proto.directiveIndex);
            } else {
              return this.values[proto.contextIndex];
            }
            return this.values[proto.contextIndex];
          },
          _readSelf: function(proto) {
            return this.values[proto.selfIndex];
          },
          _writeSelf: function(proto, value) {
            this.values[proto.selfIndex] = value;
          },
          _readPipe: function(proto) {
            return this.pipes[proto.selfIndex];
          },
          _writePipe: function(proto, value) {
            this.pipes[proto.selfIndex] = value;
          },
          _setChanged: function(proto, value) {
            this.changes[proto.selfIndex] = value;
          },
          _pureFuncAndArgsDidNotChange: function(proto) {
            return proto.isPureFunction() && !this._argsChanged(proto);
          },
          _argsChanged: function(proto) {
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              if (this.changes[args[i]]) {
                return true;
              }
            }
            return false;
          },
          _readArgs: function(proto) {
            var res = ListWrapper.createFixedSize(proto.args.length);
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              res[i] = this.values[args[i]];
            }
            return res;
          }
        }, {}, $__super);
      }(AbstractChangeDetector));
      $__export("DynamicChangeDetector", DynamicChangeDetector);
      Object.defineProperty(DynamicChangeDetector, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.any], [PipeRegistry], [assert.genericType(List, ProtoRecord)], [List]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype.hydrate, "parameters", {get: function() {
          return [[assert.type.any], [assert.type.any], [assert.type.any]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype.detectChangesInRecords, "parameters", {get: function() {
          return [[assert.type.boolean]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._addChange, "parameters", {get: function() {
          return [[BindingRecord], [], []];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._check, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._referenceCheck, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._calculateCurrValue, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._pipeCheck, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._pipeFor, "parameters", {get: function() {
          return [[ProtoRecord], []];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._readContext, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._readSelf, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._writeSelf, "parameters", {get: function() {
          return [[ProtoRecord], []];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._readPipe, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._writePipe, "parameters", {get: function() {
          return [[ProtoRecord], []];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._setChanged, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.boolean]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._argsChanged, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
      Object.defineProperty(DynamicChangeDetector.prototype._readArgs, "parameters", {get: function() {
          return [[ProtoRecord]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/view", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/render/dom/view/view_container", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/shadow_dom/light_dom", "angular2/src/render/dom/shadow_dom/content_tag"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view";
  var DOM,
      ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      int,
      isPresent,
      isBlank,
      BaseException,
      ViewContainer,
      RenderProtoView,
      LightDom,
      Content,
      NG_BINDING_CLASS,
      RenderView;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      int = $__m.int;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ViewContainer = $__m.ViewContainer;
    }, function($__m) {
      RenderProtoView = $__m.RenderProtoView;
    }, function($__m) {
      LightDom = $__m.LightDom;
    }, function($__m) {
      Content = $__m.Content;
    }],
    execute: function() {
      NG_BINDING_CLASS = 'ng-binding';
      RenderView = (function() {
        function RenderView(proto, rootNodes, boundTextNodes, boundElements, contentTags) {
          this.proto = proto;
          this.rootNodes = rootNodes;
          this.boundTextNodes = boundTextNodes;
          this.boundElements = boundElements;
          this.viewContainers = ListWrapper.createFixedSize(boundElements.length);
          this.contentTags = contentTags;
          this.lightDoms = ListWrapper.createFixedSize(boundElements.length);
          ListWrapper.fill(this.lightDoms, null);
          this.componentChildViews = ListWrapper.createFixedSize(boundElements.length);
          this.hostLightDom = null;
          this.hydrated = false;
          this.eventHandlerRemovers = [];
          this.imperativeHostViews = [];
        }
        return ($traceurRuntime.createClass)(RenderView, {
          getDirectParentLightDom: function(boundElementIndex) {
            var binder = this.proto.elementBinders[boundElementIndex];
            var destLightDom = null;
            if (binder.parentIndex !== -1 && binder.distanceToParent === 1) {
              destLightDom = this.lightDoms[binder.parentIndex];
            }
            return destLightDom;
          },
          getOrCreateViewContainer: function(binderIndex) {
            var vc = this.viewContainers[binderIndex];
            if (isBlank(vc)) {
              vc = new ViewContainer(this, binderIndex);
              this.viewContainers[binderIndex] = vc;
            }
            return vc;
          },
          setElementProperty: function(elementIndex, propertyName, value) {
            var setter = MapWrapper.get(this.proto.elementBinders[elementIndex].propertySetters, propertyName);
            setter(this.boundElements[elementIndex], value);
          },
          setText: function(textIndex, value) {
            DOM.setText(this.boundTextNodes[textIndex], value);
          },
          getViewContainer: function(index) {
            return this.viewContainers[index];
          },
          setEventDispatcher: function(dispatcher) {
            this._eventDispatcher = dispatcher;
          },
          dispatchEvent: function(elementIndex, eventName, event) {
            var allowDefaultBehavior = true;
            if (isPresent(this._eventDispatcher)) {
              var evalLocals = MapWrapper.create();
              MapWrapper.set(evalLocals, '$event', event);
              allowDefaultBehavior = this._eventDispatcher.dispatchEvent(elementIndex, eventName, evalLocals);
              if (!allowDefaultBehavior) {
                event.preventDefault();
              }
            }
            return allowDefaultBehavior;
          }
        }, {});
      }());
      $__export("RenderView", RenderView);
      Object.defineProperty(RenderView, "parameters", {get: function() {
          return [[RenderProtoView], [List], [List], [List], [List]];
        }});
      Object.defineProperty(RenderView.prototype.getDirectParentLightDom, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(RenderView.prototype.setElementProperty, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(RenderView.prototype.setText, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string]];
        }});
      Object.defineProperty(RenderView.prototype.getViewContainer, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(RenderView.prototype.setEventDispatcher, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/view/view_factory", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/shadow_dom/content_tag", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/view", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view_factory";
  var OpaqueToken,
      Inject,
      Injectable,
      int,
      isPresent,
      isBlank,
      BaseException,
      ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      DOM,
      Content,
      ShadowDomStrategy,
      EventManager,
      pvModule,
      viewModule,
      NG_BINDING_CLASS_SELECTOR,
      NG_BINDING_CLASS,
      VIEW_POOL_CAPACITY,
      ViewFactory;
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
    }, function($__m) {
      int = $__m.int;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Content = $__m.Content;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }, function($__m) {
      EventManager = $__m.EventManager;
    }, function($__m) {
      pvModule = $__m;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      NG_BINDING_CLASS_SELECTOR = $__m.NG_BINDING_CLASS_SELECTOR;
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
    }],
    execute: function() {
      VIEW_POOL_CAPACITY = 'render.ViewFactory.viewPoolCapacity';
      $__export("VIEW_POOL_CAPACITY", VIEW_POOL_CAPACITY);
      ViewFactory = (function() {
        function ViewFactory(poolCapacityPerProtoView, eventManager, shadowDomStrategy) {
          this._poolCapacityPerProtoView = poolCapacityPerProtoView;
          this._pooledViewsPerProtoView = MapWrapper.create();
          this._eventManager = eventManager;
          this._shadowDomStrategy = shadowDomStrategy;
        }
        return ($traceurRuntime.createClass)(ViewFactory, {
          createInPlaceHostView: function(hostElementSelector, hostProtoView) {
            return this._createView(hostProtoView, hostElementSelector);
          },
          getView: function(protoView) {
            var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
            if (isPresent(pooledViews) && pooledViews.length > 0) {
              return ListWrapper.removeLast(pooledViews);
            }
            return this._createView(protoView, null);
          },
          returnView: function(view) {
            if (view.hydrated) {
              throw new BaseException('View is still hydrated');
            }
            var protoView = view.proto;
            var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
            if (isBlank(pooledViews)) {
              pooledViews = [];
              MapWrapper.set(this._pooledViewsPerProtoView, protoView, pooledViews);
            }
            if (pooledViews.length < this._poolCapacityPerProtoView) {
              ListWrapper.push(pooledViews, view);
            }
          },
          _createView: function(protoView, inplaceElement) {
            if (isPresent(protoView.imperativeRendererId)) {
              return new viewModule.RenderView(protoView, [], [], [], []);
            }
            var rootElementClone = isPresent(inplaceElement) ? inplaceElement : DOM.importIntoDoc(protoView.element);
            var elementsWithBindingsDynamic;
            if (protoView.isTemplateElement) {
              elementsWithBindingsDynamic = DOM.querySelectorAll(DOM.content(rootElementClone), NG_BINDING_CLASS_SELECTOR);
            } else {
              elementsWithBindingsDynamic = DOM.getElementsByClassName(rootElementClone, NG_BINDING_CLASS);
            }
            var elementsWithBindings = ListWrapper.createFixedSize(elementsWithBindingsDynamic.length);
            for (var binderIdx = 0; binderIdx < elementsWithBindingsDynamic.length; ++binderIdx) {
              elementsWithBindings[binderIdx] = elementsWithBindingsDynamic[binderIdx];
            }
            var viewRootNodes;
            if (protoView.isTemplateElement) {
              var childNode = DOM.firstChild(DOM.content(rootElementClone));
              viewRootNodes = [];
              while (childNode != null) {
                ListWrapper.push(viewRootNodes, childNode);
                childNode = DOM.nextSibling(childNode);
              }
            } else {
              viewRootNodes = [rootElementClone];
            }
            var binders = protoView.elementBinders;
            var boundTextNodes = [];
            var boundElements = ListWrapper.createFixedSize(binders.length);
            var contentTags = ListWrapper.createFixedSize(binders.length);
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              var element = void 0;
              if (binderIdx === 0 && protoView.rootBindingOffset === 1) {
                element = rootElementClone;
              } else {
                element = elementsWithBindings[binderIdx - protoView.rootBindingOffset];
              }
              boundElements[binderIdx] = element;
              var childNodes = DOM.childNodes(DOM.templateAwareRoot(element));
              var textNodeIndices = binder.textNodeIndices;
              for (var i = 0; i < textNodeIndices.length; i++) {
                ListWrapper.push(boundTextNodes, childNodes[textNodeIndices[i]]);
              }
              var contentTag = null;
              if (isPresent(binder.contentTagSelector)) {
                contentTag = new Content(element, binder.contentTagSelector);
              }
              contentTags[binderIdx] = contentTag;
            }
            var view = new viewModule.RenderView(protoView, viewRootNodes, boundTextNodes, boundElements, contentTags);
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              var element = boundElements[binderIdx];
              if (binder.hasStaticComponent()) {
                var childView = this._createView(binder.nestedProtoView, null);
                ViewFactory.setComponentView(this._shadowDomStrategy, view, binderIdx, childView);
              }
              if (isPresent(binder.eventLocals) && isPresent(binder.localEvents)) {
                for (var i = 0; i < binder.localEvents.length; i++) {
                  this._createEventListener(view, element, binderIdx, binder.localEvents[i].name, binder.eventLocals);
                }
              }
            }
            return view;
          },
          _createEventListener: function(view, element, elementIndex, eventName, eventLocals) {
            this._eventManager.addEventListener(element, eventName, (function(event) {
              view.dispatchEvent(elementIndex, eventName, event);
            }));
          }
        }, {setComponentView: function(shadowDomStrategy, hostView, elementIndex, componentView) {
            var element = hostView.boundElements[elementIndex];
            var lightDom = shadowDomStrategy.constructLightDom(hostView, componentView, element);
            shadowDomStrategy.attachTemplate(element, componentView);
            hostView.lightDoms[elementIndex] = lightDom;
            hostView.componentChildViews[elementIndex] = componentView;
          }});
      }());
      $__export("ViewFactory", ViewFactory);
      Object.defineProperty(ViewFactory, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(ViewFactory, "parameters", {get: function() {
          return [[new Inject(VIEW_POOL_CAPACITY)], [EventManager], [ShadowDomStrategy]];
        }});
      Object.defineProperty(ViewFactory.prototype.createInPlaceHostView, "parameters", {get: function() {
          return [[], [pvModule.RenderProtoView]];
        }});
      Object.defineProperty(ViewFactory.prototype.getView, "parameters", {get: function() {
          return [[pvModule.RenderProtoView]];
        }});
      Object.defineProperty(ViewFactory.prototype.returnView, "parameters", {get: function() {
          return [[viewModule.RenderView]];
        }});
      Object.defineProperty(ViewFactory.prototype._createView, "parameters", {get: function() {
          return [[pvModule.RenderProtoView], []];
        }});
      Object.defineProperty(ViewFactory.setComponentView, "parameters", {get: function() {
          return [[ShadowDomStrategy], [viewModule.RenderView], [assert.type.number], [viewModule.RenderView]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_element", ["angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/render/dom/view/proto_view_builder"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_element";
  var List,
      Map,
      ListWrapper,
      MapWrapper,
      DOM,
      int,
      isBlank,
      isPresent,
      Type,
      StringJoiner,
      assertionsEnabled,
      ProtoViewBuilder,
      ElementBinderBuilder,
      CompileElement;
  function getElementDescription(domElement) {
    var buf = new StringJoiner();
    var atts = DOM.attributeMap(domElement);
    buf.add("<");
    buf.add(DOM.tagName(domElement).toLowerCase());
    addDescriptionAttribute(buf, "id", MapWrapper.get(atts, "id"));
    addDescriptionAttribute(buf, "class", MapWrapper.get(atts, "class"));
    MapWrapper.forEach(atts, (function(attValue, attName) {
      if (attName !== "id" && attName !== "class") {
        addDescriptionAttribute(buf, attName, attValue);
      }
    }));
    buf.add(">");
    return buf.toString();
  }
  function addDescriptionAttribute(buffer, attName, attValue) {
    if (isPresent(attValue)) {
      if (attValue.length === 0) {
        buffer.add(' ' + attName);
      } else {
        buffer.add(' ' + attName + '="' + attValue + '"');
      }
    }
  }
  return {
    setters: [function($__m) {
      List = $__m.List;
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      int = $__m.int;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      Type = $__m.Type;
      StringJoiner = $__m.StringJoiner;
      assertionsEnabled = $__m.assertionsEnabled;
    }, function($__m) {
      ProtoViewBuilder = $__m.ProtoViewBuilder;
      ElementBinderBuilder = $__m.ElementBinderBuilder;
    }],
    execute: function() {
      CompileElement = (function() {
        function CompileElement(element) {
          var compilationUnit = arguments[1] !== (void 0) ? arguments[1] : '';
          this.element = element;
          this._attrs = null;
          this._classList = null;
          this.isViewRoot = false;
          this.inheritedProtoView = null;
          this.inheritedElementBinder = null;
          this.distanceToInheritedBinder = 0;
          this.compileChildren = true;
          var tplDesc = assertionsEnabled() ? getElementDescription(element) : null;
          if (compilationUnit !== '') {
            this.elementDescription = compilationUnit;
            if (isPresent(tplDesc))
              this.elementDescription += ": " + tplDesc;
          } else {
            this.elementDescription = tplDesc;
          }
        }
        return ($traceurRuntime.createClass)(CompileElement, {
          isBound: function() {
            return isPresent(this.inheritedElementBinder) && this.distanceToInheritedBinder === 0;
          },
          bindElement: function() {
            if (!this.isBound()) {
              var parentBinder = this.inheritedElementBinder;
              this.inheritedElementBinder = this.inheritedProtoView.bindElement(this.element, this.elementDescription);
              if (isPresent(parentBinder)) {
                this.inheritedElementBinder.setParent(parentBinder, this.distanceToInheritedBinder);
              }
              this.distanceToInheritedBinder = 0;
            }
            return this.inheritedElementBinder;
          },
          refreshAttrs: function() {
            this._attrs = null;
          },
          attrs: function() {
            if (isBlank(this._attrs)) {
              this._attrs = DOM.attributeMap(this.element);
            }
            return this._attrs;
          },
          refreshClassList: function() {
            this._classList = null;
          },
          classList: function() {
            if (isBlank(this._classList)) {
              this._classList = ListWrapper.create();
              var elClassList = DOM.classList(this.element);
              for (var i = 0; i < elClassList.length; i++) {
                ListWrapper.push(this._classList, elClassList[i]);
              }
            }
            return this._classList;
          }
        }, {});
      }());
      $__export("CompileElement", CompileElement);
      Object.defineProperty(addDescriptionAttribute, "parameters", {get: function() {
          return [[StringJoiner], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_step_factory", ["angular2/src/facade/collection", "angular2/src/facade/async", "angular2/change_detection", "angular2/src/render/api", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/compiler/property_binding_parser", "angular2/src/render/dom/compiler/text_interpolation_parser", "angular2/src/render/dom/compiler/directive_parser", "angular2/src/render/dom/compiler/view_splitter", "angular2/src/render/dom/shadow_dom/shadow_dom_compile_step", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_step_factory";
  var List,
      Promise,
      Parser,
      ViewDefinition,
      CompileStep,
      PropertyBindingParser,
      TextInterpolationParser,
      DirectiveParser,
      ViewSplitter,
      ShadowDomCompileStep,
      ShadowDomStrategy,
      CompileStepFactory,
      DefaultStepFactory;
  return {
    setters: [function($__m) {
      List = $__m.List;
    }, function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      PropertyBindingParser = $__m.PropertyBindingParser;
    }, function($__m) {
      TextInterpolationParser = $__m.TextInterpolationParser;
    }, function($__m) {
      DirectiveParser = $__m.DirectiveParser;
    }, function($__m) {
      ViewSplitter = $__m.ViewSplitter;
    }, function($__m) {
      ShadowDomCompileStep = $__m.ShadowDomCompileStep;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }],
    execute: function() {
      CompileStepFactory = (function() {
        function CompileStepFactory() {}
        return ($traceurRuntime.createClass)(CompileStepFactory, {createSteps: function(template, subTaskPromises) {
            return null;
          }}, {});
      }());
      $__export("CompileStepFactory", CompileStepFactory);
      Object.defineProperty(CompileStepFactory.prototype.createSteps, "parameters", {get: function() {
          return [[ViewDefinition], [assert.genericType(List, Promise)]];
        }});
      DefaultStepFactory = (function($__super) {
        function DefaultStepFactory(parser, shadowDomStrategy) {
          $traceurRuntime.superConstructor(DefaultStepFactory).call(this);
          this._parser = parser;
          this._shadowDomStrategy = shadowDomStrategy;
        }
        return ($traceurRuntime.createClass)(DefaultStepFactory, {createSteps: function(template, subTaskPromises) {
            return [new ViewSplitter(this._parser), new PropertyBindingParser(this._parser), new DirectiveParser(this._parser, template.directives), new TextInterpolationParser(this._parser), new ShadowDomCompileStep(this._shadowDomStrategy, template, subTaskPromises)];
          }}, {}, $__super);
      }(CompileStepFactory));
      $__export("DefaultStepFactory", DefaultStepFactory);
      Object.defineProperty(DefaultStepFactory, "parameters", {get: function() {
          return [[Parser], []];
        }});
      Object.defineProperty(DefaultStepFactory.prototype.createSteps, "parameters", {get: function() {
          return [[ViewDefinition], [assert.genericType(List, Promise)]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy", ["angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/view/view", "angular2/src/render/dom/shadow_dom/light_dom", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/render/dom/shadow_dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy";
  var Promise,
      DOM,
      viewModule,
      LightDom,
      ShadowDomStrategy,
      StyleUrlResolver,
      moveViewNodesIntoParent,
      insertSharedStyleText,
      EmulatedUnscopedShadowDomStrategy;
  return {
    setters: [function($__m) {
      Promise = $__m.Promise;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      LightDom = $__m.LightDom;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      moveViewNodesIntoParent = $__m.moveViewNodesIntoParent;
      insertSharedStyleText = $__m.insertSharedStyleText;
    }],
    execute: function() {
      EmulatedUnscopedShadowDomStrategy = (function($__super) {
        function EmulatedUnscopedShadowDomStrategy(styleUrlResolver, styleHost) {
          $traceurRuntime.superConstructor(EmulatedUnscopedShadowDomStrategy).call(this);
          this.styleUrlResolver = styleUrlResolver;
          this.styleHost = styleHost;
        }
        return ($traceurRuntime.createClass)(EmulatedUnscopedShadowDomStrategy, {
          hasNativeContentElement: function() {
            return false;
          },
          attachTemplate: function(el, view) {
            moveViewNodesIntoParent(el, view);
          },
          constructLightDom: function(lightDomView, shadowDomView, el) {
            return new LightDom(lightDomView, shadowDomView, el);
          },
          processStyleElement: function(hostComponentId, templateUrl, styleEl) {
            var cssText = DOM.getText(styleEl);
            cssText = this.styleUrlResolver.resolveUrls(cssText, templateUrl);
            DOM.setText(styleEl, cssText);
            DOM.remove(styleEl);
            insertSharedStyleText(cssText, this.styleHost, styleEl);
            return null;
          }
        }, {}, $__super);
      }(ShadowDomStrategy));
      $__export("EmulatedUnscopedShadowDomStrategy", EmulatedUnscopedShadowDomStrategy);
      Object.defineProperty(EmulatedUnscopedShadowDomStrategy, "parameters", {get: function() {
          return [[StyleUrlResolver], []];
        }});
      Object.defineProperty(EmulatedUnscopedShadowDomStrategy.prototype.attachTemplate, "parameters", {get: function() {
          return [[], [viewModule.RenderView]];
        }});
      Object.defineProperty(EmulatedUnscopedShadowDomStrategy.prototype.constructLightDom, "parameters", {get: function() {
          return [[viewModule.RenderView], [viewModule.RenderView], []];
        }});
      Object.defineProperty(EmulatedUnscopedShadowDomStrategy.prototype.processStyleElement, "parameters", {get: function() {
          return [[assert.type.string], [assert.type.string], []];
        }});
    }
  };
});

System.register("angular2/forms", ["angular2/src/forms/model", "angular2/src/forms/directives", "angular2/src/forms/validators", "angular2/src/forms/validator_directives", "angular2/src/forms/form_builder"], function($__export) {
  "use strict";
  var __moduleName = "angular2/forms";
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("src/rules-engine/api/RuleEngineTypes.es6", ["npm:debug@2.2.0", "src/dc/index.es6", "src/entity-forge/EntityForge.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/api/RuleEngineTypes.es6";
  var XDebug,
      log,
      Core,
      EF,
      ValidationError,
      defaultSiteId,
      objFn,
      RuleDefinition,
      Rule;
  return {
    setters: [function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      Core = $__m.Core;
    }, function($__m) {
      EF = $__m.EntityForge;
      ValidationError = $__m.ValidationError;
    }],
    execute: function() {
      log = XDebug('RulesEngine.api');
      defaultSiteId = '48190c8c-42c4-46af-8d1a-0cd5db894797';
      objFn = (function() {
        return {};
      });
      RuleDefinition = {
        $key: EF.string(),
        name: EF.string().minLength(5).maxLength(100),
        enabled: EF.bool(true),
        site: EF.string().minLength(36).maxLength(36),
        priority: EF.int(0).min(0).max(100),
        fireOn: EF.enum().values(['EVERY_PAGE', 'ONCE_PER_VISIT', 'ONCE_PER_VISITOR', 'EVERY_REQUEST']).initTo(0),
        folder: EF.string().minLength(5).maxLength(250),
        shortCircuit: EF.bool(true),
        groups: EF.obj('groups', {
          operator: EF.enum().values(['AND', 'OR']),
          priority: EF.int(0).min(0).max(100)
        }),
        actions: EF.any()
      };
      Rule = EF.obj('Rule', RuleDefinition).asNewable();
      $__export("Rule", Rule);
    }
  };
});

System.register("src/dc/index.es6", ["src/dc/api/Core.ts", "src/dc/api/Check.ts"], function($__export) {
  "use strict";
  var __moduleName = "src/dc/index.es6";
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("angular2/src/di/binding", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection", "angular2/src/di/key", "angular2/src/di/annotations", "angular2/src/di/exceptions"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/binding";
  var Type,
      isBlank,
      isPresent,
      CONST,
      List,
      MapWrapper,
      ListWrapper,
      reflector,
      Key,
      Inject,
      InjectLazy,
      InjectPromise,
      Optional,
      DependencyAnnotation,
      NoAnnotationError,
      Dependency,
      _EMPTY_LIST,
      Binding,
      ResolvedBinding,
      BindingBuilder;
  function bind(token) {
    return new BindingBuilder(token);
  }
  function _constructDependencies(factoryFunction, dependencies) {
    return isBlank(dependencies) ? _dependenciesFor(factoryFunction) : ListWrapper.map(dependencies, (function(t) {
      return Dependency.fromKey(Key.get(t));
    }));
  }
  function _dependenciesFor(typeOrFunc) {
    var params = reflector.parameters(typeOrFunc);
    if (isBlank(params))
      return [];
    if (ListWrapper.any(params, (function(p) {
      return isBlank(p);
    })))
      throw new NoAnnotationError(typeOrFunc);
    return ListWrapper.map(params, (function(p) {
      return _extractToken(typeOrFunc, p);
    }));
  }
  function _extractToken(typeOrFunc, annotations) {
    var depProps = [];
    var token = null;
    var optional = false;
    var lazy = false;
    var asPromise = false;
    for (var i = 0; i < annotations.length; ++i) {
      var paramAnnotation = annotations[i];
      if (paramAnnotation instanceof Type) {
        token = paramAnnotation;
      } else if (paramAnnotation instanceof Inject) {
        token = paramAnnotation.token;
      } else if (paramAnnotation instanceof InjectPromise) {
        token = paramAnnotation.token;
        asPromise = true;
      } else if (paramAnnotation instanceof InjectLazy) {
        token = paramAnnotation.token;
        lazy = true;
      } else if (paramAnnotation instanceof Optional) {
        optional = true;
      } else if (paramAnnotation instanceof DependencyAnnotation) {
        if (isPresent(paramAnnotation.token)) {
          token = paramAnnotation.token;
        }
        ListWrapper.push(depProps, paramAnnotation);
      }
    }
    if (isPresent(token)) {
      return _createDependency(token, asPromise, lazy, optional, depProps);
    } else {
      throw new NoAnnotationError(typeOrFunc);
    }
  }
  function _createDependency(token, asPromise, lazy, optional, depProps) {
    return new Dependency(Key.get(token), asPromise, lazy, optional, depProps);
  }
  $__export("bind", bind);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      CONST = $__m.CONST;
    }, function($__m) {
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      Key = $__m.Key;
    }, function($__m) {
      Inject = $__m.Inject;
      InjectLazy = $__m.InjectLazy;
      InjectPromise = $__m.InjectPromise;
      Optional = $__m.Optional;
      DependencyAnnotation = $__m.DependencyAnnotation;
    }, function($__m) {
      NoAnnotationError = $__m.NoAnnotationError;
    }],
    execute: function() {
      Dependency = (function() {
        function Dependency(key, asPromise, lazy, optional, properties) {
          this.key = key;
          this.asPromise = asPromise;
          this.lazy = lazy;
          this.optional = optional;
          this.properties = properties;
        }
        return ($traceurRuntime.createClass)(Dependency, {}, {fromKey: function(key) {
            return new Dependency(key, false, false, false, []);
          }});
      }());
      $__export("Dependency", Dependency);
      Object.defineProperty(Dependency, "parameters", {get: function() {
          return [[Key], [assert.type.boolean], [assert.type.boolean], [assert.type.boolean], [List]];
        }});
      Object.defineProperty(Dependency.fromKey, "parameters", {get: function() {
          return [[Key]];
        }});
      _EMPTY_LIST = [];
      Binding = (function() {
        function Binding(token, $__2) {
          var $__3 = $__2,
              toClass = $__3.toClass,
              toValue = $__3.toValue,
              toAlias = $__3.toAlias,
              toFactory = $__3.toFactory,
              toAsyncFactory = $__3.toAsyncFactory,
              deps = $__3.deps;
          this.token = token;
          this.toClass = toClass;
          this.toValue = toValue;
          this.toAlias = toAlias;
          this.toFactory = toFactory;
          this.toAsyncFactory = toAsyncFactory;
          this.dependencies = deps;
        }
        return ($traceurRuntime.createClass)(Binding, {resolve: function() {
            var $__0 = this;
            var factoryFn;
            var resolvedDeps;
            var isAsync = false;
            if (isPresent(this.toClass)) {
              factoryFn = reflector.factory(this.toClass);
              resolvedDeps = _dependenciesFor(this.toClass);
            } else if (isPresent(this.toAlias)) {
              factoryFn = (function(aliasInstance) {
                return aliasInstance;
              });
              resolvedDeps = [Dependency.fromKey(Key.get(this.toAlias))];
            } else if (isPresent(this.toFactory)) {
              factoryFn = this.toFactory;
              resolvedDeps = _constructDependencies(this.toFactory, this.dependencies);
            } else if (isPresent(this.toAsyncFactory)) {
              factoryFn = this.toAsyncFactory;
              resolvedDeps = _constructDependencies(this.toAsyncFactory, this.dependencies);
              isAsync = true;
            } else {
              factoryFn = (function() {
                return $__0.toValue;
              });
              resolvedDeps = _EMPTY_LIST;
            }
            return new ResolvedBinding(Key.get(this.token), factoryFn, resolvedDeps, isAsync);
          }}, {});
      }());
      $__export("Binding", Binding);
      Object.defineProperty(Binding, "annotations", {get: function() {
          return [new CONST()];
        }});
      ResolvedBinding = (function() {
        function ResolvedBinding(key, factory, dependencies, providedAsPromise) {
          this.key = key;
          this.factory = factory;
          this.dependencies = dependencies;
          this.providedAsPromise = providedAsPromise;
        }
        return ($traceurRuntime.createClass)(ResolvedBinding, {}, {});
      }());
      $__export("ResolvedBinding", ResolvedBinding);
      Object.defineProperty(ResolvedBinding, "parameters", {get: function() {
          return [[Key], [Function], [assert.genericType(List, Dependency)], [assert.type.boolean]];
        }});
      BindingBuilder = (function() {
        function BindingBuilder(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(BindingBuilder, {
          toClass: function(type) {
            return new Binding(this.token, {toClass: type});
          },
          toValue: function(value) {
            return new Binding(this.token, {toValue: value});
          },
          toAlias: function(aliasToken) {
            return new Binding(this.token, {toAlias: aliasToken});
          },
          toFactory: function(factoryFunction) {
            var dependencies = arguments[1] !== (void 0) ? arguments[1] : null;
            return new Binding(this.token, {
              toFactory: factoryFunction,
              deps: dependencies
            });
          },
          toAsyncFactory: function(factoryFunction) {
            var dependencies = arguments[1] !== (void 0) ? arguments[1] : null;
            return new Binding(this.token, {
              toAsyncFactory: factoryFunction,
              deps: dependencies
            });
          }
        }, {});
      }());
      $__export("BindingBuilder", BindingBuilder);
      Object.defineProperty(BindingBuilder.prototype.toClass, "parameters", {get: function() {
          return [[Type]];
        }});
      Object.defineProperty(BindingBuilder.prototype.toFactory, "parameters", {get: function() {
          return [[Function], [List]];
        }});
      Object.defineProperty(BindingBuilder.prototype.toAsyncFactory, "parameters", {get: function() {
          return [[Function], [List]];
        }});
      Object.defineProperty(_constructDependencies, "parameters", {get: function() {
          return [[Function], [List]];
        }});
    }
  };
});

System.register("angular2/src/facade/async", ["angular2/src/facade/lang", "npm:rx@2.5.3"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/async";
  var __esModule,
      global,
      Rx,
      PromiseWrapper,
      ObservableWrapper,
      Observable,
      EventEmitter;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }, function($__m) {
      Rx = $__m;
    }],
    execute: function() {
      __esModule = true;
      $__export("__esModule", __esModule);
      PromiseWrapper = (function() {
        function PromiseWrapper() {}
        return ($traceurRuntime.createClass)(PromiseWrapper, {}, {
          resolve: function(obj) {
            return Promise.resolve(obj);
          },
          reject: function(obj) {
            return Promise.reject(obj);
          },
          catchError: function(promise, onError) {
            return promise.catch(onError);
          },
          all: function(promises) {
            if (promises.length == 0)
              return Promise.resolve([]);
            return Promise.all(promises);
          },
          then: function(promise, success, rejection) {
            return promise.then(success, rejection);
          },
          completer: function() {
            var resolve;
            var reject;
            var p = new Promise(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            return {
              promise: p,
              resolve: resolve,
              reject: reject
            };
          },
          setTimeout: function(fn, millis) {
            global.setTimeout(fn, millis);
          },
          isPromise: function(maybePromise) {
            return maybePromise instanceof Promise;
          }
        });
      }());
      $__export("PromiseWrapper", PromiseWrapper);
      ObservableWrapper = (function() {
        function ObservableWrapper() {}
        return ($traceurRuntime.createClass)(ObservableWrapper, {}, {
          subscribe: function(emitter, onNext) {
            var onThrow = arguments[2] !== (void 0) ? arguments[2] : null;
            var onReturn = arguments[3] !== (void 0) ? arguments[3] : null;
            return emitter.observer({
              next: onNext,
              throw: onThrow,
              return: onReturn
            });
          },
          isObservable: function(obs) {
            return obs instanceof Observable;
          },
          dispose: function(subscription) {
            subscription.dispose();
          },
          callNext: function(emitter, value) {
            emitter.next(value);
          },
          callThrow: function(emitter, error) {
            emitter.throw(error);
          },
          callReturn: function(emitter) {
            emitter.return(null);
          }
        });
      }());
      $__export("ObservableWrapper", ObservableWrapper);
      Observable = (function() {
        function Observable() {}
        return ($traceurRuntime.createClass)(Observable, {observer: function(generator) {}}, {});
      }());
      $__export("Observable", Observable);
      EventEmitter = (function($__super) {
        function EventEmitter() {
          $traceurRuntime.superConstructor(EventEmitter).call(this);
          if (Rx.hasOwnProperty('default')) {
            this._subject = new Rx.default.Rx.Subject();
            this._immediateScheduler = Rx.default.Rx.Scheduler.immediate;
          } else {
            this._subject = new Rx.Subject();
            this._immediateScheduler = Rx.Scheduler.immediate;
          }
        }
        return ($traceurRuntime.createClass)(EventEmitter, {
          observer: function(generator) {
            return this._subject.observeOn(this._immediateScheduler).subscribe((function(value) {
              setTimeout((function() {
                return generator.next(value);
              }));
            }), (function(error) {
              return generator.throw ? generator.throw(error) : null;
            }), (function() {
              return generator.return ? generator.return() : null;
            }));
          },
          toRx: function() {
            return this._subject;
          },
          next: function(value) {
            this._subject.onNext(value);
          },
          throw: function(error) {
            this._subject.onError(error);
          },
          return: function(value) {
            this._subject.onCompleted();
          }
        }, {}, $__super);
      }(Observable));
      $__export("EventEmitter", EventEmitter);
    }
  };
});

System.register("angular2/src/change_detection/proto_record", ["angular2/src/facade/collection", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_record";
  var List,
      BindingRecord,
      DirectiveIndex,
      RECORD_TYPE_SELF,
      RECORD_TYPE_CONST,
      RECORD_TYPE_PRIMITIVE_OP,
      RECORD_TYPE_PROPERTY,
      RECORD_TYPE_LOCAL,
      RECORD_TYPE_INVOKE_METHOD,
      RECORD_TYPE_INVOKE_CLOSURE,
      RECORD_TYPE_KEYED_ACCESS,
      RECORD_TYPE_PIPE,
      RECORD_TYPE_BINDING_PIPE,
      RECORD_TYPE_INTERPOLATE,
      ProtoRecord;
  return {
    setters: [function($__m) {
      List = $__m.List;
    }, function($__m) {
      BindingRecord = $__m.BindingRecord;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
    }],
    execute: function() {
      RECORD_TYPE_SELF = 0;
      $__export("RECORD_TYPE_SELF", RECORD_TYPE_SELF);
      RECORD_TYPE_CONST = 1;
      $__export("RECORD_TYPE_CONST", RECORD_TYPE_CONST);
      RECORD_TYPE_PRIMITIVE_OP = 2;
      $__export("RECORD_TYPE_PRIMITIVE_OP", RECORD_TYPE_PRIMITIVE_OP);
      RECORD_TYPE_PROPERTY = 3;
      $__export("RECORD_TYPE_PROPERTY", RECORD_TYPE_PROPERTY);
      RECORD_TYPE_LOCAL = 4;
      $__export("RECORD_TYPE_LOCAL", RECORD_TYPE_LOCAL);
      RECORD_TYPE_INVOKE_METHOD = 5;
      $__export("RECORD_TYPE_INVOKE_METHOD", RECORD_TYPE_INVOKE_METHOD);
      RECORD_TYPE_INVOKE_CLOSURE = 6;
      $__export("RECORD_TYPE_INVOKE_CLOSURE", RECORD_TYPE_INVOKE_CLOSURE);
      RECORD_TYPE_KEYED_ACCESS = 7;
      $__export("RECORD_TYPE_KEYED_ACCESS", RECORD_TYPE_KEYED_ACCESS);
      RECORD_TYPE_PIPE = 8;
      $__export("RECORD_TYPE_PIPE", RECORD_TYPE_PIPE);
      RECORD_TYPE_BINDING_PIPE = 9;
      $__export("RECORD_TYPE_BINDING_PIPE", RECORD_TYPE_BINDING_PIPE);
      RECORD_TYPE_INTERPOLATE = 10;
      $__export("RECORD_TYPE_INTERPOLATE", RECORD_TYPE_INTERPOLATE);
      ProtoRecord = (function() {
        function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, expressionAsString, lastInBinding, lastInDirective) {
          this.mode = mode;
          this.name = name;
          this.funcOrValue = funcOrValue;
          this.args = args;
          this.fixedArgs = fixedArgs;
          this.contextIndex = contextIndex;
          this.directiveIndex = directiveIndex;
          this.selfIndex = selfIndex;
          this.bindingRecord = bindingRecord;
          this.lastInBinding = lastInBinding;
          this.lastInDirective = lastInDirective;
          this.expressionAsString = expressionAsString;
        }
        return ($traceurRuntime.createClass)(ProtoRecord, {isPureFunction: function() {
            return this.mode === RECORD_TYPE_INTERPOLATE || this.mode === RECORD_TYPE_PRIMITIVE_OP;
          }}, {});
      }());
      $__export("ProtoRecord", ProtoRecord);
      Object.defineProperty(ProtoRecord, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [], [List], [List], [assert.type.number], [DirectiveIndex], [assert.type.number], [BindingRecord], [assert.type.string], [assert.type.boolean], [assert.type.boolean]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/proto_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/interfaces", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/change_detection_jit_generator", "angular2/src/change_detection/pipes/pipe_registry", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/coalesce", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_change_detector";
  var isPresent,
      isBlank,
      BaseException,
      Type,
      isString,
      List,
      ListWrapper,
      MapWrapper,
      StringMapWrapper,
      AccessMember,
      Assignment,
      AST,
      ASTWithSource,
      AstVisitor,
      Binary,
      Chain,
      Conditional,
      Pipe,
      FunctionCall,
      ImplicitReceiver,
      Interpolation,
      KeyedAccess,
      LiteralArray,
      LiteralMap,
      LiteralPrimitive,
      MethodCall,
      PrefixNot,
      ChangeDispatcher,
      ChangeDetector,
      ProtoChangeDetector,
      ChangeDetectionUtil,
      DynamicChangeDetector,
      ChangeDetectorJITGenerator,
      PipeRegistry,
      BindingRecord,
      DirectiveRecord,
      DirectiveIndex,
      coalesce,
      ProtoRecord,
      RECORD_TYPE_SELF,
      RECORD_TYPE_PROPERTY,
      RECORD_TYPE_LOCAL,
      RECORD_TYPE_INVOKE_METHOD,
      RECORD_TYPE_CONST,
      RECORD_TYPE_INVOKE_CLOSURE,
      RECORD_TYPE_PRIMITIVE_OP,
      RECORD_TYPE_KEYED_ACCESS,
      RECORD_TYPE_PIPE,
      RECORD_TYPE_BINDING_PIPE,
      RECORD_TYPE_INTERPOLATE,
      DynamicProtoChangeDetector,
      _jitProtoChangeDetectorClassCounter,
      JitProtoChangeDetector,
      ProtoRecordBuilder,
      _ConvertAstIntoProtoRecords;
  function _arrayFn(length) {
    switch (length) {
      case 0:
        return ChangeDetectionUtil.arrayFn0;
      case 1:
        return ChangeDetectionUtil.arrayFn1;
      case 2:
        return ChangeDetectionUtil.arrayFn2;
      case 3:
        return ChangeDetectionUtil.arrayFn3;
      case 4:
        return ChangeDetectionUtil.arrayFn4;
      case 5:
        return ChangeDetectionUtil.arrayFn5;
      case 6:
        return ChangeDetectionUtil.arrayFn6;
      case 7:
        return ChangeDetectionUtil.arrayFn7;
      case 8:
        return ChangeDetectionUtil.arrayFn8;
      case 9:
        return ChangeDetectionUtil.arrayFn9;
      default:
        throw new BaseException("Does not support literal maps with more than 9 elements");
    }
  }
  function _mapPrimitiveName(keys) {
    var stringifiedKeys = ListWrapper.join(ListWrapper.map(keys, (function(k) {
      return isString(k) ? ("\"" + k + "\"") : ("" + k);
    })), ", ");
    return ("mapFn([" + stringifiedKeys + "])");
  }
  function _operationToPrimitiveName(operation) {
    switch (operation) {
      case '+':
        return "operation_add";
      case '-':
        return "operation_subtract";
      case '*':
        return "operation_multiply";
      case '/':
        return "operation_divide";
      case '%':
        return "operation_remainder";
      case '==':
        return "operation_equals";
      case '!=':
        return "operation_not_equals";
      case '<':
        return "operation_less_then";
      case '>':
        return "operation_greater_then";
      case '<=':
        return "operation_less_or_equals_then";
      case '>=':
        return "operation_greater_or_equals_then";
      case '&&':
        return "operation_logical_and";
      case '||':
        return "operation_logical_or";
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function _operationToFunction(operation) {
    switch (operation) {
      case '+':
        return ChangeDetectionUtil.operation_add;
      case '-':
        return ChangeDetectionUtil.operation_subtract;
      case '*':
        return ChangeDetectionUtil.operation_multiply;
      case '/':
        return ChangeDetectionUtil.operation_divide;
      case '%':
        return ChangeDetectionUtil.operation_remainder;
      case '==':
        return ChangeDetectionUtil.operation_equals;
      case '!=':
        return ChangeDetectionUtil.operation_not_equals;
      case '<':
        return ChangeDetectionUtil.operation_less_then;
      case '>':
        return ChangeDetectionUtil.operation_greater_then;
      case '<=':
        return ChangeDetectionUtil.operation_less_or_equals_then;
      case '>=':
        return ChangeDetectionUtil.operation_greater_or_equals_then;
      case '&&':
        return ChangeDetectionUtil.operation_logical_and;
      case '||':
        return ChangeDetectionUtil.operation_logical_or;
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function s(v) {
    return isPresent(v) ? ("" + v) : '';
  }
  function _interpolationFn(strings) {
    var length = strings.length;
    var c0 = length > 0 ? strings[0] : null;
    var c1 = length > 1 ? strings[1] : null;
    var c2 = length > 2 ? strings[2] : null;
    var c3 = length > 3 ? strings[3] : null;
    var c4 = length > 4 ? strings[4] : null;
    var c5 = length > 5 ? strings[5] : null;
    var c6 = length > 6 ? strings[6] : null;
    var c7 = length > 7 ? strings[7] : null;
    var c8 = length > 8 ? strings[8] : null;
    var c9 = length > 9 ? strings[9] : null;
    switch (length - 1) {
      case 1:
        return (function(a1) {
          return c0 + s(a1) + c1;
        });
      case 2:
        return (function(a1, a2) {
          return c0 + s(a1) + c1 + s(a2) + c2;
        });
      case 3:
        return (function(a1, a2, a3) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3;
        });
      case 4:
        return (function(a1, a2, a3, a4) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4;
        });
      case 5:
        return (function(a1, a2, a3, a4, a5) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
        });
      case 6:
        return (function(a1, a2, a3, a4, a5, a6) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
        });
      case 7:
        return (function(a1, a2, a3, a4, a5, a6, a7) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7;
        });
      case 8:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8;
        });
      case 9:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8 + s(a9) + c9;
        });
      default:
        throw new BaseException("Does not support more than 9 expressions");
    }
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      Type = $__m.Type;
      isString = $__m.isString;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      AccessMember = $__m.AccessMember;
      Assignment = $__m.Assignment;
      AST = $__m.AST;
      ASTWithSource = $__m.ASTWithSource;
      AstVisitor = $__m.AstVisitor;
      Binary = $__m.Binary;
      Chain = $__m.Chain;
      Conditional = $__m.Conditional;
      Pipe = $__m.Pipe;
      FunctionCall = $__m.FunctionCall;
      ImplicitReceiver = $__m.ImplicitReceiver;
      Interpolation = $__m.Interpolation;
      KeyedAccess = $__m.KeyedAccess;
      LiteralArray = $__m.LiteralArray;
      LiteralMap = $__m.LiteralMap;
      LiteralPrimitive = $__m.LiteralPrimitive;
      MethodCall = $__m.MethodCall;
      PrefixNot = $__m.PrefixNot;
    }, function($__m) {
      ChangeDispatcher = $__m.ChangeDispatcher;
      ChangeDetector = $__m.ChangeDetector;
      ProtoChangeDetector = $__m.ProtoChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      DynamicChangeDetector = $__m.DynamicChangeDetector;
    }, function($__m) {
      ChangeDetectorJITGenerator = $__m.ChangeDetectorJITGenerator;
    }, function($__m) {
      PipeRegistry = $__m.PipeRegistry;
    }, function($__m) {
      BindingRecord = $__m.BindingRecord;
    }, function($__m) {
      DirectiveRecord = $__m.DirectiveRecord;
      DirectiveIndex = $__m.DirectiveIndex;
    }, function($__m) {
      coalesce = $__m.coalesce;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
      RECORD_TYPE_SELF = $__m.RECORD_TYPE_SELF;
      RECORD_TYPE_PROPERTY = $__m.RECORD_TYPE_PROPERTY;
      RECORD_TYPE_LOCAL = $__m.RECORD_TYPE_LOCAL;
      RECORD_TYPE_INVOKE_METHOD = $__m.RECORD_TYPE_INVOKE_METHOD;
      RECORD_TYPE_CONST = $__m.RECORD_TYPE_CONST;
      RECORD_TYPE_INVOKE_CLOSURE = $__m.RECORD_TYPE_INVOKE_CLOSURE;
      RECORD_TYPE_PRIMITIVE_OP = $__m.RECORD_TYPE_PRIMITIVE_OP;
      RECORD_TYPE_KEYED_ACCESS = $__m.RECORD_TYPE_KEYED_ACCESS;
      RECORD_TYPE_PIPE = $__m.RECORD_TYPE_PIPE;
      RECORD_TYPE_BINDING_PIPE = $__m.RECORD_TYPE_BINDING_PIPE;
      RECORD_TYPE_INTERPOLATE = $__m.RECORD_TYPE_INTERPOLATE;
    }],
    execute: function() {
      DynamicProtoChangeDetector = (function($__super) {
        function DynamicProtoChangeDetector(pipeRegistry, bindingRecords, variableBindings, directiveRecords, changeControlStrategy) {
          $traceurRuntime.superConstructor(DynamicProtoChangeDetector).call(this);
          this._pipeRegistry = pipeRegistry;
          this._bindingRecords = bindingRecords;
          this._variableBindings = variableBindings;
          this._directiveRecords = directiveRecords;
          this._changeControlStrategy = changeControlStrategy;
        }
        return ($traceurRuntime.createClass)(DynamicProtoChangeDetector, {
          instantiate: function(dispatcher) {
            this._createRecordsIfNecessary();
            return new DynamicChangeDetector(this._changeControlStrategy, dispatcher, this._pipeRegistry, this._records, this._directiveRecords);
          },
          _createRecordsIfNecessary: function() {
            var $__0 = this;
            if (isBlank(this._records)) {
              var recordBuilder = new ProtoRecordBuilder();
              ListWrapper.forEach(this._bindingRecords, (function(b) {
                recordBuilder.addAst(b, $__0._variableBindings);
              }));
              this._records = coalesce(recordBuilder.records);
            }
          }
        }, {}, $__super);
      }(ProtoChangeDetector));
      $__export("DynamicProtoChangeDetector", DynamicProtoChangeDetector);
      Object.defineProperty(DynamicProtoChangeDetector, "parameters", {get: function() {
          return [[PipeRegistry], [List], [List], [List], [assert.type.string]];
        }});
      Object.defineProperty(DynamicProtoChangeDetector.prototype.instantiate, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      _jitProtoChangeDetectorClassCounter = 0;
      JitProtoChangeDetector = (function($__super) {
        function JitProtoChangeDetector(pipeRegistry, bindingRecords, variableBindings, directiveRecords, changeControlStrategy) {
          $traceurRuntime.superConstructor(JitProtoChangeDetector).call(this);
          this._pipeRegistry = pipeRegistry;
          this._factory = null;
          this._bindingRecords = bindingRecords;
          this._variableBindings = variableBindings;
          this._directiveRecords = directiveRecords;
          this._changeControlStrategy = changeControlStrategy;
        }
        return ($traceurRuntime.createClass)(JitProtoChangeDetector, {
          instantiate: function(dispatcher) {
            this._createFactoryIfNecessary();
            return this._factory(dispatcher, this._pipeRegistry);
          },
          _createFactoryIfNecessary: function() {
            var $__0 = this;
            if (isBlank(this._factory)) {
              var recordBuilder = new ProtoRecordBuilder();
              ListWrapper.forEach(this._bindingRecords, (function(b) {
                recordBuilder.addAst(b, $__0._variableBindings);
              }));
              var c = _jitProtoChangeDetectorClassCounter++;
              var records = coalesce(recordBuilder.records);
              var typeName = ("ChangeDetector" + c);
              this._factory = new ChangeDetectorJITGenerator(typeName, this._changeControlStrategy, records, this._directiveRecords).generate();
            }
          }
        }, {}, $__super);
      }(ProtoChangeDetector));
      $__export("JitProtoChangeDetector", JitProtoChangeDetector);
      Object.defineProperty(JitProtoChangeDetector, "parameters", {get: function() {
          return [[], [List], [List], [List], [assert.type.string]];
        }});
      Object.defineProperty(JitProtoChangeDetector.prototype.instantiate, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      ProtoRecordBuilder = (function() {
        function ProtoRecordBuilder() {
          this.records = [];
        }
        return ($traceurRuntime.createClass)(ProtoRecordBuilder, {addAst: function(b) {
            var variableBindings = arguments[1] !== (void 0) ? arguments[1] : null;
            var last = ListWrapper.last(this.records);
            if (isPresent(last) && last.bindingRecord.directiveRecord == b.directiveRecord) {
              last.lastInDirective = false;
            }
            var pr = _ConvertAstIntoProtoRecords.convert(b, this.records.length, variableBindings);
            if (!ListWrapper.isEmpty(pr)) {
              var last = ListWrapper.last(pr);
              last.lastInBinding = true;
              last.lastInDirective = true;
              this.records = ListWrapper.concat(this.records, pr);
            }
          }}, {});
      }());
      Object.defineProperty(ProtoRecordBuilder.prototype.addAst, "parameters", {get: function() {
          return [[BindingRecord], [List]];
        }});
      _ConvertAstIntoProtoRecords = (function() {
        function _ConvertAstIntoProtoRecords(bindingRecord, contextIndex, expressionAsString, variableBindings) {
          this.protoRecords = [];
          this.bindingRecord = bindingRecord;
          this.contextIndex = contextIndex;
          this.expressionAsString = expressionAsString;
          this.variableBindings = variableBindings;
        }
        return ($traceurRuntime.createClass)(_ConvertAstIntoProtoRecords, {
          visitImplicitReceiver: function(ast) {
            return this.bindingRecord.implicitReceiver;
          },
          visitInterpolation: function(ast) {
            var args = this._visitAll(ast.expressions);
            return this._addRecord(RECORD_TYPE_INTERPOLATE, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
          },
          visitLiteralPrimitive: function(ast) {
            return this._addRecord(RECORD_TYPE_CONST, "literal", ast.value, [], null, 0);
          },
          visitAccessMember: function(ast) {
            var receiver = ast.receiver.visit(this);
            if (isPresent(this.variableBindings) && ListWrapper.contains(this.variableBindings, ast.name) && ast.receiver instanceof ImplicitReceiver) {
              return this._addRecord(RECORD_TYPE_LOCAL, ast.name, ast.name, [], null, receiver);
            } else {
              return this._addRecord(RECORD_TYPE_PROPERTY, ast.name, ast.getter, [], null, receiver);
            }
          },
          visitMethodCall: function(ast) {
            ;
            var receiver = ast.receiver.visit(this);
            var args = this._visitAll(ast.args);
            if (isPresent(this.variableBindings) && ListWrapper.contains(this.variableBindings, ast.name)) {
              var target = this._addRecord(RECORD_TYPE_LOCAL, ast.name, ast.name, [], null, receiver);
              return this._addRecord(RECORD_TYPE_INVOKE_CLOSURE, "closure", null, args, null, target);
            } else {
              return this._addRecord(RECORD_TYPE_INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
            }
          },
          visitFunctionCall: function(ast) {
            var target = ast.target.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RECORD_TYPE_INVOKE_CLOSURE, "closure", null, args, null, target);
          },
          visitLiteralArray: function(ast) {
            var primitiveName = ("arrayFn" + ast.expressions.length);
            return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
          },
          visitLiteralMap: function(ast) {
            return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, _mapPrimitiveName(ast.keys), ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
          },
          visitBinary: function(ast) {
            var left = ast.left.visit(this);
            var right = ast.right.visit(this);
            return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
          },
          visitPrefixNot: function(ast) {
            var exp = ast.expression.visit(this);
            return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, "operation_negate", ChangeDetectionUtil.operation_negate, [exp], null, 0);
          },
          visitConditional: function(ast) {
            var c = ast.condition.visit(this);
            var t = ast.trueExp.visit(this);
            var f = ast.falseExp.visit(this);
            return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, "cond", ChangeDetectionUtil.cond, [c, t, f], null, 0);
          },
          visitPipe: function(ast) {
            var value = ast.exp.visit(this);
            var type = ast.inBinding ? RECORD_TYPE_BINDING_PIPE : RECORD_TYPE_PIPE;
            return this._addRecord(type, ast.name, ast.name, [], null, value);
          },
          visitKeyedAccess: function(ast) {
            var obj = ast.obj.visit(this);
            var key = ast.key.visit(this);
            return this._addRecord(RECORD_TYPE_KEYED_ACCESS, "keyedAccess", ChangeDetectionUtil.keyedAccess, [key], null, obj);
          },
          _visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          _addRecord: function(type, name, funcOrValue, args, fixedArgs, context) {
            var selfIndex = ++this.contextIndex;
            if (context instanceof DirectiveIndex) {
              ListWrapper.push(this.protoRecords, new ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this.bindingRecord, this.expressionAsString, false, false));
            } else {
              ListWrapper.push(this.protoRecords, new ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this.bindingRecord, this.expressionAsString, false, false));
            }
            return selfIndex;
          }
        }, {convert: function(b, contextIndex, variableBindings) {
            var c = new _ConvertAstIntoProtoRecords(b, contextIndex, b.ast.toString(), variableBindings);
            b.ast.visit(c);
            return c.protoRecords;
          }});
      }());
      Object.defineProperty(_ConvertAstIntoProtoRecords, "parameters", {get: function() {
          return [[BindingRecord], [assert.type.number], [assert.type.string], [List]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.convert, "parameters", {get: function() {
          return [[BindingRecord], [assert.type.number], [List]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitImplicitReceiver, "parameters", {get: function() {
          return [[ImplicitReceiver]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitInterpolation, "parameters", {get: function() {
          return [[Interpolation]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitLiteralPrimitive, "parameters", {get: function() {
          return [[LiteralPrimitive]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitAccessMember, "parameters", {get: function() {
          return [[AccessMember]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitMethodCall, "parameters", {get: function() {
          return [[MethodCall]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitFunctionCall, "parameters", {get: function() {
          return [[FunctionCall]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitLiteralArray, "parameters", {get: function() {
          return [[LiteralArray]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitLiteralMap, "parameters", {get: function() {
          return [[LiteralMap]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitBinary, "parameters", {get: function() {
          return [[Binary]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitPrefixNot, "parameters", {get: function() {
          return [[PrefixNot]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitConditional, "parameters", {get: function() {
          return [[Conditional]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitPipe, "parameters", {get: function() {
          return [[Pipe]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype.visitKeyedAccess, "parameters", {get: function() {
          return [[KeyedAccess]];
        }});
      Object.defineProperty(_ConvertAstIntoProtoRecords.prototype._visitAll, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(_arrayFn, "parameters", {get: function() {
          return [[assert.type.number]];
        }});
      Object.defineProperty(_mapPrimitiveName, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(_operationToPrimitiveName, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_operationToFunction, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_interpolationFn, "parameters", {get: function() {
          return [[List]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_pipeline", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/dom/compiler/compile_step", "angular2/src/render/dom/view/proto_view_builder"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_pipeline";
  var isPresent,
      List,
      ListWrapper,
      DOM,
      CompileElement,
      CompileControl,
      CompileStep,
      ProtoViewBuilder,
      CompilePipeline;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      CompileStep = $__m.CompileStep;
    }, function($__m) {
      ProtoViewBuilder = $__m.ProtoViewBuilder;
    }],
    execute: function() {
      CompilePipeline = (function() {
        function CompilePipeline(steps) {
          this._control = new CompileControl(steps);
        }
        return ($traceurRuntime.createClass)(CompilePipeline, {
          process: function(rootElement) {
            var compilationCtxtDescription = arguments[1] !== (void 0) ? arguments[1] : '';
            var results = ListWrapper.create();
            var rootCompileElement = new CompileElement(rootElement, compilationCtxtDescription);
            rootCompileElement.inheritedProtoView = new ProtoViewBuilder(rootElement);
            rootCompileElement.isViewRoot = true;
            this._process(results, null, rootCompileElement, compilationCtxtDescription);
            return results;
          },
          _process: function(results, parent, current) {
            var compilationCtxtDescription = arguments[3] !== (void 0) ? arguments[3] : '';
            var additionalChildren = this._control.internalProcess(results, 0, parent, current);
            if (current.compileChildren) {
              var node = DOM.firstChild(DOM.templateAwareRoot(current.element));
              while (isPresent(node)) {
                var nextNode = DOM.nextSibling(node);
                if (DOM.isElementNode(node)) {
                  var childCompileElement = new CompileElement(node, compilationCtxtDescription);
                  childCompileElement.inheritedProtoView = current.inheritedProtoView;
                  childCompileElement.inheritedElementBinder = current.inheritedElementBinder;
                  childCompileElement.distanceToInheritedBinder = current.distanceToInheritedBinder + 1;
                  this._process(results, current, childCompileElement);
                }
                node = nextNode;
              }
            }
            if (isPresent(additionalChildren)) {
              for (var i = 0; i < additionalChildren.length; i++) {
                this._process(results, current, additionalChildren[i]);
              }
            }
          }
        }, {});
      }());
      $__export("CompilePipeline", CompilePipeline);
      Object.defineProperty(CompilePipeline, "parameters", {get: function() {
          return [[assert.genericType(List, CompileStep)]];
        }});
      Object.defineProperty(CompilePipeline.prototype.process, "parameters", {get: function() {
          return [[], [assert.type.string]];
        }});
      Object.defineProperty(CompilePipeline.prototype._process, "parameters", {get: function() {
          return [[], [CompileElement], [CompileElement], [assert.type.string]];
        }});
    }
  };
});

System.register("angular2/src/di/injector", ["angular2/src/facade/collection", "angular2/src/di/binding", "angular2/src/di/exceptions", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/di/key"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/injector";
  var Map,
      List,
      MapWrapper,
      ListWrapper,
      ResolvedBinding,
      Binding,
      BindingBuilder,
      bind,
      AbstractBindingError,
      NoBindingError,
      AsyncBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      FunctionWrapper,
      Type,
      isPresent,
      isBlank,
      Promise,
      PromiseWrapper,
      Key,
      _constructing,
      _notFound,
      _Waiting,
      Injector,
      _SyncInjectorStrategy,
      _AsyncInjectorStrategy;
  function _isWaiting(obj) {
    return obj instanceof _Waiting;
  }
  function _resolveBindings(bindings) {
    var resolvedList = ListWrapper.createFixedSize(bindings.length);
    for (var i = 0; i < bindings.length; i++) {
      var unresolved = bindings[i];
      var resolved = void 0;
      if (unresolved instanceof ResolvedBinding) {
        resolved = unresolved;
      } else if (unresolved instanceof Type) {
        resolved = bind(unresolved).toClass(unresolved).resolve();
      } else if (unresolved instanceof Binding) {
        resolved = unresolved.resolve();
      } else if (unresolved instanceof List) {
        resolved = _resolveBindings(unresolved);
      } else if (unresolved instanceof BindingBuilder) {
        throw new InvalidBindingError('BindingBuilder with ' + unresolved.token + ' token');
      } else {
        throw new InvalidBindingError(unresolved);
      }
      resolvedList[i] = resolved;
    }
    return resolvedList;
  }
  function _createListOfBindings(flattenedBindings) {
    var bindings = ListWrapper.createFixedSize(Key.numberOfKeys + 1);
    MapWrapper.forEach(flattenedBindings, (function(v, keyId) {
      return bindings[keyId] = v;
    }));
    return bindings;
  }
  function _flattenBindings(bindings, res) {
    ListWrapper.forEach(bindings, function(b) {
      if (b instanceof ResolvedBinding) {
        MapWrapper.set(res, b.key.id, b);
      } else if (b instanceof List) {
        _flattenBindings(b, res);
      }
    });
    return res;
  }
  return {
    setters: [function($__m) {
      Map = $__m.Map;
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ResolvedBinding = $__m.ResolvedBinding;
      Binding = $__m.Binding;
      BindingBuilder = $__m.BindingBuilder;
      bind = $__m.bind;
    }, function($__m) {
      AbstractBindingError = $__m.AbstractBindingError;
      NoBindingError = $__m.NoBindingError;
      AsyncBindingError = $__m.AsyncBindingError;
      CyclicDependencyError = $__m.CyclicDependencyError;
      InstantiationError = $__m.InstantiationError;
      InvalidBindingError = $__m.InvalidBindingError;
    }, function($__m) {
      FunctionWrapper = $__m.FunctionWrapper;
      Type = $__m.Type;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      Key = $__m.Key;
    }],
    execute: function() {
      _constructing = new Object();
      _notFound = new Object();
      _Waiting = (function() {
        function _Waiting(promise) {
          this.promise = promise;
        }
        return ($traceurRuntime.createClass)(_Waiting, {}, {});
      }());
      Object.defineProperty(_Waiting, "parameters", {get: function() {
          return [[Promise]];
        }});
      Injector = (function() {
        function Injector(bindings, parent, defaultBindings) {
          this._bindings = bindings;
          this._instances = this._createInstances();
          this._parent = parent;
          this._defaultBindings = defaultBindings;
          this._asyncStrategy = new _AsyncInjectorStrategy(this);
          this._syncStrategy = new _SyncInjectorStrategy(this);
        }
        return ($traceurRuntime.createClass)(Injector, {
          get: function(token) {
            return this._getByKey(Key.get(token), false, false, false);
          },
          getOptional: function(token) {
            return this._getByKey(Key.get(token), false, false, true);
          },
          asyncGet: function(token) {
            return this._getByKey(Key.get(token), true, false, false);
          },
          resolveAndCreateChild: function(bindings) {
            return new Injector(Injector.resolve(bindings), this, false);
          },
          createChildFromResolved: function(bindings) {
            return new Injector(bindings, this, false);
          },
          _createInstances: function() {
            return ListWrapper.createFixedSize(Key.numberOfKeys + 1);
          },
          _getByKey: function(key, returnPromise, returnLazy, optional) {
            var $__0 = this;
            if (returnLazy) {
              return (function() {
                return $__0._getByKey(key, returnPromise, false, optional);
              });
            }
            var strategy = returnPromise ? this._asyncStrategy : this._syncStrategy;
            var instance = strategy.readFromCache(key);
            if (instance !== _notFound)
              return instance;
            instance = strategy.instantiate(key);
            if (instance !== _notFound)
              return instance;
            if (isPresent(this._parent)) {
              return this._parent._getByKey(key, returnPromise, returnLazy, optional);
            }
            if (optional) {
              return null;
            } else {
              throw new NoBindingError(key);
            }
          },
          _resolveDependencies: function(key, binding, forceAsync) {
            var $__0 = this;
            try {
              var getDependency = (function(d) {
                return $__0._getByKey(d.key, forceAsync || d.asPromise, d.lazy, d.optional);
              });
              return ListWrapper.map(binding.dependencies, getDependency);
            } catch (e) {
              this._clear(key);
              if (e instanceof AbstractBindingError)
                e.addKey(key);
              throw e;
            }
          },
          _getInstance: function(key) {
            if (this._instances.length <= key.id)
              return null;
            return ListWrapper.get(this._instances, key.id);
          },
          _setInstance: function(key, obj) {
            ListWrapper.set(this._instances, key.id, obj);
          },
          _getBinding: function(key) {
            var binding = this._bindings.length <= key.id ? null : ListWrapper.get(this._bindings, key.id);
            if (isBlank(binding) && this._defaultBindings) {
              return bind(key.token).toClass(key.token).resolve();
            } else {
              return binding;
            }
          },
          _markAsConstructing: function(key) {
            this._setInstance(key, _constructing);
          },
          _clear: function(key) {
            this._setInstance(key, null);
          }
        }, {
          resolve: function(bindings) {
            var resolvedBindings = _resolveBindings(bindings);
            var flatten = _flattenBindings(resolvedBindings, MapWrapper.create());
            return _createListOfBindings(flatten);
          },
          resolveAndCreate: function(bindings) {
            var $__3;
            var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
                defaultBindings = ($__3 = $__2.defaultBindings) === void 0 ? false : $__3;
            return new Injector(Injector.resolve(bindings), null, defaultBindings);
          },
          fromResolvedBindings: function(bindings) {
            var $__3;
            var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
                defaultBindings = ($__3 = $__2.defaultBindings) === void 0 ? false : $__3;
            return new Injector(bindings, null, defaultBindings);
          }
        });
      }());
      $__export("Injector", Injector);
      Object.defineProperty(Injector, "parameters", {get: function() {
          return [[assert.genericType(List, ResolvedBinding)], [Injector], [assert.type.boolean]];
        }});
      Object.defineProperty(Injector.resolve, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(Injector.resolveAndCreate, "parameters", {get: function() {
          return [[List], []];
        }});
      Object.defineProperty(Injector.fromResolvedBindings, "parameters", {get: function() {
          return [[assert.genericType(List, ResolvedBinding)], []];
        }});
      Object.defineProperty(Injector.prototype.resolveAndCreateChild, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(Injector.prototype.createChildFromResolved, "parameters", {get: function() {
          return [[assert.genericType(List, ResolvedBinding)]];
        }});
      Object.defineProperty(Injector.prototype._getByKey, "parameters", {get: function() {
          return [[Key], [assert.type.boolean], [assert.type.boolean], [assert.type.boolean]];
        }});
      Object.defineProperty(Injector.prototype._resolveDependencies, "parameters", {get: function() {
          return [[Key], [ResolvedBinding], [assert.type.boolean]];
        }});
      Object.defineProperty(Injector.prototype._getInstance, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(Injector.prototype._setInstance, "parameters", {get: function() {
          return [[Key], []];
        }});
      Object.defineProperty(Injector.prototype._getBinding, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(Injector.prototype._markAsConstructing, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(Injector.prototype._clear, "parameters", {get: function() {
          return [[Key]];
        }});
      _SyncInjectorStrategy = (function() {
        function _SyncInjectorStrategy(injector) {
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_SyncInjectorStrategy, {
          readFromCache: function(key) {
            if (key.token === Injector) {
              return this.injector;
            }
            var instance = this.injector._getInstance(key);
            if (instance === _constructing) {
              throw new CyclicDependencyError(key);
            } else if (isPresent(instance) && !_isWaiting(instance)) {
              return instance;
            } else {
              return _notFound;
            }
          },
          instantiate: function(key) {
            var binding = this.injector._getBinding(key);
            if (isBlank(binding))
              return _notFound;
            if (binding.providedAsPromise)
              throw new AsyncBindingError(key);
            this.injector._markAsConstructing(key);
            var deps = this.injector._resolveDependencies(key, binding, false);
            return this._createInstance(key, binding, deps);
          },
          _createInstance: function(key, binding, deps) {
            try {
              var instance = FunctionWrapper.apply(binding.factory, deps);
              this.injector._setInstance(key, instance);
              return instance;
            } catch (e) {
              this.injector._clear(key);
              throw new InstantiationError(e, key);
            }
          }
        }, {});
      }());
      Object.defineProperty(_SyncInjectorStrategy, "parameters", {get: function() {
          return [[Injector]];
        }});
      Object.defineProperty(_SyncInjectorStrategy.prototype.readFromCache, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(_SyncInjectorStrategy.prototype.instantiate, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(_SyncInjectorStrategy.prototype._createInstance, "parameters", {get: function() {
          return [[Key], [ResolvedBinding], [List]];
        }});
      _AsyncInjectorStrategy = (function() {
        function _AsyncInjectorStrategy(injector) {
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_AsyncInjectorStrategy, {
          readFromCache: function(key) {
            if (key.token === Injector) {
              return PromiseWrapper.resolve(this.injector);
            }
            var instance = this.injector._getInstance(key);
            if (instance === _constructing) {
              throw new CyclicDependencyError(key);
            } else if (_isWaiting(instance)) {
              return instance.promise;
            } else if (isPresent(instance)) {
              return PromiseWrapper.resolve(instance);
            } else {
              return _notFound;
            }
          },
          instantiate: function(key) {
            var $__0 = this;
            var binding = this.injector._getBinding(key);
            if (isBlank(binding))
              return _notFound;
            this.injector._markAsConstructing(key);
            var deps = this.injector._resolveDependencies(key, binding, true);
            var depsPromise = PromiseWrapper.all(deps);
            var promise = PromiseWrapper.then(depsPromise, null, (function(e) {
              return $__0._errorHandler(key, e);
            })).then((function(deps) {
              return $__0._findOrCreate(key, binding, deps);
            })).then((function(instance) {
              return $__0._cacheInstance(key, instance);
            }));
            this.injector._setInstance(key, new _Waiting(promise));
            return promise;
          },
          _errorHandler: function(key, e) {
            if (e instanceof AbstractBindingError)
              e.addKey(key);
            return PromiseWrapper.reject(e);
          },
          _findOrCreate: function(key, binding, deps) {
            try {
              var instance = this.injector._getInstance(key);
              if (!_isWaiting(instance))
                return instance;
              return FunctionWrapper.apply(binding.factory, deps);
            } catch (e) {
              this.injector._clear(key);
              throw new InstantiationError(e, key);
            }
          },
          _cacheInstance: function(key, instance) {
            this.injector._setInstance(key, instance);
            return instance;
          }
        }, {});
      }());
      Object.defineProperty(_AsyncInjectorStrategy, "parameters", {get: function() {
          return [[Injector]];
        }});
      Object.defineProperty(_AsyncInjectorStrategy.prototype.readFromCache, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(_AsyncInjectorStrategy.prototype.instantiate, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(_AsyncInjectorStrategy.prototype._errorHandler, "parameters", {get: function() {
          return [[Key], []];
        }});
      Object.defineProperty(_AsyncInjectorStrategy.prototype._findOrCreate, "parameters", {get: function() {
          return [[Key], [ResolvedBinding], [List]];
        }});
      Object.defineProperty(_resolveBindings, "parameters", {get: function() {
          return [[List]];
        }});
      Object.defineProperty(_flattenBindings, "parameters", {get: function() {
          return [[List], [Map]];
        }});
    }
  };
});

System.register("angular2/src/change_detection/exceptions", ["angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/exceptions";
  var ProtoRecord,
      ExpressionChangedAfterItHasBeenChecked,
      ChangeDetectionError;
  return {
    setters: [function($__m) {
      ProtoRecord = $__m.ProtoRecord;
    }],
    execute: function() {
      ExpressionChangedAfterItHasBeenChecked = (function($__super) {
        function ExpressionChangedAfterItHasBeenChecked(proto, change) {
          $traceurRuntime.superConstructor(ExpressionChangedAfterItHasBeenChecked).call(this);
          this.message = ("Expression '" + proto.expressionAsString + "' has changed after it was checked. ") + ("Previous value: '" + change.previousValue + "'. Current value: '" + change.currentValue + "'");
        }
        return ($traceurRuntime.createClass)(ExpressionChangedAfterItHasBeenChecked, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      $__export("ExpressionChangedAfterItHasBeenChecked", ExpressionChangedAfterItHasBeenChecked);
      Object.defineProperty(ExpressionChangedAfterItHasBeenChecked, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.any]];
        }});
      ChangeDetectionError = (function($__super) {
        function ChangeDetectionError(proto, originalException) {
          $traceurRuntime.superConstructor(ChangeDetectionError).call(this);
          this.originalException = originalException;
          this.location = proto.expressionAsString;
          this.message = (this.originalException + " in [" + this.location + "]");
        }
        return ($traceurRuntime.createClass)(ChangeDetectionError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      $__export("ChangeDetectionError", ChangeDetectionError);
      Object.defineProperty(ChangeDetectionError, "parameters", {get: function() {
          return [[ProtoRecord], [assert.type.any]];
        }});
    }
  };
});

System.register("angular2/src/render/dom/compiler/compiler", ["angular2/di", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/api", "angular2/src/render/dom/compiler/compile_pipeline", "angular2/src/render/dom/compiler/template_loader", "angular2/src/render/dom/compiler/compile_step_factory", "angular2/change_detection", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compiler";
  var Injectable,
      PromiseWrapper,
      Promise,
      BaseException,
      DOM,
      ViewDefinition,
      ProtoViewDto,
      DirectiveMetadata,
      CompilePipeline,
      TemplateLoader,
      CompileStepFactory,
      DefaultStepFactory,
      Parser,
      ShadowDomStrategy,
      Compiler,
      DefaultCompiler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      Promise = $__m.Promise;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
      ProtoViewDto = $__m.ProtoViewDto;
      DirectiveMetadata = $__m.DirectiveMetadata;
    }, function($__m) {
      CompilePipeline = $__m.CompilePipeline;
    }, function($__m) {
      TemplateLoader = $__m.TemplateLoader;
    }, function($__m) {
      CompileStepFactory = $__m.CompileStepFactory;
      DefaultStepFactory = $__m.DefaultStepFactory;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }],
    execute: function() {
      Compiler = (function() {
        function Compiler(stepFactory, templateLoader) {
          this._templateLoader = templateLoader;
          this._stepFactory = stepFactory;
        }
        return ($traceurRuntime.createClass)(Compiler, {
          compile: function(template) {
            var $__0 = this;
            var tplPromise = this._templateLoader.load(template);
            return PromiseWrapper.then(tplPromise, (function(el) {
              return $__0._compileTemplate(template, el);
            }), (function(_) {
              throw new BaseException(("Failed to load the template \"" + template.componentId + "\""));
            }));
          },
          compileHost: function(directiveMetadata) {
            var hostViewDef = new ViewDefinition({
              componentId: directiveMetadata.id,
              absUrl: null,
              template: null,
              directives: [directiveMetadata]
            });
            var element = DOM.createElement(directiveMetadata.selector);
            return this._compileTemplate(hostViewDef, element);
          },
          _compileTemplate: function(viewDef, tplElement) {
            var subTaskPromises = [];
            var pipeline = new CompilePipeline(this._stepFactory.createSteps(viewDef, subTaskPromises));
            var compileElements = pipeline.process(tplElement, viewDef.componentId);
            var protoView = compileElements[0].inheritedProtoView.build();
            if (subTaskPromises.length > 0) {
              return PromiseWrapper.all(subTaskPromises).then((function(_) {
                return protoView;
              }));
            } else {
              return PromiseWrapper.resolve(protoView);
            }
          }
        }, {});
      }());
      $__export("Compiler", Compiler);
      Object.defineProperty(Compiler, "parameters", {get: function() {
          return [[CompileStepFactory], [TemplateLoader]];
        }});
      Object.defineProperty(Compiler.prototype.compile, "parameters", {get: function() {
          return [[ViewDefinition]];
        }});
      Object.defineProperty(Compiler.prototype.compileHost, "parameters", {get: function() {
          return [[DirectiveMetadata]];
        }});
      Object.defineProperty(Compiler.prototype._compileTemplate, "parameters", {get: function() {
          return [[ViewDefinition], []];
        }});
      DefaultCompiler = (function($__super) {
        function DefaultCompiler(parser, shadowDomStrategy, templateLoader) {
          $traceurRuntime.superConstructor(DefaultCompiler).call(this, new DefaultStepFactory(parser, shadowDomStrategy), templateLoader);
        }
        return ($traceurRuntime.createClass)(DefaultCompiler, {}, {}, $__super);
      }(Compiler));
      $__export("DefaultCompiler", DefaultCompiler);
      Object.defineProperty(DefaultCompiler, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(DefaultCompiler, "parameters", {get: function() {
          return [[Parser], [ShadowDomStrategy], [TemplateLoader]];
        }});
    }
  };
});

System.register("src/rules-engine/dispatcher/AppDispatcher.ts", ["npm:flux@2.0.3"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/dispatcher/AppDispatcher.ts";
  var Dispatcher,
      AppDispatcher;
  return {
    setters: [function($__m) {
      Dispatcher = $__m.default;
    }],
    execute: function() {
      AppDispatcher = new Dispatcher.Dispatcher();
      $__export("AppDispatcher", AppDispatcher);
    }
  };
});

System.register("angular2/di", ["angular2/src/di/annotations", "angular2/src/di/injector", "angular2/src/di/binding", "angular2/src/di/key", "angular2/src/di/exceptions", "angular2/src/di/opaque_token"], function($__export) {
  "use strict";
  var __moduleName = "angular2/di";
  return {
    setters: [function($__m) {
      $__export("Inject", $__m.Inject);
      $__export("InjectPromise", $__m.InjectPromise);
      $__export("InjectLazy", $__m.InjectLazy);
      $__export("Injectable", $__m.Injectable);
      $__export("Optional", $__m.Optional);
      $__export("DependencyAnnotation", $__m.DependencyAnnotation);
    }, function($__m) {
      $__export("Injector", $__m.Injector);
    }, function($__m) {
      $__export("Binding", $__m.Binding);
      $__export("ResolvedBinding", $__m.ResolvedBinding);
      $__export("Dependency", $__m.Dependency);
      $__export("bind", $__m.bind);
    }, function($__m) {
      $__export("Key", $__m.Key);
      $__export("KeyRegistry", $__m.KeyRegistry);
    }, function($__m) {
      $__export("KeyMetadataError", $__m.KeyMetadataError);
      $__export("NoBindingError", $__m.NoBindingError);
      $__export("AbstractBindingError", $__m.AbstractBindingError);
      $__export("AsyncBindingError", $__m.AsyncBindingError);
      $__export("CyclicDependencyError", $__m.CyclicDependencyError);
      $__export("InstantiationError", $__m.InstantiationError);
      $__export("InvalidBindingError", $__m.InvalidBindingError);
      $__export("NoAnnotationError", $__m.NoAnnotationError);
    }, function($__m) {
      $__export("OpaqueToken", $__m.OpaqueToken);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/render/dom/direct_dom_renderer", ["angular2/di", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/render/api", "angular2/src/render/dom/view/view", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/view_factory", "angular2/src/render/dom/view/view_hydrator", "angular2/src/render/dom/compiler/compiler", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/view/proto_view_builder", "angular2/src/render/dom/view/view_container"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/direct_dom_renderer";
  var Injectable,
      Promise,
      PromiseWrapper,
      List,
      ListWrapper,
      isBlank,
      isPresent,
      BaseException,
      api,
      RenderView,
      RenderProtoView,
      ViewFactory,
      RenderViewHydrator,
      Compiler,
      ShadowDomStrategy,
      ProtoViewBuilder,
      ViewContainer,
      DirectDomProtoViewRef,
      DirectDomViewRef,
      DirectDomRenderer;
  function _resolveViewContainer(vc) {
    return _resolveView(vc.view).getOrCreateViewContainer(vc.elementIndex);
  }
  function _resolveView(viewRef) {
    return isPresent(viewRef) ? viewRef.delegate : null;
  }
  function _resolveProtoView(protoViewRef) {
    return isPresent(protoViewRef) ? protoViewRef.delegate : null;
  }
  function _wrapView(view) {
    return new DirectDomViewRef(view);
  }
  function _collectComponentChildViewRefs(view) {
    var target = arguments[1] !== (void 0) ? arguments[1] : null;
    if (isBlank(target)) {
      target = [];
    }
    ListWrapper.push(target, _wrapView(view));
    ListWrapper.forEach(view.componentChildViews, (function(view) {
      if (isPresent(view)) {
        _collectComponentChildViewRefs(view, target);
      }
    }));
    return target;
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      api = $__m;
    }, function($__m) {
      RenderView = $__m.RenderView;
    }, function($__m) {
      RenderProtoView = $__m.RenderProtoView;
    }, function($__m) {
      ViewFactory = $__m.ViewFactory;
    }, function($__m) {
      RenderViewHydrator = $__m.RenderViewHydrator;
    }, function($__m) {
      Compiler = $__m.Compiler;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }, function($__m) {
      ProtoViewBuilder = $__m.ProtoViewBuilder;
    }, function($__m) {
      ViewContainer = $__m.ViewContainer;
    }],
    execute: function() {
      Object.defineProperty(_resolveViewContainer, "parameters", {get: function() {
          return [[api.RenderViewContainerRef]];
        }});
      Object.defineProperty(_resolveView, "parameters", {get: function() {
          return [[DirectDomViewRef]];
        }});
      Object.defineProperty(_resolveProtoView, "parameters", {get: function() {
          return [[DirectDomProtoViewRef]];
        }});
      Object.defineProperty(_wrapView, "parameters", {get: function() {
          return [[RenderView]];
        }});
      DirectDomProtoViewRef = (function($__super) {
        function DirectDomProtoViewRef(delegate) {
          $traceurRuntime.superConstructor(DirectDomProtoViewRef).call(this);
          this.delegate = delegate;
        }
        return ($traceurRuntime.createClass)(DirectDomProtoViewRef, {}, {}, $__super);
      }(api.RenderProtoViewRef));
      $__export("DirectDomProtoViewRef", DirectDomProtoViewRef);
      Object.defineProperty(DirectDomProtoViewRef, "parameters", {get: function() {
          return [[RenderProtoView]];
        }});
      DirectDomViewRef = (function($__super) {
        function DirectDomViewRef(delegate) {
          $traceurRuntime.superConstructor(DirectDomViewRef).call(this);
          this.delegate = delegate;
        }
        return ($traceurRuntime.createClass)(DirectDomViewRef, {}, {}, $__super);
      }(api.RenderViewRef));
      $__export("DirectDomViewRef", DirectDomViewRef);
      Object.defineProperty(DirectDomViewRef, "parameters", {get: function() {
          return [[RenderView]];
        }});
      DirectDomRenderer = (function($__super) {
        function DirectDomRenderer(compiler, viewFactory, viewHydrator, shadowDomStrategy) {
          $traceurRuntime.superConstructor(DirectDomRenderer).call(this);
          this._compiler = compiler;
          this._viewFactory = viewFactory;
          this._viewHydrator = viewHydrator;
          this._shadowDomStrategy = shadowDomStrategy;
        }
        return ($traceurRuntime.createClass)(DirectDomRenderer, {
          createHostProtoView: function(directiveMetadata) {
            return this._compiler.compileHost(directiveMetadata);
          },
          createImperativeComponentProtoView: function(rendererId) {
            var protoViewBuilder = new ProtoViewBuilder(null);
            protoViewBuilder.setImperativeRendererId(rendererId);
            return PromiseWrapper.resolve(protoViewBuilder.build());
          },
          compile: function(view) {
            return this._compiler.compile(view);
          },
          mergeChildComponentProtoViews: function(protoViewRef, protoViewRefs) {
            _resolveProtoView(protoViewRef).mergeChildComponentProtoViews(ListWrapper.map(protoViewRefs, _resolveProtoView));
          },
          createViewInContainer: function(vcRef, atIndex, protoViewRef) {
            var view = this._viewFactory.getView(_resolveProtoView(protoViewRef));
            var vc = _resolveViewContainer(vcRef);
            this._viewHydrator.hydrateViewInViewContainer(vc, view);
            vc.insert(view, atIndex);
            return _collectComponentChildViewRefs(view);
          },
          destroyViewInContainer: function(vcRef, atIndex) {
            var vc = _resolveViewContainer(vcRef);
            var view = vc.detach(atIndex);
            this._viewHydrator.dehydrateViewInViewContainer(vc, view);
            this._viewFactory.returnView(view);
          },
          insertViewIntoContainer: function(vcRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            var viewRef = arguments[2];
            _resolveViewContainer(vcRef).insert(_resolveView(viewRef), atIndex);
          },
          detachViewFromContainer: function(vcRef, atIndex) {
            _resolveViewContainer(vcRef).detach(atIndex);
          },
          createDynamicComponentView: function(hostViewRef, elementIndex, componentViewRef) {
            var hostView = _resolveView(hostViewRef);
            var componentView = this._viewFactory.getView(_resolveProtoView(componentViewRef));
            this._viewHydrator.hydrateDynamicComponentView(hostView, elementIndex, componentView);
            return _collectComponentChildViewRefs(componentView);
          },
          destroyDynamicComponentView: function(hostViewRef, elementIndex) {
            throw new BaseException('Not supported yet');
          },
          createInPlaceHostView: function(parentViewRef, hostElementSelector, hostProtoViewRef) {
            var parentView = _resolveView(parentViewRef);
            var hostView = this._viewFactory.createInPlaceHostView(hostElementSelector, _resolveProtoView(hostProtoViewRef));
            this._viewHydrator.hydrateInPlaceHostView(parentView, hostView);
            return _collectComponentChildViewRefs(hostView);
          },
          destroyInPlaceHostView: function(parentViewRef, hostViewRef) {
            var parentView = _resolveView(parentViewRef);
            var hostView = _resolveView(hostViewRef);
            this._viewHydrator.dehydrateInPlaceHostView(parentView, hostView);
          },
          setImperativeComponentRootNodes: function(parentViewRef, elementIndex, nodes) {
            var parentView = _resolveView(parentViewRef);
            var hostElement = parentView.boundElements[elementIndex];
            var componentView = parentView.componentChildViews[elementIndex];
            if (isBlank(componentView)) {
              throw new BaseException(("There is no componentChildView at index " + elementIndex));
            }
            if (isBlank(componentView.proto.imperativeRendererId)) {
              throw new BaseException("This component view has no imperative renderer");
            }
            ViewContainer.removeViewNodes(componentView);
            componentView.rootNodes = nodes;
            this._shadowDomStrategy.attachTemplate(hostElement, componentView);
          },
          setElementProperty: function(viewRef, elementIndex, propertyName, propertyValue) {
            _resolveView(viewRef).setElementProperty(elementIndex, propertyName, propertyValue);
          },
          setText: function(viewRef, textNodeIndex, text) {
            _resolveView(viewRef).setText(textNodeIndex, text);
          },
          setEventDispatcher: function(viewRef, dispatcher) {
            _resolveView(viewRef).setEventDispatcher(dispatcher);
          }
        }, {}, $__super);
      }(api.Renderer));
      $__export("DirectDomRenderer", DirectDomRenderer);
      Object.defineProperty(DirectDomRenderer, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(DirectDomRenderer, "parameters", {get: function() {
          return [[Compiler], [ViewFactory], [RenderViewHydrator], [ShadowDomStrategy]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.createHostProtoView, "parameters", {get: function() {
          return [[api.DirectiveMetadata]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.compile, "parameters", {get: function() {
          return [[api.ViewDefinition]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.mergeChildComponentProtoViews, "parameters", {get: function() {
          return [[api.RenderProtoViewRef], [assert.genericType(List, api.RenderProtoViewRef)]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.createViewInContainer, "parameters", {get: function() {
          return [[api.RenderViewContainerRef], [assert.type.number], [api.RenderProtoViewRef]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.destroyViewInContainer, "parameters", {get: function() {
          return [[api.RenderViewContainerRef], [assert.type.number]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.insertViewIntoContainer, "parameters", {get: function() {
          return [[api.RenderViewContainerRef], [], [api.RenderViewRef]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.detachViewFromContainer, "parameters", {get: function() {
          return [[api.RenderViewContainerRef], [assert.type.number]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.createDynamicComponentView, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.number], [api.RenderProtoViewRef]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.destroyDynamicComponentView, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.number]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.createInPlaceHostView, "parameters", {get: function() {
          return [[api.RenderViewRef], [], [api.RenderProtoViewRef]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.destroyInPlaceHostView, "parameters", {get: function() {
          return [[api.RenderViewRef], [api.RenderViewRef]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.setImperativeComponentRootNodes, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.number], [List]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.setElementProperty, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.number], [assert.type.string], [assert.type.any]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.setText, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.number], [assert.type.string]];
        }});
      Object.defineProperty(DirectDomRenderer.prototype.setEventDispatcher, "parameters", {get: function() {
          return [[api.RenderViewRef], [assert.type.any]];
        }});
    }
  };
});

System.register("src/rules-engine/api/RuleEngineAPI.ts", ["rtts_assert/rtts_assert", "npm:debug@2.2.0", "src/rules-engine/datamocks/rule.mocks.es6", "src/rules-engine/dispatcher/AppDispatcher.ts", "src/dc/index.es6", "src/rules-engine/actions/RuleEngineActionCreators.es6", "src/rules-engine/api/RuleEngineTypes.es6"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/api/RuleEngineAPI.ts";
  var assert,
      XDebug,
      log,
      mocks,
      AppDispatcher,
      Core,
      Check,
      RuleEngine,
      RuleTypes,
      dispatchToken,
      Storage,
      clauseRepo,
      ruleRepo;
  return {
    setters: [function($__m) {
      assert = $__m.assert;
    }, function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      mocks = $__m.mocks;
    }, function($__m) {
      AppDispatcher = $__m.AppDispatcher;
    }, function($__m) {
      Core = $__m.Core;
      Check = $__m.Check;
    }, function($__m) {
      RuleEngine = $__m;
    }, function($__m) {
      RuleTypes = $__m;
    }],
    execute: function() {
      log = XDebug('RulesEngine.api');
      dispatchToken = AppDispatcher.register((function(action) {
        switch (action.key) {
          case RuleEngine.actionTypes.REMOVE_RULE:
            break;
          default:
        }
      }));
      Storage = {
        get length() {
          return localStorage.length;
        },
        key: function(idx) {
          assert.argumentTypes(idx, $traceurRuntime.type.number);
          return assert.returnType((localStorage.key(idx)), $traceurRuntime.type.string);
        },
        clear: function() {
          localStorage.clear();
        },
        setItem: function(key, value) {
          assert.argumentTypes(key, $traceurRuntime.type.string, value, Object);
          key = Check.exists(key, "Cannot save with an empty key");
          value = Check.exists(value, "Cannot save empty values. Did you mean to remove?");
          localStorage.setItem(key, JSON.stringify(value));
        },
        getItem: function(key) {
          assert.argumentTypes(key, $traceurRuntime.type.string);
          var item = localStorage.getItem(key);
          item = item === null ? null : JSON.parse(item);
          return assert.returnType((item), $traceurRuntime.type.any);
        },
        getItems: function() {
          for (var keys = [],
              $__0 = 0; $__0 < arguments.length; $__0++)
            keys[$__0] = arguments[$__0];
          return assert.returnType((keys.map((function(key) {
            return Storage.getItem(key);
          }))), $traceurRuntime.genericType(Array, $traceurRuntime.type.any));
        },
        hasItem: function(key) {
          assert.argumentTypes(key, $traceurRuntime.type.string);
          return assert.returnType((localStorage.getItem(key) !== null), $traceurRuntime.type.boolean);
        },
        removeItem: function(key) {
          assert.argumentTypes(key, $traceurRuntime.type.string);
          var itemJson = localStorage.getItem(key);
          var item = null;
          if (itemJson !== null) {
            item = JSON.parse(item);
          }
          localStorage.removeItem(key);
          return item;
        },
        childKeys: function(path) {
          assert.argumentTypes(path, $traceurRuntime.type.string);
          var pathLen = path.length;
          var childKeys = Storage.childPaths(path).map((function(childPath) {
            return childPath.substring(pathLen);
          }));
          return assert.returnType((childKeys), $traceurRuntime.genericType(Array, $traceurRuntime.type.string));
        },
        childPaths: function(path) {
          assert.argumentTypes(path, $traceurRuntime.type.string);
          var childPaths = [];
          for (var i = 0; i < localStorage.length; i++) {
            var childPath = assert.type(localStorage.key(i), $traceurRuntime.type.string);
            if (childPath.startsWith(path)) {
              childPaths.push(childPath);
            }
          }
          return assert.returnType((childPaths), $traceurRuntime.genericType(Array, $traceurRuntime.type.string));
        },
        childItems: function(path) {
          assert.argumentTypes(path, $traceurRuntime.type.string);
          var pathLen = path.length;
          return assert.returnType((Storage.childPaths(path).map((function(childPath) {
            return {
              path: childPath,
              key: childPath.substring(pathLen),
              val: Storage.getItem(childPath)
            };
          }))), $traceurRuntime.genericType(Array, $traceurRuntime.type.any));
        }
      };
      clauseRepo = {
        basePath: '/api/rules-engine/clauses/',
        inward: {transform: function(_group, key) {}},
        outward: {transform: function(clause) {
            return {
              key: clause.$key,
              val: {
                type: clause.type,
                owningGroup: clause.owningGroup,
                operator: clause.operator,
                value: clause.value
              }
            };
          }},
        push: function(clause) {
          clause.$key = Core.Key.next();
          return clauseRepo.set(clause);
        },
        set: function(clause) {
          clause = Check.exists(clause, "Cannot save null clause");
          Check.exists(clause.$key, "Cannot save clause with an empty key");
          return new Promise((function(resolve, reject) {
            var _xForm = clauseRepo.outward.transform(clause);
            Storage.setItem(clauseRepo.basePath + _xForm.key, _xForm.val);
            resolve(clause);
          }));
        },
        getByGroup: function(groupKey) {
          return new Promise((function(resolve, reject) {
            var clausesByGroup = new Map();
            var _clauses = Storage.childItems(clauseRepo.basePath).filter((function(_stub) {
              return _stub.val.owningGroup == groupKey;
            })).map((function(_stub) {
              return {
                $key: _stub.key,
                owningGroup: _stub.val.owningGroup,
                value: _stub.val.value,
                operator: _stub.val.operator
              };
            }));
            resolve(clausesByGroup.get(groupKey) || []);
          }));
        },
        get: function(key) {}
      };
      ruleRepo = {
        basePath: '/api/rules-engine/rules/',
        inward: {
          transform: function(_rule, key) {
            var groups = Core.Collections.asArray(_rule.groups || {}, ruleRepo.inward.transformGroup);
            var rule = {
              $key: key,
              name: _rule.name,
              enabled: _rule.enabled,
              groups: []
            };
            return Promise.all(groups).then((function(groupsAry) {
              rule.groups = groupsAry;
              return rule;
            }));
          },
          transformGroup: function(_group, key) {
            var clausesPromises = [];
            var group = {
              $key: key,
              operator: _group.operator,
              clauses: {}
            };
            clausesPromises.push(clauseRepo.getByGroup(key).then((function(clauses) {
              group.clauses = clauses;
              return group;
            })));
            return Promise.all(clausesPromises).then((function() {
              return group;
            }));
          }
        },
        outward: {transform: function(rule) {
            var _rule = {
              name: rule.name,
              enabled: rule.enabled,
              groups: {}
            };
            var clauses = [];
            rule.groups.forEach((function(group) {
              var _group = {operator: group.operator};
              _rule.groups[group.$key] = group;
              group.clauses.forEach((function(clause) {
                clause.owningGroup = group.$key;
                clauses.push(clause);
              }));
            }));
            return {
              key: rule.$key,
              val: _rule,
              clauses: clauses
            };
          }},
        push: function(rule) {
          if (rule.$key) {
            throw new Error("Cannot push Rule: rule already has a key. Use #set()");
          }
          rule.$key = Core.Key.next();
          return ruleRepo.set(rule);
        },
        set: function(rule) {
          rule = Check.exists(rule, "Cannot save null rule.");
          Check.notEmpty(rule.name, "Name is required to save a Rule");
          return new Promise((function(resolve, reject) {
            var _xForm = ruleRepo.outward.transform(rule);
            var path = ruleRepo.basePath + _xForm.key;
            var previous = Storage.getItem(path);
            Storage.setItem(path, _xForm.val);
            var clausePromises = _xForm.clauses.map(clauseRepo.set);
            Promise.all(clausePromises).then((function(_clausesAry) {
              if (previous) {
                RuleEngine.actions.updateRule(rule);
              } else {
                RuleEngine.actions.addRule(rule);
              }
              resolve(rule);
            }), (function(e) {
              throw e;
            }));
          }));
        },
        get: function(ruleKey) {
          var _rule = Storage.getItem(ruleRepo.basePath + ruleKey);
          return ruleRepo.inward.transform(_rule, ruleKey).then((function(rule) {
            RuleEngine.actions.addRule(rule);
            return rule;
          }));
        },
        remove: function(ruleKey) {
          return new Promise((function(resolve, reject) {
            var path = ruleRepo.basePath + ruleKey;
            resolve(Storage.removeItem(path));
          }));
        },
        init: function() {
          var paths = Storage.childKeys(ruleRepo.basePath);
          var rules = paths.map(ruleRepo.get);
          return Promise.all(rules).then((function(resolvedRules) {
            return resolvedRules;
          }));
        }
      };
      $__export("ruleRepo", ruleRepo);
    }
  };
});

System.register("angular2/src/change_detection/parser/lexer", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/lexer";
  var Injectable,
      List,
      ListWrapper,
      SetWrapper,
      int,
      NumberWrapper,
      StringJoiner,
      StringWrapper,
      TOKEN_TYPE_CHARACTER,
      TOKEN_TYPE_IDENTIFIER,
      TOKEN_TYPE_KEYWORD,
      TOKEN_TYPE_STRING,
      TOKEN_TYPE_OPERATOR,
      TOKEN_TYPE_NUMBER,
      Lexer,
      Token,
      EOF,
      $EOF,
      $TAB,
      $LF,
      $VTAB,
      $FF,
      $CR,
      $SPACE,
      $BANG,
      $DQ,
      $HASH,
      $$,
      $PERCENT,
      $AMPERSAND,
      $SQ,
      $LPAREN,
      $RPAREN,
      $STAR,
      $PLUS,
      $COMMA,
      $MINUS,
      $PERIOD,
      $SLASH,
      $COLON,
      $SEMICOLON,
      $LT,
      $EQ,
      $GT,
      $QUESTION,
      $0,
      $9,
      $A,
      $E,
      $Z,
      $LBRACKET,
      $BACKSLASH,
      $RBRACKET,
      $CARET,
      $_,
      $a,
      $e,
      $f,
      $n,
      $r,
      $t,
      $u,
      $v,
      $z,
      $LBRACE,
      $BAR,
      $RBRACE,
      $NBSP,
      ScannerError,
      _Scanner,
      OPERATORS,
      KEYWORDS;
  function newCharacterToken(index, code) {
    return new Token(index, TOKEN_TYPE_CHARACTER, code, StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TOKEN_TYPE_IDENTIFIER, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TOKEN_TYPE_KEYWORD, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TOKEN_TYPE_OPERATOR, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TOKEN_TYPE_STRING, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TOKEN_TYPE_NUMBER, n, "");
  }
  function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == $$);
  }
  function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) || (code == $_) || (code == $$);
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      int = $__m.int;
      NumberWrapper = $__m.NumberWrapper;
      StringJoiner = $__m.StringJoiner;
      StringWrapper = $__m.StringWrapper;
    }],
    execute: function() {
      TOKEN_TYPE_CHARACTER = 1;
      $__export("TOKEN_TYPE_CHARACTER", TOKEN_TYPE_CHARACTER);
      TOKEN_TYPE_IDENTIFIER = 2;
      $__export("TOKEN_TYPE_IDENTIFIER", TOKEN_TYPE_IDENTIFIER);
      TOKEN_TYPE_KEYWORD = 3;
      $__export("TOKEN_TYPE_KEYWORD", TOKEN_TYPE_KEYWORD);
      TOKEN_TYPE_STRING = 4;
      $__export("TOKEN_TYPE_STRING", TOKEN_TYPE_STRING);
      TOKEN_TYPE_OPERATOR = 5;
      $__export("TOKEN_TYPE_OPERATOR", TOKEN_TYPE_OPERATOR);
      TOKEN_TYPE_NUMBER = 6;
      $__export("TOKEN_TYPE_NUMBER", TOKEN_TYPE_NUMBER);
      Lexer = (function() {
        function Lexer() {}
        return ($traceurRuntime.createClass)(Lexer, {tokenize: function(text) {
            var scanner = new _Scanner(text);
            var tokens = [];
            var token = scanner.scanToken();
            while (token != null) {
              ListWrapper.push(tokens, token);
              token = scanner.scanToken();
            }
            return tokens;
          }}, {});
      }());
      $__export("Lexer", Lexer);
      Object.defineProperty(Lexer, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(Lexer.prototype.tokenize, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Token = (function() {
        function Token(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this._numValue = numValue;
          this._strValue = strValue;
        }
        return ($traceurRuntime.createClass)(Token, {
          isCharacter: function(code) {
            return (this.type == TOKEN_TYPE_CHARACTER && this._numValue == code);
          },
          isNumber: function() {
            return (this.type == TOKEN_TYPE_NUMBER);
          },
          isString: function() {
            return (this.type == TOKEN_TYPE_STRING);
          },
          isOperator: function(operater) {
            return (this.type == TOKEN_TYPE_OPERATOR && this._strValue == operater);
          },
          isIdentifier: function() {
            return (this.type == TOKEN_TYPE_IDENTIFIER);
          },
          isKeyword: function() {
            return (this.type == TOKEN_TYPE_KEYWORD);
          },
          isKeywordVar: function() {
            return (this.type == TOKEN_TYPE_KEYWORD && this._strValue == "var");
          },
          isKeywordNull: function() {
            return (this.type == TOKEN_TYPE_KEYWORD && this._strValue == "null");
          },
          isKeywordUndefined: function() {
            return (this.type == TOKEN_TYPE_KEYWORD && this._strValue == "undefined");
          },
          isKeywordTrue: function() {
            return (this.type == TOKEN_TYPE_KEYWORD && this._strValue == "true");
          },
          isKeywordFalse: function() {
            return (this.type == TOKEN_TYPE_KEYWORD && this._strValue == "false");
          },
          toNumber: function() {
            return (this.type == TOKEN_TYPE_NUMBER) ? this._numValue : -1;
          },
          toString: function() {
            var type = this.type;
            if (type >= TOKEN_TYPE_CHARACTER && type <= TOKEN_TYPE_STRING) {
              return this._strValue;
            } else if (type == TOKEN_TYPE_NUMBER) {
              return this._numValue.toString();
            } else {
              return null;
            }
          }
        }, {});
      }());
      $__export("Token", Token);
      Object.defineProperty(Token, "parameters", {get: function() {
          return [[int], [int], [assert.type.number], [assert.type.string]];
        }});
      Object.defineProperty(Token.prototype.isCharacter, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(Token.prototype.isOperator, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(newCharacterToken, "parameters", {get: function() {
          return [[int], [int]];
        }});
      Object.defineProperty(newIdentifierToken, "parameters", {get: function() {
          return [[int], [assert.type.string]];
        }});
      Object.defineProperty(newKeywordToken, "parameters", {get: function() {
          return [[int], [assert.type.string]];
        }});
      Object.defineProperty(newOperatorToken, "parameters", {get: function() {
          return [[int], [assert.type.string]];
        }});
      Object.defineProperty(newStringToken, "parameters", {get: function() {
          return [[int], [assert.type.string]];
        }});
      Object.defineProperty(newNumberToken, "parameters", {get: function() {
          return [[int], [assert.type.number]];
        }});
      EOF = new Token(-1, 0, 0, "");
      $__export("EOF", EOF);
      $EOF = 0;
      $__export("$EOF", $EOF);
      $TAB = 9;
      $__export("$TAB", $TAB);
      $LF = 10;
      $__export("$LF", $LF);
      $VTAB = 11;
      $__export("$VTAB", $VTAB);
      $FF = 12;
      $__export("$FF", $FF);
      $CR = 13;
      $__export("$CR", $CR);
      $SPACE = 32;
      $__export("$SPACE", $SPACE);
      $BANG = 33;
      $__export("$BANG", $BANG);
      $DQ = 34;
      $__export("$DQ", $DQ);
      $HASH = 35;
      $__export("$HASH", $HASH);
      $$ = 36;
      $__export("$$", $$);
      $PERCENT = 37;
      $__export("$PERCENT", $PERCENT);
      $AMPERSAND = 38;
      $__export("$AMPERSAND", $AMPERSAND);
      $SQ = 39;
      $__export("$SQ", $SQ);
      $LPAREN = 40;
      $__export("$LPAREN", $LPAREN);
      $RPAREN = 41;
      $__export("$RPAREN", $RPAREN);
      $STAR = 42;
      $__export("$STAR", $STAR);
      $PLUS = 43;
      $__export("$PLUS", $PLUS);
      $COMMA = 44;
      $__export("$COMMA", $COMMA);
      $MINUS = 45;
      $__export("$MINUS", $MINUS);
      $PERIOD = 46;
      $__export("$PERIOD", $PERIOD);
      $SLASH = 47;
      $__export("$SLASH", $SLASH);
      $COLON = 58;
      $__export("$COLON", $COLON);
      $SEMICOLON = 59;
      $__export("$SEMICOLON", $SEMICOLON);
      $LT = 60;
      $__export("$LT", $LT);
      $EQ = 61;
      $__export("$EQ", $EQ);
      $GT = 62;
      $__export("$GT", $GT);
      $QUESTION = 63;
      $__export("$QUESTION", $QUESTION);
      $0 = 48;
      $9 = 57;
      $A = 65, $E = 69, $Z = 90;
      $LBRACKET = 91;
      $__export("$LBRACKET", $LBRACKET);
      $BACKSLASH = 92;
      $__export("$BACKSLASH", $BACKSLASH);
      $RBRACKET = 93;
      $__export("$RBRACKET", $RBRACKET);
      $CARET = 94;
      $_ = 95;
      $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
      $LBRACE = 123;
      $__export("$LBRACE", $LBRACE);
      $BAR = 124;
      $__export("$BAR", $BAR);
      $RBRACE = 125;
      $__export("$RBRACE", $RBRACE);
      $NBSP = 160;
      ScannerError = (function($__super) {
        function ScannerError(message) {
          $traceurRuntime.superConstructor(ScannerError).call(this);
          this.message = message;
        }
        return ($traceurRuntime.createClass)(ScannerError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      $__export("ScannerError", ScannerError);
      _Scanner = (function() {
        function _Scanner(input) {
          this.input = input;
          this.length = input.length;
          this.peek = 0;
          this.index = -1;
          this.advance();
        }
        return ($traceurRuntime.createClass)(_Scanner, {
          advance: function() {
            this.peek = ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
          },
          scanToken: function() {
            var input = this.input,
                length = this.length,
                peek = this.peek,
                index = this.index;
            while (peek <= $SPACE) {
              if (++index >= length) {
                peek = $EOF;
                break;
              } else {
                peek = StringWrapper.charCodeAt(input, index);
              }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
              return null;
            }
            if (isIdentifierStart(peek))
              return this.scanIdentifier();
            if (isDigit(peek))
              return this.scanNumber(index);
            var start = index;
            switch (peek) {
              case $PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                return this.scanString();
              case $HASH:
                return this.scanOperator(start, StringWrapper.fromCharCode(peek));
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
              case $QUESTION:
                return this.scanOperator(start, StringWrapper.fromCharCode(peek));
              case $LT:
              case $GT:
              case $BANG:
              case $EQ:
                return this.scanComplexOperator(start, $EQ, StringWrapper.fromCharCode(peek), '=');
              case $AMPERSAND:
                return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
              case $BAR:
                return this.scanComplexOperator(start, $BAR, '|', '|');
              case $NBSP:
                while (isWhitespace(this.peek))
                  this.advance();
                return this.scanToken();
            }
            this.error(("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]"), 0);
            return null;
          },
          scanCharacter: function(start, code) {
            assert(this.peek == code);
            this.advance();
            return newCharacterToken(start, code);
          },
          scanOperator: function(start, str) {
            assert(this.peek == StringWrapper.charCodeAt(str, 0));
            assert(SetWrapper.has(OPERATORS, str));
            this.advance();
            return newOperatorToken(start, str);
          },
          scanComplexOperator: function(start, code, one, two) {
            assert(this.peek == StringWrapper.charCodeAt(one, 0));
            this.advance();
            var str = one;
            while (this.peek == code) {
              this.advance();
              str += two;
            }
            assert(SetWrapper.has(OPERATORS, str));
            return newOperatorToken(start, str);
          },
          scanIdentifier: function() {
            assert(isIdentifierStart(this.peek));
            var start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
              this.advance();
            var str = this.input.substring(start, this.index);
            if (SetWrapper.has(KEYWORDS, str)) {
              return newKeywordToken(start, str);
            } else {
              return newIdentifierToken(start, str);
            }
          },
          scanNumber: function(start) {
            assert(isDigit(this.peek));
            var simple = (this.index === start);
            this.advance();
            while (true) {
              if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
                simple = false;
              } else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                  this.advance();
                if (!isDigit(this.peek))
                  this.error('Invalid exponent', -1);
                simple = false;
              } else {
                break;
              }
              this.advance();
            }
            var str = this.input.substring(start, this.index);
            var value = simple ? NumberWrapper.parseIntAutoRadix(str) : NumberWrapper.parseFloat(str);
            return newNumberToken(start, value);
          },
          scanString: function() {
            assert(this.peek == $SQ || this.peek == $DQ);
            var start = this.index;
            var quote = this.peek;
            this.advance();
            var buffer;
            var marker = this.index;
            var input = this.input;
            while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                if (buffer == null)
                  buffer = new StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode = void 0;
                if (this.peek == $u) {
                  var hex = input.substring(this.index + 1, this.index + 5);
                  try {
                    unescapedCode = NumberWrapper.parseInt(hex, 16);
                  } catch (e) {
                    this.error(("Invalid unicode escape [\\u" + hex + "]"), 0);
                  }
                  for (var i = 0; i < 5; i++) {
                    this.advance();
                  }
                } else {
                  unescapedCode = unescape(this.peek);
                  this.advance();
                }
                buffer.add(StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
              } else if (this.peek == $EOF) {
                this.error('Unterminated quote', 0);
              } else {
                this.advance();
              }
            }
            var last = input.substring(marker, this.index);
            this.advance();
            var unescaped = last;
            if (buffer != null) {
              buffer.add(last);
              unescaped = buffer.toString();
            }
            return newStringToken(start, unescaped);
          },
          error: function(message, offset) {
            var position = this.index + offset;
            throw new ScannerError(("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]"));
          }
        }, {});
      }());
      Object.defineProperty(_Scanner, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
      Object.defineProperty(_Scanner.prototype.scanCharacter, "parameters", {get: function() {
          return [[int], [int]];
        }});
      Object.defineProperty(_Scanner.prototype.scanOperator, "parameters", {get: function() {
          return [[int], [assert.type.string]];
        }});
      Object.defineProperty(_Scanner.prototype.scanComplexOperator, "parameters", {get: function() {
          return [[int], [int], [assert.type.string], [assert.type.string]];
        }});
      Object.defineProperty(_Scanner.prototype.scanNumber, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(_Scanner.prototype.error, "parameters", {get: function() {
          return [[assert.type.string], [int]];
        }});
      Object.defineProperty(isWhitespace, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(isIdentifierStart, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(isIdentifierPart, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(isDigit, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(isExponentStart, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(isExponentSign, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(unescape, "parameters", {get: function() {
          return [[int]];
        }});
      OPERATORS = SetWrapper.createFromList(['+', '-', '*', '/', '%', '^', '=', '==', '!=', '===', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?', '#']);
      KEYWORDS = SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false']);
    }
  };
});

System.register("angular2/src/core/compiler/element_ref", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref", "angular2/src/render/dom/direct_dom_renderer"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_ref";
  var DOM,
      normalizeBlank,
      ViewRef,
      DirectDomViewRef,
      ElementRef;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      normalizeBlank = $__m.normalizeBlank;
    }, function($__m) {
      ViewRef = $__m.ViewRef;
    }, function($__m) {
      DirectDomViewRef = $__m.DirectDomViewRef;
    }],
    execute: function() {
      ElementRef = (function() {
        function ElementRef(parentView, boundElementIndex) {
          this.parentView = parentView;
          this.boundElementIndex = boundElementIndex;
        }
        return ($traceurRuntime.createClass)(ElementRef, {
          get domElement() {
            var renderViewRef = this.parentView.render;
            return renderViewRef.delegate.boundElements[this.boundElementIndex];
          },
          getAttribute: function(name) {
            return normalizeBlank(DOM.getAttribute(this.domElement, name));
          }
        }, {});
      }());
      $__export("ElementRef", ElementRef);
      Object.defineProperty(ElementRef, "parameters", {get: function() {
          return [[ViewRef], [assert.type.number]];
        }});
      Object.defineProperty(ElementRef.prototype.getAttribute, "parameters", {get: function() {
          return [[assert.type.string]];
        }});
    }
  };
});

System.register("src/rules-engine/RuleEngine.es6", ["src/rules-engine/api/RuleEngineAPI.ts", "src/rules-engine/actions/RuleEngineActionCreators.es6", "src/rules-engine/stores/RuleEngineStore.ts"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine/RuleEngine.es6";
  var api,
      actions,
      actionTypes,
      RuleStore;
  return {
    setters: [function($__m) {
      api = $__m;
    }, function($__m) {
      actions = $__m.actions;
      actionTypes = $__m.actionTypes;
    }, function($__m) {
      RuleStore = $__m.RuleStore;
    }],
    execute: function() {
      $__export("api", api), $__export("actions", actions), $__export("actionTypes", actionTypes), $__export("store", RuleStore);
    }
  };
});

System.register("angular2/change_detection", ["angular2/src/change_detection/parser/ast", "angular2/src/change_detection/parser/lexer", "angular2/src/change_detection/parser/parser", "angular2/src/change_detection/parser/locals", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/interfaces", "angular2/src/change_detection/constants", "angular2/src/change_detection/proto_change_detector", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/pipes/pipe_registry", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/pipes/pipe", "angular2/src/change_detection/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/change_detection";
  return {
    setters: [function($__m) {
      $__export("ASTWithSource", $__m.ASTWithSource);
      $__export("AST", $__m.AST);
      $__export("AstTransformer", $__m.AstTransformer);
      $__export("AccessMember", $__m.AccessMember);
      $__export("LiteralArray", $__m.LiteralArray);
      $__export("ImplicitReceiver", $__m.ImplicitReceiver);
    }, function($__m) {
      $__export("Lexer", $__m.Lexer);
    }, function($__m) {
      $__export("Parser", $__m.Parser);
    }, function($__m) {
      $__export("Locals", $__m.Locals);
    }, function($__m) {
      $__export("ExpressionChangedAfterItHasBeenChecked", $__m.ExpressionChangedAfterItHasBeenChecked);
      $__export("ChangeDetectionError", $__m.ChangeDetectionError);
    }, function($__m) {
      $__export("ProtoChangeDetector", $__m.ProtoChangeDetector);
      $__export("ChangeDispatcher", $__m.ChangeDispatcher);
      $__export("ChangeDetector", $__m.ChangeDetector);
      $__export("ChangeDetection", $__m.ChangeDetection);
    }, function($__m) {
      $__export("CHECK_ONCE", $__m.CHECK_ONCE);
      $__export("CHECK_ALWAYS", $__m.CHECK_ALWAYS);
      $__export("DETACHED", $__m.DETACHED);
      $__export("CHECKED", $__m.CHECKED);
      $__export("ON_PUSH", $__m.ON_PUSH);
      $__export("DEFAULT", $__m.DEFAULT);
    }, function($__m) {
      $__export("DynamicProtoChangeDetector", $__m.DynamicProtoChangeDetector);
      $__export("JitProtoChangeDetector", $__m.JitProtoChangeDetector);
    }, function($__m) {
      $__export("BindingRecord", $__m.BindingRecord);
    }, function($__m) {
      $__export("DirectiveIndex", $__m.DirectiveIndex);
      $__export("DirectiveRecord", $__m.DirectiveRecord);
    }, function($__m) {
      $__export("DynamicChangeDetector", $__m.DynamicChangeDetector);
    }, function($__m) {
      $__export("ChangeDetectorRef", $__m.ChangeDetectorRef);
    }, function($__m) {
      $__export("PipeRegistry", $__m.PipeRegistry);
    }, function($__m) {
      $__export("uninitialized", $__m.uninitialized);
    }, function($__m) {
      $__export("WrappedValue", $__m.WrappedValue);
      $__export("Pipe", $__m.Pipe);
    }, function($__m) {
      $__export("defaultPipes", $__m.defaultPipes);
      $__export("DynamicChangeDetection", $__m.DynamicChangeDetection);
      $__export("JitChangeDetection", $__m.JitChangeDetection);
      $__export("defaultPipeRegistry", $__m.defaultPipeRegistry);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/compiler/view_manager", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/view_container_ref", "angular2/src/render/api", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_pool"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager";
  var Injector,
      Injectable,
      Binding,
      ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      isPresent,
      isBlank,
      BaseException,
      viewModule,
      ElementRef,
      ProtoViewRef,
      ViewRef,
      internalView,
      internalProtoView,
      ViewContainerRef,
      Renderer,
      RenderViewRef,
      RenderViewContainerRef,
      AppViewManagerUtils,
      AppViewPool,
      AppViewManager;
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      Injectable = $__m.Injectable;
      Binding = $__m.Binding;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      ProtoViewRef = $__m.ProtoViewRef;
      ViewRef = $__m.ViewRef;
      internalView = $__m.internalView;
      internalProtoView = $__m.internalProtoView;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      Renderer = $__m.Renderer;
      RenderViewRef = $__m.RenderViewRef;
      RenderViewContainerRef = $__m.RenderViewContainerRef;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
    }],
    execute: function() {
      AppViewManager = (function() {
        function AppViewManager(viewPool, utils, renderer) {
          this._renderer = renderer;
          this._viewPool = viewPool;
          this._utils = utils;
        }
        return ($traceurRuntime.createClass)(AppViewManager, {
          getViewContainer: function(location) {
            var hostView = internalView(location.parentView);
            return hostView.elementInjectors[location.boundElementIndex].getViewContainerRef();
          },
          getComponent: function(hostLocation) {
            var hostView = internalView(hostLocation.parentView);
            var boundElementIndex = hostLocation.boundElementIndex;
            return this._utils.getComponentInstance(hostView, boundElementIndex);
          },
          createDynamicComponentView: function(hostLocation, componentProtoViewRef, componentBinding, injector) {
            var componentProtoView = internalProtoView(componentProtoViewRef);
            var hostView = internalView(hostLocation.parentView);
            var boundElementIndex = hostLocation.boundElementIndex;
            var binder = hostView.proto.elementBinders[boundElementIndex];
            if (!binder.hasDynamicComponent()) {
              throw new BaseException(("There is no dynamic component directive at element " + boundElementIndex));
            }
            var componentView = this._createViewRecurse(componentProtoView);
            var renderViewRefs = this._renderer.createDynamicComponentView(hostView.render, boundElementIndex, componentProtoView.render);
            componentView.render = renderViewRefs[0];
            this._utils.attachComponentView(hostView, boundElementIndex, componentView);
            this._utils.hydrateDynamicComponentInElementInjector(hostView, boundElementIndex, componentBinding, injector);
            this._utils.hydrateComponentView(hostView, boundElementIndex);
            this._viewHydrateRecurse(componentView, renderViewRefs, 1);
            return new ViewRef(componentView);
          },
          createInPlaceHostView: function(parentComponentLocation, hostElementSelector, hostProtoViewRef, injector) {
            var hostProtoView = internalProtoView(hostProtoViewRef);
            var parentComponentHostView = null;
            var parentComponentBoundElementIndex = null;
            var parentRenderViewRef = null;
            if (isPresent(parentComponentLocation)) {
              parentComponentHostView = internalView(parentComponentLocation.parentView);
              parentComponentBoundElementIndex = parentComponentLocation.boundElementIndex;
              parentRenderViewRef = parentComponentHostView.componentChildViews[parentComponentBoundElementIndex].render;
            }
            var hostView = this._createViewRecurse(hostProtoView);
            var renderViewRefs = this._renderer.createInPlaceHostView(parentRenderViewRef, hostElementSelector, hostProtoView.render);
            hostView.render = renderViewRefs[0];
            this._utils.attachAndHydrateInPlaceHostView(parentComponentHostView, parentComponentBoundElementIndex, hostView, injector);
            this._viewHydrateRecurse(hostView, renderViewRefs, 1);
            return new ViewRef(hostView);
          },
          destroyInPlaceHostView: function(parentComponentLocation, hostViewRef) {
            var hostView = internalView(hostViewRef);
            var parentView = null;
            var parentRenderViewRef = null;
            if (isPresent(parentComponentLocation)) {
              parentView = internalView(parentComponentLocation.parentView).componentChildViews[parentComponentLocation.boundElementIndex];
              parentRenderViewRef = parentView.render;
            }
            var hostViewRenderRef = hostView.render;
            this._viewDehydrateRecurse(hostView);
            this._utils.detachInPlaceHostView(parentView, hostView);
            this._renderer.destroyInPlaceHostView(parentRenderViewRef, hostViewRenderRef);
            this._destroyView(hostView);
          },
          createViewInContainer: function(viewContainerLocation, atIndex, protoViewRef) {
            var injector = arguments[3] !== (void 0) ? arguments[3] : null;
            var protoView = internalProtoView(protoViewRef);
            var parentView = internalView(viewContainerLocation.parentView);
            var boundElementIndex = viewContainerLocation.boundElementIndex;
            var view = this._createViewRecurse(protoView);
            var renderViewRefs = this._renderer.createViewInContainer(this._getRenderViewContainerRef(parentView, boundElementIndex), atIndex, view.proto.render);
            view.render = renderViewRefs[0];
            this._utils.attachViewInContainer(parentView, boundElementIndex, atIndex, view);
            this._utils.hydrateViewInContainer(parentView, boundElementIndex, atIndex, injector);
            this._viewHydrateRecurse(view, renderViewRefs, 1);
            return new ViewRef(view);
          },
          destroyViewInContainer: function(viewContainerLocation, atIndex) {
            var parentView = internalView(viewContainerLocation.parentView);
            var boundElementIndex = viewContainerLocation.boundElementIndex;
            var viewContainer = parentView.viewContainers[boundElementIndex];
            var view = viewContainer.views[atIndex];
            this._viewDehydrateRecurse(view);
            this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
            this._renderer.destroyViewInContainer(this._getRenderViewContainerRef(parentView, boundElementIndex), atIndex);
            this._destroyView(view);
          },
          attachViewInContainer: function(viewContainerLocation, atIndex, viewRef) {
            var view = internalView(viewRef);
            var parentView = internalView(viewContainerLocation.parentView);
            var boundElementIndex = viewContainerLocation.boundElementIndex;
            this._utils.attachViewInContainer(parentView, boundElementIndex, atIndex, view);
            this._renderer.insertViewIntoContainer(this._getRenderViewContainerRef(parentView, boundElementIndex), atIndex, view.render);
            return viewRef;
          },
          detachViewInContainer: function(viewContainerLocation, atIndex) {
            var parentView = internalView(viewContainerLocation.parentView);
            var boundElementIndex = viewContainerLocation.boundElementIndex;
            var viewContainer = parentView.viewContainers[boundElementIndex];
            var view = viewContainer.views[atIndex];
            this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
            this._renderer.detachViewFromContainer(this._getRenderViewContainerRef(parentView, boundElementIndex), atIndex);
            return new ViewRef(view);
          },
          _getRenderViewContainerRef: function(parentView, boundElementIndex) {
            return new RenderViewContainerRef(parentView.render, boundElementIndex);
          },
          _createViewRecurse: function(protoView) {
            var view = this._viewPool.getView(protoView);
            if (isBlank(view)) {
              view = this._utils.createView(protoView, this, this._renderer);
              var binders = protoView.elementBinders;
              for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                var binder = binders[binderIdx];
                if (binder.hasStaticComponent()) {
                  var childView = this._createViewRecurse(binder.nestedProtoView);
                  this._utils.attachComponentView(view, binderIdx, childView);
                }
              }
            }
            return view;
          },
          _destroyView: function(view) {
            this._viewPool.returnView(view);
          },
          _viewHydrateRecurse: function(view, renderComponentViewRefs, renderComponentIndex) {
            this._renderer.setEventDispatcher(view.render, view);
            var binders = view.proto.elementBinders;
            for (var i = 0; i < binders.length; ++i) {
              if (binders[i].hasStaticComponent()) {
                var childView = view.componentChildViews[i];
                childView.render = renderComponentViewRefs[renderComponentIndex++];
                this._utils.hydrateComponentView(view, i);
                renderComponentIndex = this._viewHydrateRecurse(view.componentChildViews[i], renderComponentViewRefs, renderComponentIndex);
              }
            }
            return renderComponentIndex;
          },
          _viewDehydrateRecurse: function(view) {
            this._utils.dehydrateView(view);
            var binders = view.proto.elementBinders;
            for (var i = 0; i < binders.length; i++) {
              var componentView = view.componentChildViews[i];
              if (isPresent(componentView)) {
                this._viewDehydrateRecurse(componentView);
                if (binders[i].hasDynamicComponent()) {
                  this._utils.detachComponentView(view, i);
                  this._destroyView(componentView);
                }
              }
              var vc = view.viewContainers[i];
              if (isPresent(vc)) {
                for (var j = vc.views.length - 1; j >= 0; j--) {
                  var childView = vc.views[j];
                  this._viewDehydrateRecurse(childView);
                  this._utils.detachViewInContainer(view, i, j);
                  this._destroyView(childView);
                }
              }
            }
            for (var i = 0; i < view.imperativeHostViews.length; i++) {
              var hostView = view.imperativeHostViews[i];
              this._viewDehydrateRecurse(hostView);
              this._utils.detachInPlaceHostView(view, hostView);
              this._destroyView(hostView);
            }
            view.render = null;
          }
        }, {});
      }());
      $__export("AppViewManager", AppViewManager);
      Object.defineProperty(AppViewManager, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(AppViewManager, "parameters", {get: function() {
          return [[AppViewPool], [AppViewManagerUtils], [Renderer]];
        }});
      Object.defineProperty(AppViewManager.prototype.getViewContainer, "parameters", {get: function() {
          return [[ElementRef]];
        }});
      Object.defineProperty(AppViewManager.prototype.getComponent, "parameters", {get: function() {
          return [[ElementRef]];
        }});
      Object.defineProperty(AppViewManager.prototype.createDynamicComponentView, "parameters", {get: function() {
          return [[ElementRef], [ProtoViewRef], [Binding], [Injector]];
        }});
      Object.defineProperty(AppViewManager.prototype.createInPlaceHostView, "parameters", {get: function() {
          return [[ElementRef], [], [ProtoViewRef], [Injector]];
        }});
      Object.defineProperty(AppViewManager.prototype.destroyInPlaceHostView, "parameters", {get: function() {
          return [[ElementRef], [ViewRef]];
        }});
      Object.defineProperty(AppViewManager.prototype.createViewInContainer, "parameters", {get: function() {
          return [[ElementRef], [assert.type.number], [ProtoViewRef], [Injector]];
        }});
      Object.defineProperty(AppViewManager.prototype.destroyViewInContainer, "parameters", {get: function() {
          return [[ElementRef], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManager.prototype.attachViewInContainer, "parameters", {get: function() {
          return [[ElementRef], [assert.type.number], [ViewRef]];
        }});
      Object.defineProperty(AppViewManager.prototype.detachViewInContainer, "parameters", {get: function() {
          return [[ElementRef], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManager.prototype._getRenderViewContainerRef, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManager.prototype._createViewRecurse, "parameters", {get: function() {
          return [[viewModule.AppProtoView]];
        }});
      Object.defineProperty(AppViewManager.prototype._destroyView, "parameters", {get: function() {
          return [[viewModule.AppView]];
        }});
      Object.defineProperty(AppViewManager.prototype._viewHydrateRecurse, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.genericType(List, RenderViewRef)], [assert.type.number]];
        }});
      Object.defineProperty(AppViewManager.prototype._viewDehydrateRecurse, "parameters", {get: function() {
          return [[viewModule.AppView]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/element_injector", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/math", "angular2/src/facade/collection", "angular2/di", "angular2/src/core/annotations_impl/visibility", "angular2/src/core/annotations_impl/di", "angular2/src/core/compiler/view", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/view_ref", "angular2/src/core/annotations_impl/annotations", "angular2/change_detection", "angular2/src/core/compiler/query_list", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_injector";
  var isPresent,
      isBlank,
      Type,
      int,
      BaseException,
      EventEmitter,
      ObservableWrapper,
      Math,
      List,
      ListWrapper,
      MapWrapper,
      Injector,
      Key,
      Dependency,
      bind,
      Binding,
      ResolvedBinding,
      NoBindingError,
      AbstractBindingError,
      CyclicDependencyError,
      Parent,
      Ancestor,
      Attribute,
      Query,
      viewModule,
      avmModule,
      ViewContainerRef,
      ElementRef,
      ProtoViewRef,
      ViewRef,
      Directive,
      Component,
      onChange,
      onDestroy,
      onAllChangesDone,
      ChangeDetector,
      ChangeDetectorRef,
      QueryList,
      reflector,
      _MAX_DIRECTIVE_CONSTRUCTION_COUNTER,
      MAX_DEPTH,
      _undefined,
      _staticKeys,
      StaticKeys,
      TreeNode,
      DirectiveDependency,
      DirectiveBinding,
      PreBuiltObjects,
      EventEmitterAccessor,
      ProtoElementInjector,
      ElementInjector,
      OutOfBoundsAccess,
      QueryError,
      QueryRef;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      Type = $__m.Type;
      int = $__m.int;
      BaseException = $__m.BaseException;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      Math = $__m.Math;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      Injector = $__m.Injector;
      Key = $__m.Key;
      Dependency = $__m.Dependency;
      bind = $__m.bind;
      Binding = $__m.Binding;
      ResolvedBinding = $__m.ResolvedBinding;
      NoBindingError = $__m.NoBindingError;
      AbstractBindingError = $__m.AbstractBindingError;
      CyclicDependencyError = $__m.CyclicDependencyError;
    }, function($__m) {
      Parent = $__m.Parent;
      Ancestor = $__m.Ancestor;
    }, function($__m) {
      Attribute = $__m.Attribute;
      Query = $__m.Query;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      avmModule = $__m;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      ProtoViewRef = $__m.ProtoViewRef;
      ViewRef = $__m.ViewRef;
    }, function($__m) {
      Directive = $__m.Directive;
      Component = $__m.Component;
      onChange = $__m.onChange;
      onDestroy = $__m.onDestroy;
      onAllChangesDone = $__m.onAllChangesDone;
    }, function($__m) {
      ChangeDetector = $__m.ChangeDetector;
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      _MAX_DIRECTIVE_CONSTRUCTION_COUNTER = 10;
      MAX_DEPTH = Math.pow(2, 30) - 1;
      _undefined = new Object();
      StaticKeys = (function() {
        function StaticKeys() {
          this.viewManagerId = Key.get(avmModule.AppViewManager).id;
          this.protoViewId = Key.get(ProtoViewRef).id;
          this.viewContainerId = Key.get(ViewContainerRef).id;
          this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
          this.elementRefId = Key.get(ElementRef).id;
        }
        return ($traceurRuntime.createClass)(StaticKeys, {}, {instance: function() {
            if (isBlank(_staticKeys))
              _staticKeys = new StaticKeys();
            return _staticKeys;
          }});
      }());
      TreeNode = (function() {
        function TreeNode(parent) {
          this._head = null;
          this._tail = null;
          this._next = null;
          if (isPresent(parent))
            parent.addChild(this);
        }
        return ($traceurRuntime.createClass)(TreeNode, {
          _assertConsistency: function() {
            this._assertHeadBeforeTail();
            this._assertTailReachable();
            this._assertPresentInParentList();
          },
          _assertHeadBeforeTail: function() {
            if (isBlank(this._tail) && isPresent(this._head))
              throw new BaseException('null tail but non-null head');
          },
          _assertTailReachable: function() {
            if (isBlank(this._tail))
              return ;
            if (isPresent(this._tail._next))
              throw new BaseException('node after tail');
            var p = this._head;
            while (isPresent(p) && p != this._tail)
              p = p._next;
            if (isBlank(p) && isPresent(this._tail))
              throw new BaseException('tail not reachable.');
          },
          _assertPresentInParentList: function() {
            var p = this._parent;
            if (isBlank(p)) {
              return ;
            }
            var cur = p._head;
            while (isPresent(cur) && cur != this)
              cur = cur._next;
            if (isBlank(cur))
              throw new BaseException('node not reachable through parent.');
          },
          addChild: function(child) {
            if (isPresent(this._tail)) {
              this._tail._next = child;
              this._tail = child;
            } else {
              this._tail = this._head = child;
            }
            child._next = null;
            child._parent = this;
            this._assertConsistency();
          },
          addChildAfter: function(child, prevSibling) {
            this._assertConsistency();
            if (isBlank(prevSibling)) {
              var prevHead = this._head;
              this._head = child;
              child._next = prevHead;
              if (isBlank(this._tail))
                this._tail = child;
            } else if (isBlank(prevSibling._next)) {
              this.addChild(child);
              return ;
            } else {
              prevSibling._assertPresentInParentList();
              child._next = prevSibling._next;
              prevSibling._next = child;
            }
            child._parent = this;
            this._assertConsistency();
          },
          remove: function() {
            this._assertConsistency();
            if (isBlank(this.parent))
              return ;
            var nextSibling = this._next;
            var prevSibling = this._findPrev();
            if (isBlank(prevSibling)) {
              this.parent._head = this._next;
            } else {
              prevSibling._next = this._next;
            }
            if (isBlank(nextSibling)) {
              this._parent._tail = prevSibling;
            }
            this._parent._assertConsistency();
            this._parent = null;
            this._next = null;
            this._assertConsistency();
          },
          _findPrev: function() {
            var node = this.parent._head;
            if (node == this)
              return null;
            while (node._next !== this)
              node = node._next;
            return node;
          },
          get parent() {
            return this._parent;
          },
          get children() {
            var res = [];
            var child = this._head;
            while (child != null) {
              ListWrapper.push(res, child);
              child = child._next;
            }
            return res;
          }
        }, {});
      }());
      $__export("TreeNode", TreeNode);
      Object.defineProperty(TreeNode, "parameters", {get: function() {
          return [[TreeNode]];
        }});
      Object.defineProperty(TreeNode.prototype.addChild, "parameters", {get: function() {
          return [[TreeNode]];
        }});
      Object.defineProperty(TreeNode.prototype.addChildAfter, "parameters", {get: function() {
          return [[TreeNode], [TreeNode]];
        }});
      DirectiveDependency = (function($__super) {
        function DirectiveDependency(key, asPromise, lazy, optional, properties, depth, attributeName, queryDirective) {
          $traceurRuntime.superConstructor(DirectiveDependency).call(this, key, asPromise, lazy, optional, properties);
          this.depth = depth;
          this.attributeName = attributeName;
          this.queryDirective = queryDirective;
          this._verify();
        }
        return ($traceurRuntime.createClass)(DirectiveDependency, {_verify: function() {
            var count = 0;
            if (isPresent(this.queryDirective))
              count++;
            if (isPresent(this.attributeName))
              count++;
            if (count > 1)
              throw new BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
          }}, {
          createFrom: function(d) {
            return new DirectiveDependency(d.key, d.asPromise, d.lazy, d.optional, d.properties, DirectiveDependency._depth(d.properties), DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
          },
          _depth: function(properties) {
            if (properties.length == 0)
              return 0;
            if (ListWrapper.any(properties, (function(p) {
              return p instanceof Parent;
            })))
              return 1;
            if (ListWrapper.any(properties, (function(p) {
              return p instanceof Ancestor;
            })))
              return MAX_DEPTH;
            return 0;
          },
          _attributeName: function(properties) {
            var p = ListWrapper.find(properties, (function(p) {
              return p instanceof Attribute;
            }));
            return isPresent(p) ? p.attributeName : null;
          },
          _query: function(properties) {
            var p = ListWrapper.find(properties, (function(p) {
              return p instanceof Query;
            }));
            return isPresent(p) ? p.directive : null;
          }
        }, $__super);
      }(Dependency));
      $__export("DirectiveDependency", DirectiveDependency);
      Object.defineProperty(DirectiveDependency, "parameters", {get: function() {
          return [[Key], [assert.type.boolean], [assert.type.boolean], [assert.type.boolean], [List], [int], [assert.type.string], []];
        }});
      Object.defineProperty(DirectiveDependency.createFrom, "parameters", {get: function() {
          return [[Dependency]];
        }});
      DirectiveBinding = (function($__super) {
        function DirectiveBinding(key, factory, dependencies, providedAsPromise, annotation) {
          $traceurRuntime.superConstructor(DirectiveBinding).call(this, key, factory, dependencies, providedAsPromise);
          this.callOnDestroy = isPresent(annotation) && annotation.hasLifecycleHook(onDestroy);
          this.callOnChange = isPresent(annotation) && annotation.hasLifecycleHook(onChange);
          this.callOnAllChangesDone = isPresent(annotation) && annotation.hasLifecycleHook(onAllChangesDone);
          this.annotation = annotation;
          if (annotation instanceof Component && isPresent(annotation.injectables)) {
            this.resolvedInjectables = Injector.resolve(annotation.injectables);
          }
        }
        return ($traceurRuntime.createClass)(DirectiveBinding, {
          get displayName() {
            return this.key.displayName;
          },
          get eventEmitters() {
            return isPresent(this.annotation) && isPresent(this.annotation.events) ? this.annotation.events : [];
          },
          get changeDetection() {
            if (this.annotation instanceof Component) {
              var c = this.annotation;
              return c.changeDetection;
            } else {
              return null;
            }
          }
        }, {
          createFromBinding: function(b, annotation) {
            var rb = b.resolve();
            var deps = ListWrapper.map(rb.dependencies, DirectiveDependency.createFrom);
            return new DirectiveBinding(rb.key, rb.factory, deps, rb.providedAsPromise, annotation);
          },
          createFromType: function(type, annotation) {
            var binding = new Binding(type, {toClass: type});
            return DirectiveBinding.createFromBinding(binding, annotation);
          }
        }, $__super);
      }(ResolvedBinding));
      $__export("DirectiveBinding", DirectiveBinding);
      Object.defineProperty(DirectiveBinding, "parameters", {get: function() {
          return [[Key], [Function], [List], [assert.type.boolean], [Directive]];
        }});
      Object.defineProperty(DirectiveBinding.createFromBinding, "parameters", {get: function() {
          return [[Binding], [Directive]];
        }});
      Object.defineProperty(DirectiveBinding.createFromType, "parameters", {get: function() {
          return [[Type], [Directive]];
        }});
      PreBuiltObjects = (function() {
        function PreBuiltObjects(viewManager, view, protoView) {
          this.viewManager = viewManager;
          this.view = view;
          this.protoView = protoView;
        }
        return ($traceurRuntime.createClass)(PreBuiltObjects, {}, {});
      }());
      $__export("PreBuiltObjects", PreBuiltObjects);
      Object.defineProperty(PreBuiltObjects, "parameters", {get: function() {
          return [[avmModule.AppViewManager], [viewModule.AppView], [viewModule.AppProtoView]];
        }});
      EventEmitterAccessor = (function() {
        function EventEmitterAccessor(eventName, getter) {
          this.eventName = eventName;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(EventEmitterAccessor, {subscribe: function(view, boundElementIndex, directive) {
            var $__0 = this;
            var eventEmitter = this.getter(directive);
            return ObservableWrapper.subscribe(eventEmitter, (function(eventObj) {
              return view.triggerEventHandlers($__0.eventName, eventObj, boundElementIndex);
            }));
          }}, {});
      }());
      Object.defineProperty(EventEmitterAccessor, "parameters", {get: function() {
          return [[assert.type.string], [Function]];
        }});
      Object.defineProperty(EventEmitterAccessor.prototype.subscribe, "parameters", {get: function() {
          return [[viewModule.AppView], [assert.type.number], [Object]];
        }});
      ProtoElementInjector = (function() {
        function ProtoElementInjector(parent, index, bindings) {
          var firstBindingIsComponent = arguments[3] !== (void 0) ? arguments[3] : false;
          var distanceToParent = arguments[4] !== (void 0) ? arguments[4] : 0;
          this.parent = parent;
          this.index = index;
          this.distanceToParent = distanceToParent;
          this.exportComponent = false;
          this.exportElement = false;
          this._binding0IsComponent = firstBindingIsComponent;
          this._binding0 = null;
          this._keyId0 = null;
          this._binding1 = null;
          this._keyId1 = null;
          this._binding2 = null;
          this._keyId2 = null;
          this._binding3 = null;
          this._keyId3 = null;
          this._binding4 = null;
          this._keyId4 = null;
          this._binding5 = null;
          this._keyId5 = null;
          this._binding6 = null;
          this._keyId6 = null;
          this._binding7 = null;
          this._keyId7 = null;
          this._binding8 = null;
          this._keyId8 = null;
          this._binding9 = null;
          this._keyId9 = null;
          this.numberOfDirectives = bindings.length;
          var length = bindings.length;
          this.eventEmitterAccessors = ListWrapper.createFixedSize(length);
          if (length > 0) {
            this._binding0 = this._createBinding(bindings[0]);
            this._keyId0 = this._binding0.key.id;
            this.eventEmitterAccessors[0] = this._createEventEmitterAccessors(this._binding0);
          }
          if (length > 1) {
            this._binding1 = this._createBinding(bindings[1]);
            this._keyId1 = this._binding1.key.id;
            this.eventEmitterAccessors[1] = this._createEventEmitterAccessors(this._binding1);
          }
          if (length > 2) {
            this._binding2 = this._createBinding(bindings[2]);
            this._keyId2 = this._binding2.key.id;
            this.eventEmitterAccessors[2] = this._createEventEmitterAccessors(this._binding2);
          }
          if (length > 3) {
            this._binding3 = this._createBinding(bindings[3]);
            this._keyId3 = this._binding3.key.id;
            this.eventEmitterAccessors[3] = this._createEventEmitterAccessors(this._binding3);
          }
          if (length > 4) {
            this._binding4 = this._createBinding(bindings[4]);
            this._keyId4 = this._binding4.key.id;
            this.eventEmitterAccessors[4] = this._createEventEmitterAccessors(this._binding4);
          }
          if (length > 5) {
            this._binding5 = this._createBinding(bindings[5]);
            this._keyId5 = this._binding5.key.id;
            this.eventEmitterAccessors[5] = this._createEventEmitterAccessors(this._binding5);
          }
          if (length > 6) {
            this._binding6 = this._createBinding(bindings[6]);
            this._keyId6 = this._binding6.key.id;
            this.eventEmitterAccessors[6] = this._createEventEmitterAccessors(this._binding6);
          }
          if (length > 7) {
            this._binding7 = this._createBinding(bindings[7]);
            this._keyId7 = this._binding7.key.id;
            this.eventEmitterAccessors[7] = this._createEventEmitterAccessors(this._binding7);
          }
          if (length > 8) {
            this._binding8 = this._createBinding(bindings[8]);
            this._keyId8 = this._binding8.key.id;
            this.eventEmitterAccessors[8] = this._createEventEmitterAccessors(this._binding8);
          }
          if (length > 9) {
            this._binding9 = this._createBinding(bindings[9]);
            this._keyId9 = this._binding9.key.id;
            this.eventEmitterAccessors[9] = this._createEventEmitterAccessors(this._binding9);
          }
          if (length > 10) {
            throw 'Maximum number of directives per element has been reached.';
          }
        }
        return ($traceurRuntime.createClass)(ProtoElementInjector, {
          _createEventEmitterAccessors: function(b) {
            return ListWrapper.map(b.eventEmitters, (function(eventName) {
              return new EventEmitterAccessor(eventName, reflector.getter(eventName));
            }));
          },
          instantiate: function(parent) {
            return new ElementInjector(this, parent);
          },
          directParent: function() {
            return this.distanceToParent < 2 ? this.parent : null;
          },
          _createBinding: function(bindingOrType) {
            if (bindingOrType instanceof DirectiveBinding) {
              return bindingOrType;
            } else {
              var b = bind(bindingOrType).toClass(bindingOrType);
              return DirectiveBinding.createFromBinding(b, null);
            }
          },
          get hasBindings() {
            return isPresent(this._binding0);
          },
          getDirectiveBindingAtIndex: function(index) {
            if (index == 0)
              return this._binding0;
            if (index == 1)
              return this._binding1;
            if (index == 2)
              return this._binding2;
            if (index == 3)
              return this._binding3;
            if (index == 4)
              return this._binding4;
            if (index == 5)
              return this._binding5;
            if (index == 6)
              return this._binding6;
            if (index == 7)
              return this._binding7;
            if (index == 8)
              return this._binding8;
            if (index == 9)
              return this._binding9;
            throw new OutOfBoundsAccess(index);
          }
        }, {});
      }());
      $__export("ProtoElementInjector", ProtoElementInjector);
      Object.defineProperty(ProtoElementInjector, "parameters", {get: function() {
          return [[ProtoElementInjector], [int], [List], [assert.type.boolean], [assert.type.number]];
        }});
      Object.defineProperty(ProtoElementInjector.prototype._createEventEmitterAccessors, "parameters", {get: function() {
          return [[DirectiveBinding]];
        }});
      Object.defineProperty(ProtoElementInjector.prototype.instantiate, "parameters", {get: function() {
          return [[ElementInjector]];
        }});
      Object.defineProperty(ProtoElementInjector.prototype.getDirectiveBindingAtIndex, "parameters", {get: function() {
          return [[int]];
        }});
      ElementInjector = (function($__super) {
        function ElementInjector(proto, parent) {
          $traceurRuntime.superConstructor(ElementInjector).call(this, parent);
          this._proto = proto;
          this._preBuiltObjects = null;
          this._lightDomAppInjector = null;
          this._shadowDomAppInjector = null;
          this._obj0 = null;
          this._obj1 = null;
          this._obj2 = null;
          this._obj3 = null;
          this._obj4 = null;
          this._obj5 = null;
          this._obj6 = null;
          this._obj7 = null;
          this._obj8 = null;
          this._obj9 = null;
          this._constructionCounter = 0;
          this._inheritQueries(parent);
          this._buildQueries();
        }
        return ($traceurRuntime.createClass)(ElementInjector, {
          clearDirectives: function() {
            this._host = null;
            this._preBuiltObjects = null;
            this._lightDomAppInjector = null;
            this._shadowDomAppInjector = null;
            var p = this._proto;
            if (isPresent(p._binding0) && p._binding0.callOnDestroy) {
              this._obj0.onDestroy();
            }
            if (isPresent(p._binding1) && p._binding1.callOnDestroy) {
              this._obj1.onDestroy();
            }
            if (isPresent(p._binding2) && p._binding2.callOnDestroy) {
              this._obj2.onDestroy();
            }
            if (isPresent(p._binding3) && p._binding3.callOnDestroy) {
              this._obj3.onDestroy();
            }
            if (isPresent(p._binding4) && p._binding4.callOnDestroy) {
              this._obj4.onDestroy();
            }
            if (isPresent(p._binding5) && p._binding5.callOnDestroy) {
              this._obj5.onDestroy();
            }
            if (isPresent(p._binding6) && p._binding6.callOnDestroy) {
              this._obj6.onDestroy();
            }
            if (isPresent(p._binding7) && p._binding7.callOnDestroy) {
              this._obj7.onDestroy();
            }
            if (isPresent(p._binding8) && p._binding8.callOnDestroy) {
              this._obj8.onDestroy();
            }
            if (isPresent(p._binding9) && p._binding9.callOnDestroy) {
              this._obj9.onDestroy();
            }
            if (isPresent(this._dynamicallyCreatedComponentBinding) && this._dynamicallyCreatedComponentBinding.callOnDestroy) {
              this._dynamicallyCreatedComponent.onDestroy();
            }
            this._obj0 = null;
            this._obj1 = null;
            this._obj2 = null;
            this._obj3 = null;
            this._obj4 = null;
            this._obj5 = null;
            this._obj6 = null;
            this._obj7 = null;
            this._obj8 = null;
            this._obj9 = null;
            this._dynamicallyCreatedComponent = null;
            this._dynamicallyCreatedComponentBinding = null;
            this._constructionCounter = 0;
          },
          instantiateDirectives: function(lightDomAppInjector, host, shadowDomAppInjector, preBuiltObjects) {
            this._host = host;
            this._checkShadowDomAppInjector(shadowDomAppInjector);
            this._preBuiltObjects = preBuiltObjects;
            this._lightDomAppInjector = lightDomAppInjector;
            this._shadowDomAppInjector = shadowDomAppInjector;
            var p = this._proto;
            if (isPresent(p._keyId0))
              this._getDirectiveByKeyId(p._keyId0);
            if (isPresent(p._keyId1))
              this._getDirectiveByKeyId(p._keyId1);
            if (isPresent(p._keyId2))
              this._getDirectiveByKeyId(p._keyId2);
            if (isPresent(p._keyId3))
              this._getDirectiveByKeyId(p._keyId3);
            if (isPresent(p._keyId4))
              this._getDirectiveByKeyId(p._keyId4);
            if (isPresent(p._keyId5))
              this._getDirectiveByKeyId(p._keyId5);
            if (isPresent(p._keyId6))
              this._getDirectiveByKeyId(p._keyId6);
            if (isPresent(p._keyId7))
              this._getDirectiveByKeyId(p._keyId7);
            if (isPresent(p._keyId8))
              this._getDirectiveByKeyId(p._keyId8);
            if (isPresent(p._keyId9))
              this._getDirectiveByKeyId(p._keyId9);
          },
          dynamicallyCreateComponent: function(directiveBinding, injector) {
            this._shadowDomAppInjector = injector;
            this._dynamicallyCreatedComponentBinding = directiveBinding;
            this._dynamicallyCreatedComponent = this._new(this._dynamicallyCreatedComponentBinding);
            return this._dynamicallyCreatedComponent;
          },
          _checkShadowDomAppInjector: function(shadowDomAppInjector) {
            if (this._proto._binding0IsComponent && isBlank(shadowDomAppInjector)) {
              throw new BaseException('A shadowDomAppInjector is required as this ElementInjector contains a component');
            } else if (!this._proto._binding0IsComponent && isPresent(shadowDomAppInjector)) {
              throw new BaseException('No shadowDomAppInjector allowed as there is not component stored in this ElementInjector');
            }
          },
          get: function(token) {
            if (this._isDynamicallyLoadedComponent(token)) {
              return this._dynamicallyCreatedComponent;
            }
            return this._getByKey(Key.get(token), 0, false, null);
          },
          _isDynamicallyLoadedComponent: function(token) {
            return isPresent(this._dynamicallyCreatedComponentBinding) && Key.get(token) === this._dynamicallyCreatedComponentBinding.key;
          },
          hasDirective: function(type) {
            return this._getDirectiveByKeyId(Key.get(type).id) !== _undefined;
          },
          getEventEmitterAccessors: function() {
            return this._proto.eventEmitterAccessors;
          },
          getComponent: function() {
            if (this._proto._binding0IsComponent) {
              return this._obj0;
            } else {
              throw new BaseException('There is no component stored in this ElementInjector');
            }
          },
          getElementRef: function() {
            return new ElementRef(new ViewRef(this._preBuiltObjects.view), this._proto.index);
          },
          getViewContainerRef: function() {
            return new ViewContainerRef(this._preBuiltObjects.viewManager, this.getElementRef());
          },
          getDynamicallyLoadedComponent: function() {
            return this._dynamicallyCreatedComponent;
          },
          directParent: function() {
            return this._proto.distanceToParent < 2 ? this.parent : null;
          },
          _isComponentKey: function(key) {
            return this._proto._binding0IsComponent && key.id === this._proto._keyId0;
          },
          _isDynamicallyLoadedComponentKey: function(key) {
            return isPresent(this._dynamicallyCreatedComponentBinding) && key.id === this._dynamicallyCreatedComponentBinding.key.id;
          },
          _new: function(binding) {
            if (this._constructionCounter++ > _MAX_DIRECTIVE_CONSTRUCTION_COUNTER) {
              throw new CyclicDependencyError(binding.key);
            }
            var factory = binding.factory;
            var deps = binding.dependencies;
            var length = deps.length;
            var d0,
                d1,
                d2,
                d3,
                d4,
                d5,
                d6,
                d7,
                d8,
                d9;
            try {
              d0 = length > 0 ? this._getByDependency(deps[0], binding.key) : null;
              d1 = length > 1 ? this._getByDependency(deps[1], binding.key) : null;
              d2 = length > 2 ? this._getByDependency(deps[2], binding.key) : null;
              d3 = length > 3 ? this._getByDependency(deps[3], binding.key) : null;
              d4 = length > 4 ? this._getByDependency(deps[4], binding.key) : null;
              d5 = length > 5 ? this._getByDependency(deps[5], binding.key) : null;
              d6 = length > 6 ? this._getByDependency(deps[6], binding.key) : null;
              d7 = length > 7 ? this._getByDependency(deps[7], binding.key) : null;
              d8 = length > 8 ? this._getByDependency(deps[8], binding.key) : null;
              d9 = length > 9 ? this._getByDependency(deps[9], binding.key) : null;
            } catch (e) {
              if (e instanceof AbstractBindingError)
                e.addKey(binding.key);
              throw e;
            }
            var obj;
            switch (length) {
              case 0:
                obj = factory();
                break;
              case 1:
                obj = factory(d0);
                break;
              case 2:
                obj = factory(d0, d1);
                break;
              case 3:
                obj = factory(d0, d1, d2);
                break;
              case 4:
                obj = factory(d0, d1, d2, d3);
                break;
              case 5:
                obj = factory(d0, d1, d2, d3, d4);
                break;
              case 6:
                obj = factory(d0, d1, d2, d3, d4, d5);
                break;
              case 7:
                obj = factory(d0, d1, d2, d3, d4, d5, d6);
                break;
              case 8:
                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                break;
              case 9:
                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                break;
              case 10:
                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                break;
              default:
                throw ("Directive " + binding.key.token + " can only have up to 10 dependencies.");
            }
            this._addToQueries(obj, binding.key.token);
            return obj;
          },
          _getByDependency: function(dep, requestor) {
            if (isPresent(dep.attributeName))
              return this._buildAttribute(dep);
            if (isPresent(dep.queryDirective))
              return this._findQuery(dep.queryDirective).list;
            if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
              var componentView = this._preBuiltObjects.view.componentChildViews[this._proto.index];
              return componentView.changeDetector.ref;
            }
            if (dep.key.id === StaticKeys.instance().elementRefId) {
              return this.getElementRef();
            }
            if (dep.key.id === StaticKeys.instance().viewContainerId) {
              return this.getViewContainerRef();
            }
            if (dep.key.id === StaticKeys.instance().protoViewId) {
              if (isBlank(this._preBuiltObjects.protoView)) {
                throw new NoBindingError(dep.key);
              }
              return new ProtoViewRef(this._preBuiltObjects.protoView);
            }
            return this._getByKey(dep.key, dep.depth, dep.optional, requestor);
          },
          _buildAttribute: function(dep) {
            var attributes = this._proto.attributes;
            if (isPresent(attributes) && MapWrapper.contains(attributes, dep.attributeName)) {
              return MapWrapper.get(attributes, dep.attributeName);
            } else {
              return null;
            }
          },
          _buildQueriesForDeps: function(deps) {
            for (var i = 0; i < deps.length; i++) {
              var dep = deps[i];
              if (isPresent(dep.queryDirective)) {
                this._createQueryRef(dep.queryDirective);
              }
            }
          },
          _createQueryRef: function(directive) {
            var queryList = new QueryList();
            if (isBlank(this._query0)) {
              this._query0 = new QueryRef(directive, queryList, this);
            } else if (isBlank(this._query1)) {
              this._query1 = new QueryRef(directive, queryList, this);
            } else if (isBlank(this._query2)) {
              this._query2 = new QueryRef(directive, queryList, this);
            } else
              throw new QueryError();
          },
          _addToQueries: function(obj, token) {
            if (isPresent(this._query0) && (this._query0.directive === token)) {
              this._query0.list.add(obj);
            }
            if (isPresent(this._query1) && (this._query1.directive === token)) {
              this._query1.list.add(obj);
            }
            if (isPresent(this._query2) && (this._query2.directive === token)) {
              this._query2.list.add(obj);
            }
          },
          _inheritQueries: function(parent) {
            if (isBlank(parent))
              return ;
            if (isPresent(parent._query0)) {
              this._query0 = parent._query0;
            }
            if (isPresent(parent._query1)) {
              this._query1 = parent._query1;
            }
            if (isPresent(parent._query2)) {
              this._query2 = parent._query2;
            }
          },
          _buildQueries: function() {
            if (isBlank(this._proto))
              return ;
            var p = this._proto;
            if (isPresent(p._binding0)) {
              this._buildQueriesForDeps(p._binding0.dependencies);
            }
            if (isPresent(p._binding1)) {
              this._buildQueriesForDeps(p._binding1.dependencies);
            }
            if (isPresent(p._binding2)) {
              this._buildQueriesForDeps(p._binding2.dependencies);
            }
            if (isPresent(p._binding3)) {
              this._buildQueriesForDeps(p._binding3.dependencies);
            }
            if (isPresent(p._binding4)) {
              this._buildQueriesForDeps(p._binding4.dependencies);
            }
            if (isPresent(p._binding5)) {
              this._buildQueriesForDeps(p._binding5.dependencies);
            }
            if (isPresent(p._binding6)) {
              this._buildQueriesForDeps(p._binding6.dependencies);
            }
            if (isPresent(p._binding7)) {
              this._buildQueriesForDeps(p._binding7.dependencies);
            }
            if (isPresent(p._binding8)) {
              this._buildQueriesForDeps(p._binding8.dependencies);
            }
            if (isPresent(p._binding9)) {
              this._buildQueriesForDeps(p._binding9.dependencies);
            }
          },
          _findQuery: function(token) {
            if (isPresent(this._query0) && this._query0.directive === token) {
              return this._query0;
            }
            if (isPresent(this._query1) && this._query1.directive === token) {
              return this._query1;
            }
            if (isPresent(this._query2) && this._query2.directive === token) {
              return this._query2;
            }
            throw new BaseException(("Cannot find query for directive " + token + "."));
          },
          link: function(parent) {
            parent.addChild(this);
            this._addParentQueries();
          },
          linkAfter: function(parent, prevSibling) {
            parent.addChildAfter(this, prevSibling);
            this._addParentQueries();
          },
          _addParentQueries: function() {
            if (isPresent(this.parent._query0)) {
              this._addQueryToTree(this.parent._query0);
              this.parent._query0.update();
            }
            if (isPresent(this.parent._query1)) {
              this._addQueryToTree(this.parent._query1);
              this.parent._query1.update();
            }
            if (isPresent(this.parent._query2)) {
              this._addQueryToTree(this.parent._query2);
              this.parent._query2.update();
            }
          },
          unlink: function() {
            var queriesToUpDate = [];
            if (isPresent(this.parent._query0)) {
              this._pruneQueryFromTree(this.parent._query0);
              ListWrapper.push(queriesToUpDate, this.parent._query0);
            }
            if (isPresent(this.parent._query1)) {
              this._pruneQueryFromTree(this.parent._query1);
              ListWrapper.push(queriesToUpDate, this.parent._query1);
            }
            if (isPresent(this.parent._query2)) {
              this._pruneQueryFromTree(this.parent._query2);
              ListWrapper.push(queriesToUpDate, this.parent._query2);
            }
            this.remove();
            ListWrapper.forEach(queriesToUpDate, (function(q) {
              return q.update();
            }));
          },
          _pruneQueryFromTree: function(query) {
            this._removeQueryRef(query);
            var child = this._head;
            while (isPresent(child)) {
              child._pruneQueryFromTree(query);
              child = child._next;
            }
          },
          _addQueryToTree: function(query) {
            this._assignQueryRef(query);
            var child = this._head;
            while (isPresent(child)) {
              child._addQueryToTree(query);
              child = child._next;
            }
          },
          _assignQueryRef: function(query) {
            if (isBlank(this._query0)) {
              this._query0 = query;
              return ;
            } else if (isBlank(this._query1)) {
              this._query1 = query;
              return ;
            } else if (isBlank(this._query2)) {
              this._query2 = query;
              return ;
            }
            throw new QueryError();
          },
          _removeQueryRef: function(query) {
            if (this._query0 == query)
              this._query0 = null;
            if (this._query1 == query)
              this._query1 = null;
            if (this._query2 == query)
              this._query2 = null;
          },
          _getByKey: function(key, depth, optional, requestor) {
            var ei = this;
            if (!this._shouldIncludeSelf(depth)) {
              depth -= ei._proto.distanceToParent;
              ei = ei._parent;
            }
            while (ei != null && depth >= 0) {
              var preBuiltObj = ei._getPreBuiltObjectByKeyId(key.id);
              if (preBuiltObj !== _undefined)
                return preBuiltObj;
              var dir = ei._getDirectiveByKeyId(key.id);
              if (dir !== _undefined)
                return dir;
              depth -= ei._proto.distanceToParent;
              ei = ei._parent;
            }
            if (isPresent(this._host) && this._host._isComponentKey(key)) {
              return this._host.getComponent();
            } else if (isPresent(this._host) && this._host._isDynamicallyLoadedComponentKey(key)) {
              return this._host.getDynamicallyLoadedComponent();
            } else if (optional) {
              return this._appInjector(requestor).getOptional(key);
            } else {
              return this._appInjector(requestor).get(key);
            }
          },
          _appInjector: function(requestor) {
            if (isPresent(requestor) && (this._isComponentKey(requestor) || this._isDynamicallyLoadedComponentKey(requestor))) {
              return this._shadowDomAppInjector;
            } else {
              return this._lightDomAppInjector;
            }
          },
          _shouldIncludeSelf: function(depth) {
            return depth === 0;
          },
          _getPreBuiltObjectByKeyId: function(keyId) {
            var staticKeys = StaticKeys.instance();
            if (keyId === staticKeys.viewManagerId)
              return this._preBuiltObjects.viewManagerId;
            return _undefined;
          },
          _getDirectiveByKeyId: function(keyId) {
            var p = this._proto;
            if (p._keyId0 === keyId) {
              if (isBlank(this._obj0)) {
                this._obj0 = this._new(p._binding0);
              }
              return this._obj0;
            }
            if (p._keyId1 === keyId) {
              if (isBlank(this._obj1)) {
                this._obj1 = this._new(p._binding1);
              }
              return this._obj1;
            }
            if (p._keyId2 === keyId) {
              if (isBlank(this._obj2)) {
                this._obj2 = this._new(p._binding2);
              }
              return this._obj2;
            }
            if (p._keyId3 === keyId) {
              if (isBlank(this._obj3)) {
                this._obj3 = this._new(p._binding3);
              }
              return this._obj3;
            }
            if (p._keyId4 === keyId) {
              if (isBlank(this._obj4)) {
                this._obj4 = this._new(p._binding4);
              }
              return this._obj4;
            }
            if (p._keyId5 === keyId) {
              if (isBlank(this._obj5)) {
                this._obj5 = this._new(p._binding5);
              }
              return this._obj5;
            }
            if (p._keyId6 === keyId) {
              if (isBlank(this._obj6)) {
                this._obj6 = this._new(p._binding6);
              }
              return this._obj6;
            }
            if (p._keyId7 === keyId) {
              if (isBlank(this._obj7)) {
                this._obj7 = this._new(p._binding7);
              }
              return this._obj7;
            }
            if (p._keyId8 === keyId) {
              if (isBlank(this._obj8)) {
                this._obj8 = this._new(p._binding8);
              }
              return this._obj8;
            }
            if (p._keyId9 === keyId) {
              if (isBlank(this._obj9)) {
                this._obj9 = this._new(p._binding9);
              }
              return this._obj9;
            }
            return _undefined;
          },
          getDirectiveAtIndex: function(index) {
            if (index == 0)
              return this._obj0;
            if (index == 1)
              return this._obj1;
            if (index == 2)
              return this._obj2;
            if (index == 3)
              return this._obj3;
            if (index == 4)
              return this._obj4;
            if (index == 5)
              return this._obj5;
            if (index == 6)
              return this._obj6;
            if (index == 7)
              return this._obj7;
            if (index == 8)
              return this._obj8;
            if (index == 9)
              return this._obj9;
            throw new OutOfBoundsAccess(index);
          },
          hasInstances: function() {
            return this._constructionCounter > 0;
          },
          isExportingComponent: function() {
            return this._proto.exportComponent;
          },
          isExportingElement: function() {
            return this._proto.exportElement;
          },
          getExportImplicitName: function() {
            return this._proto.exportImplicitName;
          },
          getLightDomAppInjector: function() {
            return this._lightDomAppInjector;
          },
          getShadowDomAppInjector: function() {
            return this._shadowDomAppInjector;
          },
          getHost: function() {
            return this._host;
          },
          getBoundElementIndex: function() {
            return this._proto.index;
          }
        }, {}, $__super);
      }(TreeNode));
      $__export("ElementInjector", ElementInjector);
      Object.defineProperty(ElementInjector, "parameters", {get: function() {
          return [[ProtoElementInjector], [ElementInjector]];
        }});
      Object.defineProperty(ElementInjector.prototype.instantiateDirectives, "parameters", {get: function() {
          return [[Injector], [ElementInjector], [Injector], [PreBuiltObjects]];
        }});
      Object.defineProperty(ElementInjector.prototype.dynamicallyCreateComponent, "parameters", {get: function() {
          return [[], [Injector]];
        }});
      Object.defineProperty(ElementInjector.prototype._checkShadowDomAppInjector, "parameters", {get: function() {
          return [[Injector]];
        }});
      Object.defineProperty(ElementInjector.prototype.hasDirective, "parameters", {get: function() {
          return [[Type]];
        }});
      Object.defineProperty(ElementInjector.prototype._isComponentKey, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(ElementInjector.prototype._isDynamicallyLoadedComponentKey, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(ElementInjector.prototype._new, "parameters", {get: function() {
          return [[ResolvedBinding]];
        }});
      Object.defineProperty(ElementInjector.prototype._getByDependency, "parameters", {get: function() {
          return [[DirectiveDependency], [Key]];
        }});
      Object.defineProperty(ElementInjector.prototype._buildQueriesForDeps, "parameters", {get: function() {
          return [[assert.genericType(List, DirectiveDependency)]];
        }});
      Object.defineProperty(ElementInjector.prototype._inheritQueries, "parameters", {get: function() {
          return [[ElementInjector]];
        }});
      Object.defineProperty(ElementInjector.prototype.link, "parameters", {get: function() {
          return [[ElementInjector]];
        }});
      Object.defineProperty(ElementInjector.prototype.linkAfter, "parameters", {get: function() {
          return [[ElementInjector], [ElementInjector]];
        }});
      Object.defineProperty(ElementInjector.prototype._pruneQueryFromTree, "parameters", {get: function() {
          return [[QueryRef]];
        }});
      Object.defineProperty(ElementInjector.prototype._addQueryToTree, "parameters", {get: function() {
          return [[QueryRef]];
        }});
      Object.defineProperty(ElementInjector.prototype._assignQueryRef, "parameters", {get: function() {
          return [[QueryRef]];
        }});
      Object.defineProperty(ElementInjector.prototype._removeQueryRef, "parameters", {get: function() {
          return [[QueryRef]];
        }});
      Object.defineProperty(ElementInjector.prototype._getByKey, "parameters", {get: function() {
          return [[Key], [assert.type.number], [assert.type.boolean], [Key]];
        }});
      Object.defineProperty(ElementInjector.prototype._appInjector, "parameters", {get: function() {
          return [[Key]];
        }});
      Object.defineProperty(ElementInjector.prototype._shouldIncludeSelf, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(ElementInjector.prototype._getPreBuiltObjectByKeyId, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(ElementInjector.prototype._getDirectiveByKeyId, "parameters", {get: function() {
          return [[int]];
        }});
      Object.defineProperty(ElementInjector.prototype.getDirectiveAtIndex, "parameters", {get: function() {
          return [[int]];
        }});
      OutOfBoundsAccess = (function($__super) {
        function OutOfBoundsAccess(index) {
          $traceurRuntime.superConstructor(OutOfBoundsAccess).call(this);
          this.message = ("Index " + index + " is out-of-bounds.");
        }
        return ($traceurRuntime.createClass)(OutOfBoundsAccess, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      QueryError = (function($__super) {
        function QueryError() {
          $traceurRuntime.superConstructor(QueryError).call(this);
          this.message = 'Only 3 queries can be concurrently active in a template.';
        }
        return ($traceurRuntime.createClass)(QueryError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(Error));
      QueryRef = (function() {
        function QueryRef(directive, list, originator) {
          this.directive = directive;
          this.list = list;
          this.originator = originator;
        }
        return ($traceurRuntime.createClass)(QueryRef, {
          update: function() {
            var aggregator = [];
            this.visit(this.originator, aggregator);
            this.list.reset(aggregator);
          },
          visit: function(inj, aggregator) {
            if (isBlank(inj))
              return ;
            if (inj.hasDirective(this.directive)) {
              ListWrapper.push(aggregator, inj.get(this.directive));
            }
            var child = inj._head;
            while (isPresent(child)) {
              this.visit(child, aggregator);
              child = child._next;
            }
          }
        }, {});
      }());
      Object.defineProperty(QueryRef, "parameters", {get: function() {
          return [[], [QueryList], [ElementInjector]];
        }});
      Object.defineProperty(QueryRef.prototype.visit, "parameters", {get: function() {
          return [[ElementInjector], []];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/view", ["angular2/src/facade/collection", "angular2/change_detection", "angular2/src/core/compiler/element_injector", "angular2/src/core/compiler/element_binder", "angular2/src/facade/lang", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view";
  var ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      List,
      AST,
      Locals,
      ChangeDispatcher,
      ProtoChangeDetector,
      ChangeDetector,
      ChangeRecord,
      BindingRecord,
      DirectiveRecord,
      DirectiveIndex,
      ChangeDetectorRef,
      ProtoElementInjector,
      ElementInjector,
      PreBuiltObjects,
      DirectiveBinding,
      ElementBinder,
      IMPLEMENTS,
      int,
      isPresent,
      isBlank,
      BaseException,
      renderApi,
      AppViewContainer,
      AppView,
      AppProtoView;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      List = $__m.List;
    }, function($__m) {
      AST = $__m.AST;
      Locals = $__m.Locals;
      ChangeDispatcher = $__m.ChangeDispatcher;
      ProtoChangeDetector = $__m.ProtoChangeDetector;
      ChangeDetector = $__m.ChangeDetector;
      ChangeRecord = $__m.ChangeRecord;
      BindingRecord = $__m.BindingRecord;
      DirectiveRecord = $__m.DirectiveRecord;
      DirectiveIndex = $__m.DirectiveIndex;
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      ProtoElementInjector = $__m.ProtoElementInjector;
      ElementInjector = $__m.ElementInjector;
      PreBuiltObjects = $__m.PreBuiltObjects;
      DirectiveBinding = $__m.DirectiveBinding;
    }, function($__m) {
      ElementBinder = $__m.ElementBinder;
    }, function($__m) {
      IMPLEMENTS = $__m.IMPLEMENTS;
      int = $__m.int;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      renderApi = $__m;
    }],
    execute: function() {
      AppViewContainer = (function() {
        function AppViewContainer() {
          this.views = [];
        }
        return ($traceurRuntime.createClass)(AppViewContainer, {}, {});
      }());
      $__export("AppViewContainer", AppViewContainer);
      AppView = (function() {
        function AppView(renderer, proto, protoLocals) {
          this.render = null;
          this.proto = proto;
          this.changeDetector = null;
          this.elementInjectors = null;
          this.rootElementInjectors = null;
          this.componentChildViews = null;
          this.viewContainers = ListWrapper.createFixedSize(this.proto.elementBinders.length);
          this.preBuiltObjects = null;
          this.context = null;
          this.locals = new Locals(null, MapWrapper.clone(protoLocals));
          this.renderer = renderer;
          this.imperativeHostViews = [];
        }
        return ($traceurRuntime.createClass)(AppView, {
          init: function(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, componentChildViews) {
            this.changeDetector = changeDetector;
            this.elementInjectors = elementInjectors;
            this.rootElementInjectors = rootElementInjectors;
            this.preBuiltObjects = preBuiltObjects;
            this.componentChildViews = componentChildViews;
          },
          setLocal: function(contextName, value) {
            if (!this.hydrated())
              throw new BaseException('Cannot set locals on dehydrated view.');
            if (!MapWrapper.contains(this.proto.variableBindings, contextName)) {
              return ;
            }
            var templateName = MapWrapper.get(this.proto.variableBindings, contextName);
            this.locals.set(templateName, value);
          },
          hydrated: function() {
            return isPresent(this.context);
          },
          triggerEventHandlers: function(eventName, eventObj, binderIndex) {
            var locals = MapWrapper.create();
            MapWrapper.set(locals, '$event', eventObj);
            this.dispatchEvent(binderIndex, eventName, locals);
          },
          notifyOnBinding: function(b, currentValue) {
            if (b.isElement()) {
              this.renderer.setElementProperty(this.render, b.elementIndex, b.propertyName, currentValue);
            } else {
              this.renderer.setText(this.render, b.elementIndex, currentValue);
            }
          },
          getDirectiveFor: function(directive) {
            var elementInjector = this.elementInjectors[directive.elementIndex];
            return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
          },
          getDetectorFor: function(directive) {
            var childView = this.componentChildViews[directive.elementIndex];
            return isPresent(childView) ? childView.changeDetector : null;
          },
          dispatchEvent: function(elementIndex, eventName, locals) {
            var $__0 = this;
            var allowDefaultBehavior = true;
            if (this.hydrated()) {
              var elBinder = this.proto.elementBinders[elementIndex];
              if (isBlank(elBinder.hostListeners))
                return allowDefaultBehavior;
              var eventMap = elBinder.hostListeners[eventName];
              if (isBlank(eventMap))
                return allowDefaultBehavior;
              MapWrapper.forEach(eventMap, (function(expr, directiveIndex) {
                var context;
                if (directiveIndex === -1) {
                  context = $__0.context;
                } else {
                  context = $__0.elementInjectors[elementIndex].getDirectiveAtIndex(directiveIndex);
                }
                var result = expr.eval(context, new Locals($__0.locals, locals));
                if (isPresent(result)) {
                  allowDefaultBehavior = allowDefaultBehavior && result;
                }
              }));
            }
            return allowDefaultBehavior;
          }
        }, {});
      }());
      $__export("AppView", AppView);
      Object.defineProperty(AppView, "annotations", {get: function() {
          return [new IMPLEMENTS(ChangeDispatcher)];
        }});
      Object.defineProperty(AppView, "parameters", {get: function() {
          return [[renderApi.Renderer], [AppProtoView], [Map]];
        }});
      Object.defineProperty(AppView.prototype.init, "parameters", {get: function() {
          return [[ChangeDetector], [List], [List], [List], [List]];
        }});
      Object.defineProperty(AppView.prototype.setLocal, "parameters", {get: function() {
          return [[assert.type.string], []];
        }});
      Object.defineProperty(AppView.prototype.triggerEventHandlers, "parameters", {get: function() {
          return [[assert.type.string], [], [int]];
        }});
      Object.defineProperty(AppView.prototype.notifyOnBinding, "parameters", {get: function() {
          return [[BindingRecord], [assert.type.any]];
        }});
      Object.defineProperty(AppView.prototype.getDirectiveFor, "parameters", {get: function() {
          return [[DirectiveIndex]];
        }});
      Object.defineProperty(AppView.prototype.getDetectorFor, "parameters", {get: function() {
          return [[DirectiveIndex]];
        }});
      Object.defineProperty(AppView.prototype.dispatchEvent, "parameters", {get: function() {
          return [[assert.type.number], [assert.type.string], [assert.genericType(Map, assert.type.string, assert.type.any)]];
        }});
      AppProtoView = (function() {
        function AppProtoView(render, protoChangeDetector, variableBindings, protoLocals, variableNames) {
          this.render = render;
          this.elementBinders = [];
          this.variableBindings = variableBindings;
          this.protoLocals = protoLocals;
          this.variableNames = variableNames;
          this.protoChangeDetector = protoChangeDetector;
        }
        return ($traceurRuntime.createClass)(AppProtoView, {
          bindElement: function(parent, distanceToParent, protoElementInjector) {
            var componentDirective = arguments[3] !== (void 0) ? arguments[3] : null;
            var elBinder = new ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective);
            ListWrapper.push(this.elementBinders, elBinder);
            return elBinder;
          },
          bindEvent: function(eventBindings, boundElementIndex) {
            var directiveIndex = arguments[2] !== (void 0) ? arguments[2] : -1;
            var elBinder = this.elementBinders[boundElementIndex];
            var events = elBinder.hostListeners;
            if (isBlank(events)) {
              events = StringMapWrapper.create();
              elBinder.hostListeners = events;
            }
            for (var i = 0; i < eventBindings.length; i++) {
              var eventBinding = eventBindings[i];
              var eventName = eventBinding.fullName;
              var event = StringMapWrapper.get(events, eventName);
              if (isBlank(event)) {
                event = MapWrapper.create();
                StringMapWrapper.set(events, eventName, event);
              }
              MapWrapper.set(event, directiveIndex, eventBinding.source);
            }
          }
        }, {});
      }());
      $__export("AppProtoView", AppProtoView);
      Object.defineProperty(AppProtoView, "parameters", {get: function() {
          return [[renderApi.RenderProtoViewRef], [ProtoChangeDetector], [Map], [Map], [List]];
        }});
      Object.defineProperty(AppProtoView.prototype.bindElement, "parameters", {get: function() {
          return [[ElementBinder], [int], [ProtoElementInjector], [DirectiveBinding]];
        }});
      Object.defineProperty(AppProtoView.prototype.bindEvent, "parameters", {get: function() {
          return [[assert.genericType(List, renderApi.EventBinding)], [assert.type.number], [int]];
        }});
    }
  };
});

System.register("angular2/src/core/compiler/compiler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/core/compiler/directive_metadata_reader", "angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/view", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/element_injector", "angular2/src/core/compiler/template_resolver", "angular2/src/core/annotations_impl/view", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/proto_view_factory", "angular2/src/services/url_resolver", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/compiler";
  var Injectable,
      Binding,
      Type,
      isBlank,
      isPresent,
      BaseException,
      normalizeBlank,
      stringify,
      Promise,
      PromiseWrapper,
      List,
      ListWrapper,
      Map,
      MapWrapper,
      DirectiveMetadataReader,
      Component,
      Directive,
      AppProtoView,
      ProtoViewRef,
      DirectiveBinding,
      TemplateResolver,
      View,
      ComponentUrlMapper,
      ProtoViewFactory,
      UrlResolver,
      renderApi,
      CompilerCache,
      Compiler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
      Binding = $__m.Binding;
    }, function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      normalizeBlank = $__m.normalizeBlank;
      stringify = $__m.stringify;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DirectiveMetadataReader = $__m.DirectiveMetadataReader;
    }, function($__m) {
      Component = $__m.Component;
      Directive = $__m.Directive;
    }, function($__m) {
      AppProtoView = $__m.AppProtoView;
    }, function($__m) {
      ProtoViewRef = $__m.ProtoViewRef;
    }, function($__m) {
      DirectiveBinding = $__m.DirectiveBinding;
    }, function($__m) {
      TemplateResolver = $__m.TemplateResolver;
    }, function($__m) {
      View = $__m.View;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      renderApi = $__m;
    }],
    execute: function() {
      CompilerCache = (function() {
        function CompilerCache() {
          this._cache = MapWrapper.create();
        }
        return ($traceurRuntime.createClass)(CompilerCache, {
          set: function(component, protoView) {
            MapWrapper.set(this._cache, component, protoView);
          },
          get: function(component) {
            var result = MapWrapper.get(this._cache, component);
            return normalizeBlank(result);
          },
          clear: function() {
            MapWrapper.clear(this._cache);
          }
        }, {});
      }());
      $__export("CompilerCache", CompilerCache);
      Object.defineProperty(CompilerCache, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(CompilerCache.prototype.set, "parameters", {get: function() {
          return [[Type], [AppProtoView]];
        }});
      Object.defineProperty(CompilerCache.prototype.get, "parameters", {get: function() {
          return [[Type]];
        }});
      Compiler = (function() {
        function Compiler(reader, cache, templateResolver, componentUrlMapper, urlResolver, renderer, protoViewFactory) {
          this._reader = reader;
          this._compilerCache = cache;
          this._compiling = MapWrapper.create();
          this._templateResolver = templateResolver;
          this._componentUrlMapper = componentUrlMapper;
          this._urlResolver = urlResolver;
          this._appUrl = urlResolver.resolve(null, './');
          this._renderer = renderer;
          this._protoViewFactory = protoViewFactory;
        }
        return ($traceurRuntime.createClass)(Compiler, {
          _bindDirective: function(directiveTypeOrBinding) {
            if (directiveTypeOrBinding instanceof DirectiveBinding) {
              return directiveTypeOrBinding;
            } else if (directiveTypeOrBinding instanceof Binding) {
              var meta = this._reader.read(directiveTypeOrBinding.token);
              return DirectiveBinding.createFromBinding(directiveTypeOrBinding, meta.annotation);
            } else {
              var meta$__2 = this._reader.read(directiveTypeOrBinding);
              return DirectiveBinding.createFromType(meta$__2.type, meta$__2.annotation);
            }
          },
          compileInHost: function(componentTypeOrBinding) {
            var $__0 = this;
            var componentBinding = this._bindDirective(componentTypeOrBinding);
            this._assertTypeIsComponent(componentBinding);
            var directiveMetadata = Compiler.buildRenderDirective(componentBinding);
            return this._renderer.createHostProtoView(directiveMetadata).then((function(hostRenderPv) {
              return $__0._compileNestedProtoViews(null, null, hostRenderPv, [componentBinding], true);
            })).then((function(appProtoView) {
              return new ProtoViewRef(appProtoView);
            }));
          },
          compile: function(component) {
            var componentBinding = this._bindDirective(component);
            this._assertTypeIsComponent(componentBinding);
            var protoView = this._compile(componentBinding);
            var pvPromise = PromiseWrapper.isPromise(protoView) ? protoView : PromiseWrapper.resolve(protoView);
            return pvPromise.then((function(appProtoView) {
              return new ProtoViewRef(appProtoView);
            }));
          },
          _compile: function(componentBinding) {
            var $__0 = this;
            var component = componentBinding.key.token;
            var protoView = this._compilerCache.get(component);
            if (isPresent(protoView)) {
              return protoView;
            }
            var pvPromise = MapWrapper.get(this._compiling, component);
            if (isPresent(pvPromise)) {
              return pvPromise;
            }
            var template = this._templateResolver.resolve(component);
            if (isBlank(template)) {
              return null;
            }
            if (isPresent(template.renderer)) {
              var directives = [];
              pvPromise = this._renderer.createImperativeComponentProtoView(template.renderer).then((function(renderPv) {
                return $__0._compileNestedProtoViews(null, componentBinding, renderPv, directives, true);
              }));
            } else {
              var directives = ListWrapper.map(this._flattenDirectives(template), (function(directive) {
                return $__0._bindDirective(directive);
              }));
              var renderTemplate = this._buildRenderTemplate(component, template, directives);
              pvPromise = this._renderer.compile(renderTemplate).then((function(renderPv) {
                return $__0._compileNestedProtoViews(null, componentBinding, renderPv, directives, true);
              }));
            }
            MapWrapper.set(this._compiling, component, pvPromise);
            return pvPromise;
          },
          _compileNestedProtoViews: function(parentProtoView, componentBinding, renderPv, directives, isComponentRootView) {
            var $__0 = this;
            var nestedPVPromises = [];
            var protoView = this._protoViewFactory.createProtoView(parentProtoView, componentBinding, renderPv, directives);
            if (isComponentRootView && isPresent(componentBinding)) {
              var component = componentBinding.key.token;
              this._compilerCache.set(component, protoView);
              MapWrapper.delete(this._compiling, component);
            }
            var binderIndex = 0;
            ListWrapper.forEach(protoView.elementBinders, (function(elementBinder) {
              var nestedComponent = elementBinder.componentDirective;
              var nestedRenderProtoView = renderPv.elementBinders[binderIndex].nestedProtoView;
              var elementBinderDone = (function(nestedPv) {
                elementBinder.nestedProtoView = nestedPv;
              });
              var nestedCall = null;
              if (isPresent(nestedComponent)) {
                nestedCall = $__0._compile(nestedComponent);
              } else if (isPresent(nestedRenderProtoView)) {
                nestedCall = $__0._compileNestedProtoViews(protoView, componentBinding, nestedRenderProtoView, directives, false);
              }
              if (PromiseWrapper.isPromise(nestedCall)) {
                ListWrapper.push(nestedPVPromises, nestedCall.then(elementBinderDone));
              } else if (isPresent(nestedCall)) {
                elementBinderDone(nestedCall);
              }
              binderIndex++;
            }));
            var protoViewDone = (function(_) {
              var childComponentRenderPvRefs = [];
              ListWrapper.forEach(protoView.elementBinders, (function(eb) {
                if (isPresent(eb.componentDirective)) {
                  var componentPv = eb.nestedProtoView;
                  ListWrapper.push(childComponentRenderPvRefs, isPresent(componentPv) ? componentPv.render : null);
                }
              }));
              $__0._renderer.mergeChildComponentProtoViews(protoView.render, childComponentRenderPvRefs);
              return protoView;
            });
            if (nestedPVPromises.length > 0) {
              return PromiseWrapper.all(nestedPVPromises).then(protoViewDone);
            } else {
              return protoViewDone(null);
            }
          },
          _buildRenderTemplate: function(component, view, directives) {
            var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
            var templateAbsUrl = null;
            if (isPresent(view.templateUrl)) {
              templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
            } else if (isPresent(view.template)) {
              templateAbsUrl = componentUrl;
            }
            return new renderApi.ViewDefinition({
              componentId: stringify(component),
              absUrl: templateAbsUrl,
              template: view.template,
              directives: ListWrapper.map(directives, Compiler.buildRenderDirective)
            });
          },
          _flattenDirectives: function(template) {
            if (isBlank(template.directives))
              return [];
            var directives = [];
            this._flattenList(template.directives, directives);
            return directives;
          },
          _flattenList: function(tree, out) {
            for (var i = 0; i < tree.length; i++) {
              var item = tree[i];
              if (ListWrapper.isList(item)) {
                this._flattenList(item, out);
              } else {
                ListWrapper.push(out, item);
              }
            }
          },
          _assertTypeIsComponent: function(directiveBinding) {
            if (!(directiveBinding.annotation instanceof Component)) {
              throw new BaseException(("Could not load '" + stringify(directiveBinding.key.token) + "' because it is not a component."));
            }
          }
        }, {buildRenderDirective: function(directiveBinding) {
            var ann = directiveBinding.annotation;
            var renderType;
            var compileChildren = ann.compileChildren;
            if (ann instanceof Component) {
              renderType = renderApi.DirectiveMetadata.COMPONENT_TYPE;
            } else {
              renderType = renderApi.DirectiveMetadata.DIRECTIVE_TYPE;
            }
            var readAttributes = [];
            ListWrapper.forEach(directiveBinding.dependencies, (function(dep) {
              if (isPresent(dep.attributeName)) {
                ListWrapper.push(readAttributes, dep.attributeName);
              }
            }));
            return new renderApi.DirectiveMetadata({
              id: stringify(directiveBinding.key.token),
              type: renderType,
              selector: ann.selector,
              compileChildren: compileChildren,
              hostListeners: isPresent(ann.hostListeners) ? MapWrapper.createFromStringMap(ann.hostListeners) : null,
              hostProperties: isPresent(ann.hostProperties) ? MapWrapper.createFromStringMap(ann.hostProperties) : null,
              properties: isPresent(ann.properties) ? MapWrapper.createFromStringMap(ann.properties) : null,
              readAttributes: readAttributes
            });
          }});
      }());
      $__export("Compiler", Compiler);
      Object.defineProperty(Compiler, "annotations", {get: function() {
          return [new Injectable()];
        }});
      Object.defineProperty(Compiler, "parameters", {get: function() {
          return [[DirectiveMetadataReader], [CompilerCache], [TemplateResolver], [ComponentUrlMapper], [UrlResolver], [renderApi.Renderer], [ProtoViewFactory]];
        }});
      Object.defineProperty(Compiler.prototype.compileInHost, "parameters", {get: function() {
          return [[assert.type.any]];
        }});
      Object.defineProperty(Compiler.prototype.compile, "parameters", {get: function() {
          return [[Type]];
        }});
      Object.defineProperty(Compiler.prototype._compile, "parameters", {get: function() {
          return [[DirectiveBinding]];
        }});
      Object.defineProperty(Compiler.prototype._flattenDirectives, "parameters", {get: function() {
          return [[View]];
        }});
      Object.defineProperty(Compiler.prototype._flattenList, "parameters", {get: function() {
          return [[assert.genericType(List, assert.type.any)], [assert.genericType(List, Type)]];
        }});
      Object.defineProperty(Compiler.prototype._assertTypeIsComponent, "parameters", {get: function() {
          return [[DirectiveBinding]];
        }});
    }
  };
});

System.register("angular2/src/core/application", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/browser_adapter", "angular2/src/dom/dom_adapter", "angular2/src/core/compiler/compiler", "angular2/src/reflection/reflection", "angular2/change_detection", "angular2/src/core/exception_handler", "angular2/src/render/dom/compiler/template_loader", "angular2/src/core/compiler/template_resolver", "angular2/src/core/compiler/directive_metadata_reader", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/core/zone/vm_turn_zone", "angular2/src/core/life_cycle/life_cycle", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy", "angular2/src/services/xhr", "angular2/src/services/xhr_impl", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/events/key_events", "angular2/src/render/dom/events/hammer_gestures", "angular2/src/di/binding", "angular2/src/core/compiler/component_url_mapper", "angular2/src/services/url_resolver", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/render/dom/shadow_dom/style_inliner", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/testability/testability", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/proto_view_factory", "angular2/src/render/api", "angular2/src/render/dom/direct_dom_renderer", "angular2/src/render/dom/compiler/compiler", "angular2/src/render/dom/view/view_factory", "angular2/src/render/dom/view/view_hydrator", "angular2/src/core/compiler/view_ref", "angular2/src/core/application_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application";
  var Injector,
      bind,
      OpaqueToken,
      Optional,
      NumberWrapper,
      Type,
      isBlank,
      isPresent,
      BaseException,
      assertionsEnabled,
      print,
      stringify,
      BrowserDomAdapter,
      DOM,
      Compiler,
      CompilerCache,
      Reflector,
      reflector,
      Parser,
      Lexer,
      ChangeDetection,
      DynamicChangeDetection,
      PipeRegistry,
      defaultPipeRegistry,
      ExceptionHandler,
      TemplateLoader,
      TemplateResolver,
      DirectiveMetadataReader,
      List,
      ListWrapper,
      Promise,
      PromiseWrapper,
      VmTurnZone,
      LifeCycle,
      ShadowDomStrategy,
      EmulatedUnscopedShadowDomStrategy,
      XHR,
      XHRImpl,
      EventManager,
      DomEventsPlugin,
      KeyEventsPlugin,
      HammerGesturesPlugin,
      Binding,
      ComponentUrlMapper,
      UrlResolver,
      StyleUrlResolver,
      StyleInliner,
      ComponentRef,
      DynamicComponentLoader,
      TestabilityRegistry,
      Testability,
      AppViewPool,
      APP_VIEW_POOL_CAPACITY,
      AppViewManager,
      AppViewManagerUtils,
      ProtoViewFactory,
      Renderer,
      DirectDomRenderer,
      rc,
      rvf,
      rvh,
      internalView,
      appComponentRefToken,
      appElementToken,
      appComponentAnnotatedTypeToken,
      appDocumentToken,
      _rootInjector,
      _rootBindings,
      ApplicationRef;
  function _injectorBindings(appComponentType) {
    return [bind(appDocumentToken).toValue(DOM.defaultDoc()), bind(appComponentAnnotatedTypeToken).toFactory((function(reader) {
      return reader.read(appComponentType);
    }), [DirectiveMetadataReader]), bind(appElementToken).toFactory((function(appComponentAnnotatedType, appDocument) {
      var selector = appComponentAnnotatedType.annotation.selector;
      var element = DOM.querySelector(appDocument, selector);
      if (isBlank(element)) {
        throw new BaseException(("The app selector \"" + selector + "\" did not match any elements"));
      }
      return element;
    }), [appComponentAnnotatedTypeToken, appDocumentToken]), bind(appComponentRefToken).toAsyncFactory((function(dynamicComponentLoader, injector, appElement, appComponentAnnotatedType, testability, registry) {
      registry.registerApplication(appElement, testability);
      return dynamicComponentLoader.loadIntoNewLocation(appComponentAnnotatedType.type, null, appElement, injector);
    }), [DynamicComponentLoader, Injector, appElementToken, appComponentAnnotatedTypeToken, Testability, TestabilityRegistry]), bind(appComponentType).toFactory((function(ref) {
      return ref.instance;
    }), [appComponentRefToken]), bind(LifeCycle).toFactory((function(exceptionHandler) {
      return new LifeCycle(exceptionHandler, null, assertionsEnabled());
    }), [ExceptionHandler]), bind(EventManager).toFactory((function(zone) {
      var plugins = [new HammerGesturesPlugin(), new KeyEventsPlugin(), new DomEventsPlugin()];
      return new EventManager(plugins, zone);
    }), [VmTurnZone]), bind(ShadowDomStrategy).toFactory((function(styleUrlResolver, doc) {
      return new EmulatedUnscopedShadowDomStrategy(styleUrlResolver, doc.head);
    }), [StyleUrlResolver, appDocumentToken]), DirectDomRenderer, bind(Renderer).toClass(DirectDomRenderer), bind(rc.Compiler).toClass(rc.DefaultCompiler), bind(rvf.ViewFactory).toFactory((function(capacity, eventManager, shadowDomStrategy) {
      return new rvf.ViewFactory(capacity, eventManager, shadowDomStrategy);
    }), [rvf.VIEW_POOL_CAPACITY, EventManager, ShadowDomStrategy]), bind(rvf.VIEW_POOL_CAPACITY).toValue(10000), rvh.RenderViewHydrator, ProtoViewFactory, bind(AppViewPool).toFactory((function(capacity) {
      return new AppViewPool(capacity);
    }), [APP_VIEW_POOL_CAPACITY]), bind(APP_VIEW_POOL_CAPACITY).toValue(10000), AppViewManager, AppViewManagerUtils, Compiler, CompilerCache, TemplateResolver, bind(PipeRegistry).toValue(defaultPipeRegistry), bind(ChangeDetection).toClass(DynamicChangeDetection), TemplateLoader, DirectiveMetadataReader, Parser, Lexer, ExceptionHandler, bind(XHR).toValue(new XHRImpl()), ComponentUrlMapper, UrlResolver, StyleUrlResolver, StyleInliner, DynamicComponentLoader, Testability];
  }
  function _createVmZone(givenReporter) {
    var defaultErrorReporter = (function(exception, stackTrace) {
      var longStackTrace = ListWrapper.join(stackTrace, "\n\n-----async gap-----\n");
      DOM.logError((exception + "\n\n" + longStackTrace));
      throw exception;
    });
    var reporter = isPresent(givenReporter) ? givenReporter : defaultErrorReporter;
    var zone = new VmTurnZone({enableLongStackTrace: assertionsEnabled()});
    zone.initCallbacks({onErrorHandler: reporter});
    return zone;
  }
  function bootstrap(appComponentType) {
    var componentInjectableBindings = arguments[1] !== (void 0) ? arguments[1] : null;
    var errorReporter = arguments[2] !== (void 0) ? arguments[2] : null;
    BrowserDomAdapter.makeCurrent();
    var bootstrapProcess = PromiseWrapper.completer();
    var zone = _createVmZone(errorReporter);
    zone.run((function() {
      var appInjector = _createAppInjector(appComponentType, componentInjectableBindings, zone);
      PromiseWrapper.then(appInjector.asyncGet(appComponentRefToken), (function(componentRef) {
        var appChangeDetector = internalView(componentRef.hostView).changeDetector;
        var lc = appInjector.get(LifeCycle);
        lc.registerWith(zone, appChangeDetector);
        lc.tick();
        bootstrapProcess.resolve(new ApplicationRef(componentRef, appInjector));
      }), (function(err) {
        bootstrapProcess.reject(err);
      }));
    }));
    return bootstrapProcess.promise;
  }
  function _createAppInjector(appComponentType, bindings, zone) {
    if (isBlank(_rootInjector))
      _rootInjector = Injector.resolveAndCreate(_rootBindings);
    var mergedBindings = isPresent(bindings) ? ListWrapper.concat(_injectorBindings(appComponentType), bindings) : _injectorBindings(appComponentType);
    ListWrapper.push(mergedBindings, bind(VmTurnZone).toValue(zone));
    return _rootInjector.resolveAndCreateChild(mergedBindings);
  }
  $__export("bootstrap", bootstrap);
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      bind = $__m.bind;
      OpaqueToken = $__m.OpaqueToken;
      Optional = $__m.Optional;
    }, function($__m) {
      NumberWrapper = $__m.NumberWrapper;
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      assertionsEnabled = $__m.assertionsEnabled;
      print = $__m.print;
      stringify = $__m.stringify;
    }, function($__m) {
      BrowserDomAdapter = $__m.BrowserDomAdapter;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Compiler = $__m.Compiler;
      CompilerCache = $__m.CompilerCache;
    }, function($__m) {
      Reflector = $__m.Reflector;
      reflector = $__m.reflector;
    }, function($__m) {
      Parser = $__m.Parser;
      Lexer = $__m.Lexer;
      ChangeDetection = $__m.ChangeDetection;
      DynamicChangeDetection = $__m.DynamicChangeDetection;
      PipeRegistry = $__m.PipeRegistry;
      defaultPipeRegistry = $__m.defaultPipeRegistry;
    }, function($__m) {
      ExceptionHandler = $__m.ExceptionHandler;
    }, function($__m) {
      TemplateLoader = $__m.TemplateLoader;
    }, function($__m) {
      TemplateResolver = $__m.TemplateResolver;
    }, function($__m) {
      DirectiveMetadataReader = $__m.DirectiveMetadataReader;
    }, function($__m) {
      List = $__m.List;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Promise = $__m.Promise;
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      VmTurnZone = $__m.VmTurnZone;
    }, function($__m) {
      LifeCycle = $__m.LifeCycle;
    }, function($__m) {
      ShadowDomStrategy = $__m.ShadowDomStrategy;
    }, function($__m) {
      EmulatedUnscopedShadowDomStrategy = $__m.EmulatedUnscopedShadowDomStrategy;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      XHRImpl = $__m.XHRImpl;
    }, function($__m) {
      EventManager = $__m.EventManager;
      DomEventsPlugin = $__m.DomEventsPlugin;
    }, function($__m) {
      KeyEventsPlugin = $__m.KeyEventsPlugin;
    }, function($__m) {
      HammerGesturesPlugin = $__m.HammerGesturesPlugin;
    }, function($__m) {
      Binding = $__m.Binding;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      ComponentRef = $__m.ComponentRef;
      DynamicComponentLoader = $__m.DynamicComponentLoader;
    }, function($__m) {
      TestabilityRegistry = $__m.TestabilityRegistry;
      Testability = $__m.Testability;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
      APP_VIEW_POOL_CAPACITY = $__m.APP_VIEW_POOL_CAPACITY;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      DirectDomRenderer = $__m.DirectDomRenderer;
    }, function($__m) {
      rc = $__m;
    }, function($__m) {
      rvf = $__m;
    }, function($__m) {
      rvh = $__m;
    }, function($__m) {
      internalView = $__m.internalView;
    }, function($__m) {
      appComponentRefToken = $__m.appComponentRefToken;
      appElementToken = $__m.appElementToken;
      appComponentAnnotatedTypeToken = $__m.appComponentAnnotatedTypeToken;
      appDocumentToken = $__m.appDocumentToken;
    }],
    execute: function() {
      _rootBindings = [bind(Reflector).toValue(reflector), TestabilityRegistry];
      Object.defineProperty(_createVmZone, "parameters", {get: function() {
          return [[Function]];
        }});
      Object.defineProperty(bootstrap, "parameters", {get: function() {
          return [[Type], [assert.genericType(List, Binding)], [Function]];
        }});
      ApplicationRef = (function() {
        function ApplicationRef(hostComponent, injector) {
          this._hostComponent = hostComponent;
          this._injector = injector;
        }
        return ($traceurRuntime.createClass)(ApplicationRef, {
          get hostComponent() {
            return this._hostComponent.instance;
          },
          dispose: function() {
            return this._hostComponent.dispose();
          },
          get injector() {
            return this._injector;
          }
        }, {});
      }());
      $__export("ApplicationRef", ApplicationRef);
      Object.defineProperty(ApplicationRef, "parameters", {get: function() {
          return [[ComponentRef], [Injector]];
        }});
      Object.defineProperty(_createAppInjector, "parameters", {get: function() {
          return [[Type], [assert.genericType(List, Binding)], [VmTurnZone]];
        }});
    }
  };
});

System.register("angular2/core", ["angular2/src/core/annotations/visibility", "angular2/src/core/compiler/interfaces", "angular2/src/core/annotations/view", "angular2/src/core/application", "angular2/src/core/application_tokens", "angular2/src/core/annotations/di", "angular2/src/core/compiler/query_list", "angular2/src/core/compiler/compiler", "angular2/src/render/dom/compiler/template_loader", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/native_shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/emulated_scoped_shadow_dom_strategy", "angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/element_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/core";
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("ViewRef", $__m.ViewRef);
      $__export("ProtoViewRef", $__m.ProtoViewRef);
    }, function($__m) {
      $__export("ViewContainerRef", $__m.ViewContainerRef);
    }, function($__m) {
      $__export("ElementRef", $__m.ElementRef);
    }],
    execute: function() {}
  };
});

System.register("angular2/angular2", ["angular2/change_detection", "angular2/core", "angular2/annotations", "angular2/directives", "angular2/forms", "angular2/src/facade/async", "angular2/src/render/api", "angular2/src/render/dom/direct_dom_renderer"], function($__export) {
  "use strict";
  var __moduleName = "angular2/angular2";
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("Observable", $__m.Observable);
      $__export("EventEmitter", $__m.EventEmitter);
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("DirectDomRenderer", $__m.DirectDomRenderer);
    }],
    execute: function() {}
  };
});

System.register("src/rules-engine-ng2/app/rules-engine-ng2.ts", ["rtts_assert/rtts_assert", "npm:debug@2.2.0", "npm:reflect-metadata@0.1.0", "angular2/angular2", "angular2/src/core/annotations_impl/annotations", "angular2/src/core/annotations_impl/view", "angular2/forms", "src/dc/index.es6", "src/rules-engine/RuleEngine.es6", "github:twbs/bootstrap@3.3.4/css/bootstrap.css!github:systemjs/plugin-css@0.1.12", "src/rules-engine-ng2/app/styles/rules-engine.css!github:systemjs/plugin-css@0.1.12", "src/rules-engine-ng2/app/styles/theme-dark.css!github:systemjs/plugin-css@0.1.12", "src/rules-engine-ng2/app/rules-engine-ng2.html!github:systemjs/plugin-text@0.0.2", "src/rules-engine-ng2/app/rule.tpl.html!github:systemjs/plugin-text@0.0.2", "src/rules-engine-ng2/app/rule-action.tpl.html!github:systemjs/plugin-text@0.0.2", "src/rules-engine-ng2/app/clause-group.tpl.html!github:systemjs/plugin-text@0.0.2", "src/rules-engine-ng2/app/clause.tpl.html!github:systemjs/plugin-text@0.0.2"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine-ng2/app/rules-engine-ng2.ts";
  var assert,
      XDebug,
      log,
      Reflect,
      bootstrap,
      For,
      If,
      Component,
      Directive,
      View,
      FormBuilder,
      Validators,
      FormDirectives,
      ControlGroup,
      Core,
      RuleEngine,
      rulesEngineTemplate,
      ruleTemplate,
      ruleActionTemplate,
      clauseGroupTemplate,
      clauseTemplate,
      RuleActionComponent,
      ClauseComponent,
      ClauseGroupComponent,
      RuleComponent,
      RulesEngine;
  function main() {
    log("Bootstrapping rules engine");
    return bootstrap(RulesEngine);
  }
  $__export("main", main);
  return {
    setters: [function($__m) {
      assert = $__m.assert;
    }, function($__m) {
      XDebug = $__m.default;
    }, function($__m) {
      Reflect = $__m.default;
    }, function($__m) {
      bootstrap = $__m.bootstrap;
      For = $__m.For;
      If = $__m.If;
    }, function($__m) {
      Component = $__m.Component;
      Directive = $__m.Directive;
    }, function($__m) {
      View = $__m.View;
    }, function($__m) {
      FormBuilder = $__m.FormBuilder;
      Validators = $__m.Validators;
      FormDirectives = $__m.FormDirectives;
      ControlGroup = $__m.ControlGroup;
    }, function($__m) {
      Core = $__m.Core;
    }, function($__m) {
      RuleEngine = $__m;
    }, function($__m) {}, function($__m) {}, function($__m) {}, function($__m) {
      rulesEngineTemplate = $__m.default;
    }, function($__m) {
      ruleTemplate = $__m.default;
    }, function($__m) {
      ruleActionTemplate = $__m.default;
    }, function($__m) {
      clauseGroupTemplate = $__m.default;
    }, function($__m) {
      clauseTemplate = $__m.default;
    }],
    execute: function() {
      log = XDebug('RulesEngineNg2.RulesEngineComponent');
      RuleActionComponent = (function() {
        function RuleActionComponent(b) {
          assert.argumentTypes(b, FormBuilder);
          this.builder = b;
        }
        return ($traceurRuntime.createClass)(RuleActionComponent, {
          get _ruleAction() {
            return assert.returnType((this.$__0), $traceurRuntime.type.any);
          },
          set _ruleAction(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__0 = value;
          },
          get form() {
            return assert.returnType((this.$__1), ControlGroup);
          },
          set form(value) {
            assert.argumentTypes(value, ControlGroup);
            this.$__1 = value;
          },
          get rule() {
            return assert.returnType((this.$__2), $traceurRuntime.type.any);
          },
          set rule(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__2 = value;
          },
          get index() {
            return assert.returnType((this.$__3), $traceurRuntime.type.number);
          },
          set index(value) {
            assert.argumentTypes(value, $traceurRuntime.type.number);
            this.$__3 = value;
          },
          get builder() {
            return assert.returnType((this.$__4), FormBuilder);
          },
          set builder(value) {
            assert.argumentTypes(value, FormBuilder);
            this.$__4 = value;
          },
          get ruleAction() {
            return assert.returnType((this._ruleAction), $traceurRuntime.type.any);
          },
          set ruleAction(ruleAction) {
            var $__22 = this;
            assert.argumentTypes(ruleAction, $traceurRuntime.type.any);
            var ruleActionControl = this.builder.group({"name": [ruleAction.name, Validators.required]});
            ruleActionControl.controls.name.valueChanges.toRx().debounce(500).subscribe((function(v) {
              $__22._ruleAction = $__22._ruleAction.clone().withName(v).build();
              $__22.saveChanges();
            }));
            this.form = ruleActionControl;
            this._ruleAction = ruleAction;
          },
          addRuleAction: function() {},
          saveChanges: function() {},
          onChange: function(action) {},
          removeRuleAction: function() {}
        }, {});
      }());
      Object.defineProperty(RuleActionComponent, "annotations", {get: function() {
          return [new Component({
            selector: 'rule-action',
            properties: {
              "rule": "rule",
              "ruleAction": "rule-action",
              "index": "index"
            }
          }), new View({
            template: ruleActionTemplate,
            directives: [FormDirectives, If, For],
            injectables: [FormBuilder]
          })];
        }});
      Object.defineProperty(RuleActionComponent, "parameters", {get: function() {
          return [[FormBuilder]];
        }});
      Object.defineProperty(Object.getOwnPropertyDescriptor(RuleActionComponent.prototype, "ruleAction").set, "parameters", {get: function() {
          return [[$traceurRuntime.type.any]];
        }});
      ClauseComponent = (function() {
        function ClauseComponent() {
          this.clauseTypes = [{
            id: 'hello',
            text: 'foo'
          }, {
            id: 'goodbye',
            text: 'bar'
          }];
          this.comparisons = [{
            id: 'compHello',
            text: 'cFoo'
          }, {
            id: 'compGoodbye',
            text: 'cBar'
          }];
        }
        return ($traceurRuntime.createClass)(ClauseComponent, {
          get _clause() {
            return assert.returnType((this.$__5), $traceurRuntime.type.any);
          },
          set _clause(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__5 = value;
          },
          get group() {
            return assert.returnType((this.$__6), $traceurRuntime.type.any);
          },
          set group(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__6 = value;
          },
          get rule() {
            return assert.returnType((this.$__7), $traceurRuntime.type.any);
          },
          set rule(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__7 = value;
          },
          get index() {
            return assert.returnType((this.$__8), $traceurRuntime.type.number);
          },
          set index(value) {
            assert.argumentTypes(value, $traceurRuntime.type.number);
            this.$__8 = value;
          },
          get clauseTypes() {
            return assert.returnType((this.$__9), Array);
          },
          set clauseTypes(value) {
            assert.argumentTypes(value, Array);
            this.$__9 = value;
          },
          get comparisons() {
            return assert.returnType((this.$__10), Array);
          },
          set comparisons(value) {
            assert.argumentTypes(value, Array);
            this.$__10 = value;
          },
          get clause() {
            return this._clause;
          },
          set clause(clause) {
            this._clause = clause;
          },
          onChange: function(action) {},
          addClause: function(rule, group) {},
          removeClause: function() {},
          toggleOperator: function() {}
        }, {});
      }());
      Object.defineProperty(ClauseComponent, "annotations", {get: function() {
          return [new Component({
            selector: 'clause',
            properties: {
              "rule": "rule",
              "group": "group",
              "clause": "clause",
              "index": "index"
            }
          }), new View({
            template: clauseTemplate,
            directives: [FormDirectives, If, For]
          })];
        }});
      ClauseGroupComponent = (function() {
        function ClauseGroupComponent() {
          this.clauses = null;
          this.isCollapse = true;
        }
        return ($traceurRuntime.createClass)(ClauseGroupComponent, {
          get _group() {
            return this.$__11;
          },
          set _group(value) {
            this.$__11 = value;
          },
          get rule() {
            return this.$__12;
          },
          set rule(value) {
            this.$__12 = value;
          },
          get index() {
            return assert.returnType((this.$__13), $traceurRuntime.type.number);
          },
          set index(value) {
            assert.argumentTypes(value, $traceurRuntime.type.number);
            this.$__13 = value;
          },
          get clauses() {
            return assert.returnType((this.$__14), Array);
          },
          set clauses(value) {
            assert.argumentTypes(value, Array);
            this.$__14 = value;
          },
          get isCollapse() {
            return assert.returnType((this.$__15), $traceurRuntime.type.any);
          },
          set isCollapse(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__15 = value;
          },
          get group() {
            return this._group;
          },
          set group(group) {
            this._group = group;
            var idx = 1;
            this.clauses = [{
              $key: 'rule0' + idx + '-group02-clause01',
              type: 'IsAuthenticated',
              name: 'User is authenticated',
              owningGroup: 'rule0' + idx + '-group02',
              value: true,
              operator: 'AND'
            }, {
              $key: 'rule0' + idx + '-group02-clause02',
              type: 'VisitorLocation',
              name: 'User is visiting from france',
              owningGroup: 'rule0' + idx + '-group02',
              value: 'CA',
              operator: 'AND'
            }];
          },
          onChange: function(action) {},
          addGroup: function(rule) {
            assert.argumentTypes(rule, $traceurRuntime.type.any);
          },
          removeGroup: function() {},
          toggleOperator: function(rule, group) {},
          toggleCollapse: function() {
            this.isCollapse = !this.isCollapse;
          }
        }, {});
      }());
      Object.defineProperty(ClauseGroupComponent, "annotations", {get: function() {
          return [new Component({
            selector: 'clause-group',
            properties: {
              "rule": "rule",
              "group": "group",
              "index": "index"
            }
          }), new View({
            template: clauseGroupTemplate,
            directives: [ClauseComponent, FormDirectives, If, For]
          })];
        }});
      Object.defineProperty(ClauseGroupComponent.prototype.addGroup, "parameters", {get: function() {
          return [[$traceurRuntime.type.any]];
        }});
      RuleComponent = (function() {
        function RuleComponent(b) {
          assert.argumentTypes(b, FormBuilder);
          this.builder = b;
          this.isCollapse = true;
        }
        return ($traceurRuntime.createClass)(RuleComponent, {
          get _rule() {
            return assert.returnType((this.$__16), $traceurRuntime.type.any);
          },
          set _rule(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__16 = value;
          },
          get form() {
            return assert.returnType((this.$__17), ControlGroup);
          },
          set form(value) {
            assert.argumentTypes(value, ControlGroup);
            this.$__17 = value;
          },
          get index() {
            return assert.returnType((this.$__18), $traceurRuntime.type.number);
          },
          set index(value) {
            assert.argumentTypes(value, $traceurRuntime.type.number);
            this.$__18 = value;
          },
          get builder() {
            return assert.returnType((this.$__19), FormBuilder);
          },
          set builder(value) {
            assert.argumentTypes(value, FormBuilder);
            this.$__19 = value;
          },
          get isCollapse() {
            return assert.returnType((this.$__20), $traceurRuntime.type.any);
          },
          set isCollapse(value) {
            assert.argumentTypes(value, $traceurRuntime.type.any);
            this.$__20 = value;
          },
          get rule() {
            return assert.returnType((this._rule), $traceurRuntime.type.any);
          },
          set rule(rule) {
            this._rule = rule;
            var ruleControl = this.builder.group({"name": [rule.name, Validators.required]});
            ruleControl.controls.name.valueChanges.toRx().subscribe((function(v) {
              return log("it changed: ", v);
            }));
            this.form = ruleControl;
          },
          addRule: function() {
            log('ADD RULE');
            RuleEngine.api.ruleRepo.push({
              $key: Core.Key.next(),
              enabled: true,
              groups: [{
                $key: Core.Key.next(),
                enabled: true
              }]
            });
          },
          toggleCollapse: function() {
            this.isCollapse = !this.isCollapse;
          },
          removeRule: function() {}
        }, {});
      }());
      Object.defineProperty(RuleComponent, "annotations", {get: function() {
          return [new Component({
            selector: 'rule',
            properties: {
              "rule": "rule",
              "index": "index"
            },
            injectables: [FormBuilder]
          }), new View({
            template: ruleTemplate,
            directives: [RuleActionComponent, ClauseGroupComponent, FormDirectives, If, For]
          })];
        }});
      Object.defineProperty(RuleComponent, "parameters", {get: function() {
          return [[FormBuilder]];
        }});
      Object.defineProperty(Object.getOwnPropertyDescriptor(RuleComponent.prototype, "rule").set, "parameters", {get: function() {
          return [[$traceurRuntime.type.any]];
        }});
      RulesEngine = (function() {
        function RulesEngine() {
          this.rules = [];
          log("creating rules engine");
          RuleEngine.store.addChangeListener(this.onChange.bind(this));
          RuleEngine.store.init();
        }
        return ($traceurRuntime.createClass)(RulesEngine, {
          get rules() {
            return assert.returnType((this.$__21), Array);
          },
          set rules(value) {
            assert.argumentTypes(value, Array);
            this.$__21 = value;
          },
          onChange: function(event) {
            var $__22 = this;
            RuleEngine.store.get().then((function(rulesAry) {
              return $__22.rules = rulesAry;
            }));
          },
          nameFieldKeyUp: function(event, rule, foo) {
            log("key typed", arguments);
          }
        }, {});
      }());
      Object.defineProperty(RulesEngine, "annotations", {get: function() {
          return [new Component({selector: 'rules-engine'}), new View({
            template: rulesEngineTemplate,
            directives: [FormDirectives, For, RuleComponent, If]
          })];
        }});
    }
  };
});

System.register("src/rules-engine-ng2/index.es6", ["src/rules-engine-ng2/app/rules-engine-ng2.ts"], function($__export) {
  "use strict";
  var __moduleName = "src/rules-engine-ng2/index.es6";
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("index", ["npm:zone.js@0.4.4", "npm:debug@2.2.0", "src/dc/index.es6", "src/rules-engine-ng2/index.es6", "src/rules-engine-ng2/log-config.es6", "src/rules-engine/datamocks/rule.mocks.es6"], function($__export) {
  "use strict";
  var __moduleName = "index";
  var XDebug,
      Core,
      RulesEngine,
      logConfig,
      mocks,
      dot,
      root;
  return {
    setters: [function($__m) {}, function($__m) {
      XDebug = $__m;
    }, function($__m) {
      Core = $__m;
    }, function($__m) {
      RulesEngine = $__m;
    }, function($__m) {
      logConfig = $__m;
    }, function($__m) {
      mocks = $__m.mocks;
    }],
    execute: function() {
      dot = {
        XDebug: XDebug.default,
        Core: Core,
        RulesEngine: RulesEngine
      };
      $__export("dot", dot);
      root = dot;
      root.XDebug.disable();
      root.XDebug.enable("*, .*");
      mocks.init().then(function() {
        root.RulesEngine.main().then(function() {
          console.log("Loaded rules-engine component.");
        });
      });
      console.log("Loading rules-engine component.");
      RulesEngine.main();
    }
  };
});

System.register('github:twbs/bootstrap@3.3.4/css/bootstrap.css!github:systemjs/plugin-css@0.1.12', [], false, function() {});
System.register('src/rules-engine-ng2/app/styles/rules-engine.css!github:systemjs/plugin-css@0.1.12', [], false, function() {});
System.register('src/rules-engine-ng2/app/styles/theme-dark.css!github:systemjs/plugin-css@0.1.12', [], false, function() {});
(function(c){var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("/*!\n * Bootstrap v3.3.4 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n *//*! normalize.css v3.0.2 | MIT License | git.io/normalize */body,figure{margin:0}*,:after,:before,input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.pre-scrollable{max-height:340px}.popover>.arrow,.popover>.arrow:after,.tooltip-arrow{width:0;height:0;border-color:transparent;border-style:solid}.breadcrumb,.dropdown-menu,.list-inline,.list-unstyled,.media-list,.nav,.pager{list-style:none}html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;font-size:10px;-webkit-tap-highlight-color:transparent}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}b,optgroup,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{color:#000;background:#ff0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0;vertical-align:middle}svg:not(:root){overflow:hidden}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre,textarea{overflow:auto}code,kbd,pre,samp{font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{blockquote,img,pre,tr{page-break-inside:avoid}*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href)\")\"}abbr[title]:after{content:\" (\" attr(title)\")\"}a[href^=\"javascript:\"]:after,a[href^=\"#\"]:after{content:\"\"}blockquote,pre{border:1px solid #999}thead{display:table-header-group}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}select{background:#fff!important}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}.btn,.btn-danger.active,.btn-danger:active,.btn-default.active,.btn-default:active,.btn-info.active,.btn-info:active,.btn-primary.active,.btn-primary:active,.btn-warning.active,.btn-warning:active,.btn.active,.btn:active,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover,.form-control,.navbar-toggle,.open>.dropdown-toggle.btn-danger,.open>.dropdown-toggle.btn-default,.open>.dropdown-toggle.btn-info,.open>.dropdown-toggle.btn-primary,.open>.dropdown-toggle.btn-warning{background-image:none}@font-face{font-family:'Glyphicons Halflings';src:url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.eot);src:url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.eot?#iefix)format('embedded-opentype'),url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.woff2)format('woff2'),url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.woff)format('woff'),url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.ttf)format('truetype'),url(jspm_packages/github/twbs/bootstrap@3.3.4/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular)format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\2a\"}.glyphicon-plus:before{content:\"\\2b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before,.glyphicon-btc:before,.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-jpy:before,.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-rub:before,.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}address,blockquote .small,blockquote footer,blockquote small,dd,dt,pre{line-height:1.42857143}dt,kbd kbd,label{font-weight:700}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:hover{background-color:#e4b9b9}pre code,table{background-color:transparent}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}dl,ol,ul{margin-top:0}ol,ul{margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0}.list-inline{padding-left:0;margin-left:-5px}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-bottom:20px}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;color:#777}code,kbd{font-size:90%}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}caption,th{text-align:left}code,kbd{padding:2px 4px}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}.popover,.tooltip{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif}code{color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}.container,.container-fluid{margin-right:auto;margin-left:auto}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;border-radius:0}.badge,.btn,.dropdown-header,.dropdown-menu>li>a,.input-group-btn,.label{white-space:nowrap}.container,.container-fluid{padding-right:15px;padding-left:15px}.pre-scrollable{overflow-y:scroll}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}caption{padding-top:8px;padding-bottom:8px;color:#777}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}fieldset,legend{border:0;padding:0}.table-bordered,.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover,.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.btn-group>.btn-group,.btn-toolbar .btn-group,.btn-toolbar .input-group,.dropdown-menu{float:left}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;margin:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px}.checkbox,.form-control,.radio,input[type=file],output{display:block}input[type=search]{-webkit-appearance:none}input[type=checkbox],input[type=radio]{margin:4px 0 0;line-height:normal}.form-control,output{line-height:1.42857143}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=checkbox]:focus,input[type=radio]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{padding-top:7px;font-size:14px;color:#555}.form-control{width:100%;height:34px;padding:6px 12px;font-size:14px;background-color:#fff;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-group-sm .form-control,.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .form-control-feedback,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date],input[type=time],input[type=datetime-local],input[type=month]{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}.checkbox-inline.disabled,.checkbox.disabled label,.radio-inline.disabled,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio label,fieldset[disabled] .radio-inline,fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;line-height:1.5}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;line-height:1.5}.form-group-lg .form-control,.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}select.form-group-sm .form-control{height:30px;line-height:30px}select[multiple].form-group-sm .form-control,textarea.form-group-sm .form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:5px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;line-height:1.3333333}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;line-height:1.3333333}select.form-group-lg .form-control{height:46px;line-height:46px}select[multiple].form-group-lg .form-control,textarea.form-group-lg .form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:10px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.collapsing,.dropdown,.dropup{position:relative}.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .form-control-feedback,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .form-control-feedback,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.btn-block,input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}.form-horizontal .has-feedback .form-control-feedback{right:15px}.dropdown-menu-right,.dropdown-menu.pull-right{left:auto;right:0}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}.form-horizontal .form-group-lg .control-label{padding-top:14.33px}.form-horizontal .form-group-sm .control-label{padding-top:6px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{pointer-events:none;cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.active,.btn-default.focus,.btn-default:active,.btn-default:focus,.btn-default:hover,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.disabled,.btn-default.disabled.active,.btn-default.disabled.focus,.btn-default.disabled:active,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled],.btn-default[disabled].active,.btn-default[disabled].focus,.btn-default[disabled]:active,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default.active,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.active,.btn-primary.focus,.btn-primary:active,.btn-primary:focus,.btn-primary:hover,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.disabled,.btn-primary.disabled.active,.btn-primary.disabled.focus,.btn-primary.disabled:active,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled],.btn-primary[disabled].active,.btn-primary[disabled].focus,.btn-primary[disabled]:active,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary.active,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.active,.btn-success.focus,.btn-success:active,.btn-success:focus,.btn-success:hover,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled,.btn-success.disabled.active,.btn-success.disabled.focus,.btn-success.disabled:active,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled],.btn-success[disabled].active,.btn-success[disabled].focus,.btn-success[disabled]:active,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success.active,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.active,.btn-info.focus,.btn-info:active,.btn-info:focus,.btn-info:hover,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.disabled,.btn-info.disabled.active,.btn-info.disabled.focus,.btn-info.disabled:active,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled],.btn-info[disabled].active,.btn-info[disabled].focus,.btn-info[disabled]:active,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info.active,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.active,.btn-warning.focus,.btn-warning:active,.btn-warning:focus,.btn-warning:hover,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.disabled,.btn-warning.disabled.active,.btn-warning.disabled.focus,.btn-warning.disabled:active,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled],.btn-warning[disabled].active,.btn-warning[disabled].focus,.btn-warning[disabled]:active,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning.active,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.active,.btn-danger.focus,.btn-danger:active,.btn-danger:focus,.btn-danger:hover,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.disabled,.btn-danger.disabled.active,.btn-danger.disabled.focus,.btn-danger.disabled:active,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled],.btn-danger[disabled].active,.btn-danger[disabled].focus,.btn-danger[disabled]:active,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger.active,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.dropdown-header,.dropdown-menu>li>a{display:block;padding:3px 20px;line-height:1.42857143}.btn-block{display:block}.btn-block+.btn-block{margin-top:5px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-right:4px solid transparent;border-left:4px solid transparent}.input-group-addon:last-child,.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.input-group-addon:first-child,.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.btn-group-vertical>.btn:not(:first-child):not(:last-child),.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn,.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.dropdown-menu,.input-group-addon,.popover{border:1px solid #ccc}.badge,.input-group-addon,.label,.nav-justified>li>a,.pager,.progress-bar{text-align:center}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{clear:both;font-weight:400;color:#333}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-left{right:auto;left:0}.dropdown-header{font-size:12px;color:#777}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover,.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.nav-justified>.dropdown .dropdown-menu,.nav-tabs.nav-justified>.dropdown .dropdown-menu{left:auto;top:auto}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px solid}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn .caret,.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group,.input-group-btn>.btn+.btn{margin-left:-1px}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group,.input-group-btn,.input-group-btn>.btn,.nav>li,.nav>li>a,.navbar{position:relative}.input-group{display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;background-color:#eee;border-radius:4px}.badge,.label{font-weight:700}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-btn{font-size:0}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.nav{padding-left:0;margin-bottom:0}.nav>li{display:block}.nav>li>a{display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover,.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center;margin-right:0;border-radius:4px}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0;border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-justified>li,.nav-stacked>li{float:none}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li>a{margin-bottom:5px}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.navbar,.navbar-toggle{border:1px solid transparent}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.navbar-form,.panel-heading{border-bottom:1px solid transparent}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{min-height:50px;margin-bottom:20px}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar{border-radius:4px}.navbar-header{float:left}.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.embed-responsive,.modal,.modal-open,.progress{overflow:hidden}@media (max-device-width:480px)and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}.navbar-static-top{z-index:1000;border-width:0 0 1px}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}.navbar-fixed-bottom,.navbar-fixed-top,.navbar-static-top{border-radius:0}.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-toggle{display:none}.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}.breadcrumb>li,.pagination{display:inline-block}.badge,.label{vertical-align:baseline}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-text{float:left;margin-right:15px;margin-left:15px}.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-nav>li>a,.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>li>a,.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{padding-left:0;margin:20px 0;border-radius:4px}.pager li,.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.badge,.label{line-height:1}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:2;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;color:#fff;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;color:#fff;background-color:#777;border-radius:10px}.badge:empty{display:none}.media-object,.thumbnail{display:block}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.jumbotron,.jumbotron .h1,.jumbotron h1{color:inherit}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding:30px 15px;margin-bottom:30px;background-color:#eee}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.alert .alert-link,.close{font-weight:700}.alert,.thumbnail{margin-bottom:20px}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{border-radius:6px}.alert,.panel,.progress,.thumbnail{border-radius:4px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding:48px 0}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;border:1px solid transparent}.alert h4{margin-top:0;color:inherit}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;background-color:#f5f5f5;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-striped .progress-bar-info,.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-striped .progress-bar-danger,.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item{color:#555}a.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.panel-heading>.dropdown .dropdown-toggle,.panel-title,.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-title,.panel>.list-group,.panel>.panel-collapse>.list-group,.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-top-left-radius:3px;border-top-right-radius:3px}.panel-group .panel-heading,.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel-title{margin-top:0;font-size:16px}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.list-group+.panel-footer,.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default>.panel-heading{color:#333}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.carousel-caption,.carousel-control{text-shadow:0 1px 2px rgba(0,0,0,.6)}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-content,.popover{background-clip:padding-box;-webkit-background-clip:padding-box}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{min-height:16.43px;padding:15px;border-bottom:1px solid #e5e5e5}.tooltip.bottom .tooltip-arrow,.tooltip.bottom-left .tooltip-arrow,.tooltip.bottom-right .tooltip-arrow{top:0;border-width:0 5px 5px;border-bottom-color:#000}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-size:12px;font-weight:400;line-height:1.4;filter:alpha(opacity=0);opacity:0}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{left:50%;margin-left:-5px}.tooltip.bottom-left .tooltip-arrow{right:5px;margin-top:-5px}.tooltip.bottom-right .tooltip-arrow{left:5px;margin-top:-5px}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-size:14px;font-weight:400;line-height:1.42857143;text-align:left;white-space:normal;background-color:#fff;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2)}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block}.carousel,.carousel-inner{position:relative}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.bottom>.arrow:after,.popover.left>.arrow:after,.popover.right>.arrow:after,.popover.top>.arrow:after{content:\" \"}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;border-right-width:0;border-left-color:#fff}.carousel-inner{width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000;perspective:1000}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;margin-top:-10px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:transparent;border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center}.carousel-caption .btn,.text-hide{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-15px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-15px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-15px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.hidden,.visible-lg,.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;background-color:transparent;border:0}.clause,.panel-default{border:none}.affix{position:fixed}.section-separator,.section-separator h2{text-align:center;position:relative}@-ms-viewport{width:device-width}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}.visible-xs-block{display:block!important}.visible-xs-inline{display:inline!important}.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px)and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}.visible-sm-block{display:block!important}.visible-sm-inline{display:inline!important}.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px)and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}.visible-md-block{display:block!important}.visible-md-inline{display:inline!important}.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}.visible-lg-block{display:block!important}.visible-lg-inline{display:inline!important}.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px)and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px)and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}.hidden-print{display:none!important}}body,html{background-color:#3e484f;color:#8c9ca8}.clause:nth-child(2n-2),.clause:nth-child(2n-2) .clause-selector{background-color:#f2f2f2}hr{border-top-color:#68757E}.action-item h4.separator{line-height:34px;margin:0;text-align:center}.clause{margin:0}.clause h4.separator{text-align:center}.clause .clause-option{width:410px}.clause:nth-child(2n-2){border-radius:0}.clause-group .panel-title{color:#f2f2f2;line-height:34px;display:inline-block;vertical-align:middle;margin-left:10px}.clause-group>.panel-body{padding:0}.clause-group-separator{margin-bottom:20px}.form-control{color:#3e484f}.panel-default>.panel-heading{border:none;background-color:#68757E}.operations{text-align:right}.page-title-search{margin-top:40px}.page-title-search h1{margin:0}.page-title-search .form-group{margin-bottom:0}.rule{-webkit-box-shadow:0 1px 2px rgba(0,0,0,.5);box-shadow:0 1px 2px rgba(0,0,0,.5);background-color:#384046}.rule-operations label{color:#fff;font-weight:400;margin-right:5px}.rule-operations .separator{display:inline-block;width:1px;border-right:solid 1px #8c9ca8;height:34px;vertical-align:top;margin:0 10px}.rule-title{font-size:18px;font-weight:700;border-color:rgba(0,0,0,.1);box-shadow:none;background-color:rgba(255,255,255,.25)}.rule-title:hover{background-color:#ffc}.rule-title:focus{background-color:#fff}.section-separator h2{background-color:#384046;display:inline-block;margin-top:0;padding:0 20px;z-index:2}.section-separator hr{margin:0;position:relative;top:-27px}");
//# sourceMappingURL=core-web.js.map